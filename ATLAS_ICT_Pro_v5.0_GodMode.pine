// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ATLAS Trading - God Mode v5.0
// CORTEX-POWERED: All ICT concepts derived from 20,833 knowledge chunks from 672 transcripts

//@version=5
indicator("ATLAS ICT Pro v5.0 - GOD MODE [PAC-MAN EDITION]", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ® PAC-MAN GOD MODE - THE CORTEX KNOWS ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This indicator uses ALL ICT concepts from The Cortex (672 transcripts) to
// determine the most probable Draw on Liquidity (DOL) path.
//
// PAC-MAN TERMINOLOGY:
// ğŸŸ¡ PAC-MAN = Price Action (you are the trader following the path)
// ğŸ‘» GHOSTS = Institutional Players / Smart Money hunting stops
// âš« PELLET = Small liquidity (BSL/SSL - equal highs/lows)
// ğŸ”´ POWER PELLET = Major liquidity (EQH/EQL clusters, swing points)
// ğŸ’ CHERRY = PWH/PWL (Previous Week High/Low)
// ğŸŒ€ SPAWN ZONE = OTE Retracement (62-79% fib zone)
// ğŸš‡ TUNNEL = FVG (Fair Value Gap - imbalance to fill)
// ğŸ BONUS = NWOG CE (New Week Opening Gap Consequent Encroachment)
// ğŸšª EXIT = CBDR Standard Deviation projections
// ğŸ¯ MAZE PATH = Draw on Liquidity direction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                           USER INPUTS                                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GOD MODE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_god = "ğŸ® GOD MODE (DOL Engine)"
i_showDOL = input.bool(true, "Show DOL Path (Pac-Man Maze)", group=grp_god)
i_showDOLTable = input.bool(true, "Show DOL Probability Dashboard", group=grp_god)
i_showPacMan = input.bool(true, "Show Pac-Man Visuals", group=grp_god)
i_dolSensitivity = input.string("Medium", "DOL Sensitivity", options=["Low", "Medium", "High"], group=grp_god)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF BIAS SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_htf = "ğŸ“Š HTF BIAS"
i_htfBias = input.bool(true, "Enable HTF Bias Filter", group=grp_htf)
i_htfTimeframe = input.timeframe("240", "HTF Timeframe", group=grp_htf)
i_htfLookback = input.int(20, "HTF Swing Lookback", minval=5, maxval=50, group=grp_htf)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TURTLE SOUP SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ts = "ğŸ¢ TURTLE SOUP"
i_showTurtleSoup = input.bool(true, "Show Turtle Soup Setups", group=grp_ts)
i_tsLookback = input.int(20, "Turtle Soup Lookback", minval=5, maxval=100, group=grp_ts)
i_tsBuffer = input.float(0.0, "Turtle Soup Buffer (ticks)", minval=0, group=grp_ts)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JUDAS SWING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_judas = "ğŸ­ JUDAS SWING"
i_showJudas = input.bool(true, "Show Judas Swing", group=grp_judas)
i_judasSession = input.session("0200-0500", "Judas Session (NY Time)", group=grp_judas)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORDER BLOCK SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ob = "ğŸ“¦ ORDER BLOCKS"
i_showOB = input.bool(true, "Show Order Blocks", group=grp_ob)
i_obLookback = input.int(50, "OB Lookback", minval=10, maxval=200, group=grp_ob)
i_obMitigation = input.string("Wick", "OB Mitigation Type", options=["Wick", "Close", "Avg"], group=grp_ob)
i_obMaxAge = input.int(100, "Max OB Age (bars)", minval=10, maxval=500, group=grp_ob)
i_obShowLifecycle = input.bool(true, "Show OB Lifecycle Labels", group=grp_ob)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FVG/IFVG SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_fvg = "âš¡ FVG / IFVG"
i_showFVG = input.bool(true, "Show Fair Value Gaps", group=grp_fvg)
i_showIFVG = input.bool(true, "Show Inverse FVG (IFVG)", group=grp_fvg)
i_fvgMitigation = input.string("50%", "FVG Mitigation Level", options=["25%", "50%", "75%", "100%"], group=grp_fvg)
i_fvgMinSize = input.float(0.0, "Min FVG Size (ticks)", minval=0, group=grp_fvg)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREAKER / MITIGATION / REJECTION BLOCKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_blocks = "ğŸ§± BREAKER / MIT / REJ BLOCKS"
i_showBreaker = input.bool(true, "Show Breaker Blocks", group=grp_blocks)
i_showMitBlock = input.bool(true, "Show Mitigation Blocks", group=grp_blocks)
i_showRejBlock = input.bool(true, "Show Rejection Blocks", group=grp_blocks)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_liq = "ğŸ’§ LIQUIDITY"
i_showBSL = input.bool(true, "Show Buy Side Liquidity (BSL)", group=grp_liq)
i_showSSL = input.bool(true, "Show Sell Side Liquidity (SSL)", group=grp_liq)
i_showEQH = input.bool(true, "Show Equal Highs", group=grp_liq)
i_showEQL = input.bool(true, "Show Equal Lows", group=grp_liq)
i_eqThreshold = input.float(0.1, "Equal H/L Threshold %", minval=0.01, maxval=1.0, group=grp_liq)
i_liqLookback = input.int(50, "Liquidity Lookback", minval=10, maxval=200, group=grp_liq)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IPDA LOOKBACK SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ipda = "ğŸ“ˆ IPDA DATA RANGES"
i_showIPDA = input.bool(true, "Show IPDA Levels", group=grp_ipda)
i_ipda20 = input.bool(true, "20-Day IPDA", group=grp_ipda)
i_ipda40 = input.bool(true, "40-Day IPDA", group=grp_ipda)
i_ipda60 = input.bool(true, "60-Day IPDA", group=grp_ipda)
i_showPWHL = input.bool(true, "Show Previous Week H/L", group=grp_ipda)
i_showPMHL = input.bool(true, "Show Previous Month H/L", group=grp_ipda)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CBDR SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_cbdr = "ğŸ¦ CBDR (Central Bank Dealers Range)"
i_showCBDR = input.bool(true, "Show CBDR", group=grp_cbdr)
i_cbdrSession = input.session("1400-2000", "CBDR Session (NY Time)", group=grp_cbdr)
i_cbdrSD = input.float(2.5, "CBDR SD Multiplier", minval=0.5, maxval=5.0, step=0.5, group=grp_cbdr)
i_showCBDRProjections = input.bool(true, "Show SD Projections", group=grp_cbdr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NWOG SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_nwog = "ğŸ“… NWOG (New Week Opening Gap)"
i_showNWOG = input.bool(true, "Show NWOG", group=grp_nwog)
i_showNWOGCE = input.bool(true, "Show NWOG Consequent Encroachment", group=grp_nwog)
i_nwogWeeks = input.int(5, "Number of Weeks to Show", minval=1, maxval=10, group=grp_nwog)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKET STRUCTURE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ms = "ğŸ“ MARKET STRUCTURE"
i_showMS = input.bool(true, "Show Market Structure", group=grp_ms)
i_showBOS = input.bool(true, "Show BOS (Break of Structure)", group=grp_ms)
i_showCHoCH = input.bool(true, "Show CHoCH (Change of Character)", group=grp_ms)
i_msLookback = input.int(20, "MS Swing Lookback", minval=5, maxval=50, group=grp_ms)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM/DISCOUNT SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_pd = "âš–ï¸ PREMIUM / DISCOUNT"
i_showPDZones = input.bool(true, "Show Premium/Discount Zones", group=grp_pd)
i_showEQ = input.bool(true, "Show Equilibrium", group=grp_pd)
i_showOTE = input.bool(true, "Show OTE Zone (62-79%)", group=grp_pd)
i_pdLookback = input.int(50, "PD Range Lookback", minval=10, maxval=200, group=grp_pd)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POWER OF THREE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_po3 = "ğŸ”º POWER OF THREE (AMD)"
i_showPO3 = input.bool(true, "Show Power of Three", group=grp_po3)
i_showPO3Labels = input.bool(true, "Show AMD Phase Labels", group=grp_po3)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2022 MODEL SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_2022 = "ğŸ“š 2022 MODEL"
i_show2022 = input.bool(true, "Show 2022 Model Setups", group=grp_2022)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_sess = "â° SESSIONS & KILLZONES"
i_showSessions = input.bool(true, "Show Session Backgrounds", group=grp_sess)
i_showKillzones = input.bool(true, "Highlight Killzones", group=grp_sess)
i_showSilverBullet = input.bool(true, "Show Silver Bullet Windows", group=grp_sess)
i_showMacro = input.bool(true, "Show Macro Times (:50/:10)", group=grp_sess)
i_showMidnight = input.bool(true, "Show Midnight Open", group=grp_sess)
i_timezone = input.string("America/New_York", "Timezone", options=["America/New_York", "America/Chicago", "Europe/London", "Asia/Tokyo"], group=grp_sess)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE SCORING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_comp = "ğŸ† COMPOSITE SCORING (5-Tier System)"
i_showComposite = input.bool(true, "Show Composite Signals", group=grp_comp)
i_tier1Threshold = input.int(90, "Tier 1 ELITE (90%+)", minval=85, maxval=100, group=grp_comp)
i_tier2Threshold = input.int(80, "Tier 2 PREMIUM (80%+)", minval=70, maxval=90, group=grp_comp)
i_tier3Threshold = input.int(65, "Tier 3 STRONG (65%+)", minval=55, maxval=80, group=grp_comp)
i_tier4Threshold = input.int(50, "Tier 4 MODERATE (50%+)", minval=40, maxval=65, group=grp_comp)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLORS (Refined Retro-Arcade Palette)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_colors = "ğŸ¨ COLORS"
i_bullColor = input.color(color.new(#00E676, 0), "Bullish Color", group=grp_colors)  // Neon green
i_bearColor = input.color(color.new(#FF1744, 0), "Bearish Color", group=grp_colors)  // Hot pink-red
i_neutralColor = input.color(color.new(#FFD740, 0), "Neutral Color", group=grp_colors)  // Warm yellow
i_obColor = input.color(color.new(#448AFF, 20), "Order Block Color", group=grp_colors)  // Electric blue
i_fvgColor = input.color(color.new(#7C4DFF, 30), "FVG Color", group=grp_colors)  // Purple
i_liqColor = input.color(color.new(#FF9100, 0), "Liquidity Color", group=grp_colors)  // Orange
i_pacmanColor = input.color(color.new(#FFEB3B, 0), "Pac-Man Color", group=grp_colors)  // Classic yellow

// Visual Style Settings
grp_style = "ğŸ¨ VISUAL STYLE"
i_tableStyle = input.string("Minimal", "Dashboard Style", options=["Minimal", "Classic", "Compact"], group=grp_style)
i_boxTransparency = input.int(88, "Zone Box Transparency", minval=70, maxval=95, group=grp_style)
i_labelStyle = input.string("Clean", "Label Style", options=["Clean", "Badge", "Minimal"], group=grp_style)
i_cleanMode = input.bool(false, "ğŸ§¹ Clean Mode (Hide Arcade Visuals)", tooltip="Disables Pac-Man themed elements for a professional trading view", group=grp_style)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRUE DAY SETTINGS (6PM-6PM NY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_trueday = "ğŸŒ™ TRUE DAY"
i_showTrueDay = input.bool(true, "Show True Day Levels", tooltip="ICT's True Day runs from 6PM NY to 6PM NY", group=grp_trueday)
i_showTrueDayOpen = input.bool(true, "Show True Day Open Line", tooltip="Mark the 6PM NY opening price", group=grp_trueday)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LONDON CLOSE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_londonclose = "ğŸ‡¬ğŸ‡§ LONDON CLOSE"
i_showLondonClose = input.bool(true, "Show London Close Manipulation", tooltip="Detects manipulation during London close (11AM-12PM NY)", group=grp_londonclose)
i_lcSession = input.session("1100-1200", "London Close Session", group=grp_londonclose)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WEBHOOK SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_webhook = "ğŸ“¡ WEBHOOK"
i_enableWebhook = input.bool(false, "Enable Webhook Alerts", tooltip="Send JSON alerts for external logging", group=grp_webhook)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        CONSTANTS & ENUMS                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Order Block Lifecycle States
OB_FRESH = 0
OB_PROPULSION = 1
OB_TESTED = 2
OB_MITIGATED = 3
OB_VIOLATED = 4

// Direction
DIR_BULL = 1
DIR_BEAR = -1
DIR_NEUTRAL = 0

// Composite Tiers (5-Tier System)
TIER_1 = 1  // ELITE: 90%+ - Highest probability setups
TIER_2 = 2  // PREMIUM: 80-89% - Very strong setups
TIER_3 = 3  // STRONG: 65-79% - Good setups
TIER_4 = 4  // MODERATE: 50-64% - Developing setups
TIER_5 = 5  // WEAK: Below 50% - Low probability

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        TYPE DEFINITIONS                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Order Block Type
type OrderBlock
    float top
    float bottom
    int startBar
    int direction  // 1 = bullish, -1 = bearish
    int state      // OB_FRESH, OB_PROPULSION, etc.
    bool isBreaker
    box visual
    label stateLabel

// FVG Type
type FVG
    float top
    float bottom
    int startBar
    int direction
    bool mitigated
    float mitLevel
    box visual

// Liquidity Level Type
type LiqLevel
    float level
    int bar
    int touches
    bool swept
    string liqType  // "EQH", "EQL", "SH", "SL"
    line visual

// Swing Point Type
type SwingPoint
    float price
    int bar
    int direction

// Volume Imbalance Type (VI)
type VolumeImbalance
    float top
    float bottom
    int startBar
    int direction  // 1 = bullish (gap up), -1 = bearish (gap down)
    bool filled
    box visual

// Suspension Block Type (Single candle with VI at both ends)
type SuspensionBlock
    float top        // Volume Imbalance HIGH
    float bottom     // Volume Imbalance LOW
    float bodyHigh   // Candle body high
    float bodyLow    // Candle body low
    int startBar
    int direction    // 1 = bullish (up close), -1 = bearish (down close)
    bool mitigated
    bool inverted    // Becomes inversion when traded through
    box visual
    label nameLabel

// Liquidity Void Type (Large single candle with no overlapping wicks)
type LiquidityVoid
    float top
    float bottom
    int startBar
    int direction
    bool filled
    box visual

// Opening Gap Type (NDOG, ORG, etc.)
type OpeningGap
    float top
    float bottom
    int startBar
    string gapType   // "NDOG", "ORG", "NWOG"
    bool filled
    box visual

// Rejection Block Type (Different from Order Block - single candle close rejection)
type RejectionBlock
    float level      // The closing price that gets rejected
    float wickHigh   // Wick high for context
    float wickLow    // Wick low for context
    int startBar
    int direction    // 1 = bullish rejection (down close rejected), -1 = bearish
    bool mitigated
    box visual
    label nameLabel

// Wick Gradient Type (ICT's notepad system - 0/25/50/75/100% levels on wicks)
type WickGradient
    float wick100    // Full wick extent
    float wick75     // 75% level
    float wick50     // Consequent encroachment (midpoint)
    float wick25     // 25% level
    float wick0      // Wick base
    int startBar
    int direction    // 1 = premium wick (high), -1 = discount wick (low)
    bool active
    line line100
    line line75
    line line50
    line line25
    line line0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        GLOBAL VARIABLES                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Arrays for Order Blocks
var array<OrderBlock> bullOBs = array.new<OrderBlock>()
var array<OrderBlock> bearOBs = array.new<OrderBlock>()

// Arrays for FVGs
var array<FVG> bullFVGs = array.new<FVG>()
var array<FVG> bearFVGs = array.new<FVG>()

// Arrays for Liquidity
var array<LiqLevel> bslLevels = array.new<LiqLevel>()
var array<LiqLevel> sslLevels = array.new<LiqLevel>()

// Swing Points
var array<SwingPoint> swingHighs = array.new<SwingPoint>()
var array<SwingPoint> swingLows = array.new<SwingPoint>()

// Arrays for Volume Imbalances
var array<VolumeImbalance> bullVIs = array.new<VolumeImbalance>()
var array<VolumeImbalance> bearVIs = array.new<VolumeImbalance>()

// Arrays for Suspension Blocks
var array<SuspensionBlock> bullSuspBlocks = array.new<SuspensionBlock>()
var array<SuspensionBlock> bearSuspBlocks = array.new<SuspensionBlock>()

// Arrays for Liquidity Voids
var array<LiquidityVoid> bullLiqVoids = array.new<LiquidityVoid>()
var array<LiquidityVoid> bearLiqVoids = array.new<LiquidityVoid>()

// Arrays for Opening Gaps (NDOG, ORG)
var array<OpeningGap> openingGaps = array.new<OpeningGap>()

// NDOG (New Day Opening Gap)
var float ndogHigh = na
var float ndogLow = na
var float ndogCE = na
var bool ndogFilled = false

// ORG (Opening Range Gap) - First 5 min of session
var float orgHigh = na
var float orgLow = na
var float orgCE = na
var bool orgFilled = false
var bool orgTracking = false

// 3-Day ORG Confluence (ICT's lookback system)
var float org1DayAgo = na      // Yesterday's ORG CE
var float org2DaysAgo = na     // 2 days ago ORG CE
var float org3DaysAgo = na     // 3 days ago ORG CE
var int orgDayCount = 0

// Arrays for Rejection Blocks
var array<RejectionBlock> bullRejBlocks = array.new<RejectionBlock>()
var array<RejectionBlock> bearRejBlocks = array.new<RejectionBlock>()

// Arrays for Wick Gradients (ICT's notepad levels)
var array<WickGradient> premiumWicks = array.new<WickGradient>()
var array<WickGradient> discountWicks = array.new<WickGradient>()

// High/Low Resistance Liquidity Run Detection
var string liqRunType = "NEUTRAL"       // "HIGH_RESISTANCE", "LOW_RESISTANCE", "NEUTRAL"
var float liqRunScore = 0.0             // 0-100 score for resistance level
var int consolidationBars = 0           // Bars spent in consolidation
var int reversalCount = 0               // Number of reversals in lookback
var float avgMoveSize = 0.0             // Average move size for comparison
var bool isJaggedMarket = false         // High resistance = jagged price action
var bool isSmoothMarket = false         // Low resistance = smooth price action

// Time-Based Risk Adjustment (ICT's weekly rhythm)
var float timeRiskMultiplier = 1.0      // Adjusts based on day/time
var string timeRiskReason = ""          // Why risk is adjusted
var bool isHighProbTime = false         // Mon 9-11, Tue 8:30-11
var bool isLowProbTime = false          // Wed 11am+, Thu PM, Fri PM

// Discount Sensitivity Detection
var bool discountSensitivity = false    // When 3+ confluences honor gradient levels
var int sensitivityCount = 0            // Number of confluences present
var float sensitivityLevel = na         // The level being tested

// Immediate Rebalance Pattern Detection
// ICT: "Next day we open and trade back down... offering an immediate rebalance"
var bool immediateRebalanceBull = false
var bool immediateRebalanceBear = false
var float rebalanceLevel = na
var int rebalanceBar = 0

// Market Maker Buy/Sell Model (9/18 EMA)
// ICT: "Market makers will generally price markets lower to buy into that drop"
var string mmModel = "NEUTRAL"          // "BUY_MODEL", "SELL_MODEL", "NEUTRAL"
var bool mmModelBullish = false         // 9 < 18 = Buy Model active
var bool mmModelBearish = false         // 9 > 18 = Sell Model active

// Power of Three Maturity (Young vs Mature Swings)
// ICT: "Daily swings are maturing into key support resistance"
var int swingHighAge = 0                // Days since swing high formed
var int swingLowAge = 0                 // Days since swing low formed
var bool matureSwingHigh = false        // 5+ days = mature
var bool matureSwingLow = false
var bool youngSwingHigh = false         // 1-3 days = young
var bool youngSwingLow = false

// Longest Wick CE Detection
// ICT: "Consequent encroachment of the longest wick... that's the one that matters"
var float longestWickCE = na            // CE of the longest wick in lookback
var float longestWickHigh = na
var float longestWickLow = na
var int longestWickBar = 0
var int longestWickDirection = 0        // 1 = upper wick, -1 = lower wick

// Institutional Order Flow Drill Entry
// ICT: "Entry into a partial fair value gap"
var bool iofDrillLong = false
var bool iofDrillShort = false
var float iofEntryLevel = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ•¹ï¸ PAC-MAN ARCADE STATE VARIABLES ğŸ•¹ï¸
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Game State: ATTRACT, READY, PLAYING, POWER_MODE, LEVEL_COMPLETE, GAME_OVER
var string gameState = "ATTRACT"
var int arcadeScore = 0                  // Running score based on confluences
var int highScore = 0                    // Best score this session
var int comboCount = 0                   // Consecutive confluence hits
var int comboMultiplier = 1              // Score multiplier from combos

// Power Mode (all conditions aligned)
var bool powerModeActive = false
var int powerModeTimer = 0               // Bars remaining in power mode
var int POWER_MODE_DURATION = 15         // Bars of power mode

// Fruit R:R Targets (appears when in a trade setup)
// ğŸ’=1R, ğŸ“=1.5R, ğŸŠ=2R, ğŸ=2.5R, ğŸ‡=3R, ğŸš€=4R, ğŸ””=5R, ğŸ”‘=DOL
var string currentFruit = ""
var float fruitTarget = na

// Ghost Eaten Scoring (when liquidity is swept)
var int ghostsEaten = 0                  // Count of sweeps this session
var int lastGhostPoints = 0              // Points from last ghost eaten

// Level System (based on composite tier)
var int currentLevel = 1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š SETUP TRACKING SYSTEM - Performance Analytics
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trade tracking type
type TradeRecord
    int barIndex           // When setup was generated
    string setupType       // Pattern name
    int tier              // 1-5 tier
    int direction         // 1=long, -1=short
    float entryPrice      // Entry level
    float stopLoss        // Stop loss level
    float target          // Target level
    float rr              // Risk:Reward
    string outcome        // "PENDING", "WIN", "LOSS", "BREAKEVEN"
    float pnlPercent      // Actual P&L %
    int confluenceCount   // Number of confluences
    bool inKillzone       // Was in killzone
    bool inOTE            // Was in OTE

// Session tracking arrays (max 100 trades per session)
var array<TradeRecord> sessionTrades = array.new<TradeRecord>()

// Session statistics
var int sessionWins = 0
var int sessionLosses = 0
var int sessionPending = 0
var float sessionTotalRR = 0.0
var float sessionBestRR = 0.0
var float sessionWorstRR = 0.0
var int totalSetupsGenerated = 0

// Tier-specific tracking
var int tier1Wins = 0
var int tier1Losses = 0
var int tier2Wins = 0
var int tier2Losses = 0
var int tier3Wins = 0
var int tier3Losses = 0

// Pattern-specific tracking (top 5 patterns)
var int unicornWins = 0
var int unicornLosses = 0
var int mmxmWins = 0
var int mmxmLosses = 0
var int model2022Wins = 0
var int model2022Losses = 0
var int turtleSoupWins = 0
var int turtleSoupLosses = 0
var int judasWins = 0
var int judasLosses = 0

// Current active trade tracking
var bool hasActiveTrade = false
var float activeEntry = na
var float activeStop = na
var float activeTarget = na
var int activeDirection = 0
var int activeBar = 0
var string activePattern = ""
var int activeTier = 0

// Market Structure
var int msDirection = 0
var float lastSwingHigh = na
var float lastSwingLow = na
var int lastSwingHighBar = 0
var int lastSwingLowBar = 0
var bool bosDetected = false
var bool chochDetected = false

// HTF Bias
var int htfBias = 0
var bool htfBullValid = false
var bool htfBearValid = false

// CBDR
var float cbdrHigh = na
var float cbdrLow = na
var float cbdrRange = na
var bool inCBDR = false

// NWOG - Arrays for multiple weeks
var float[] nwogHighs = array.new_float(0)
var float[] nwogLows = array.new_float(0)
var float[] nwogCEs = array.new_float(0)
var bool newWeekStart = false
// Keep single variables for backward compatibility with confluence
var float nwogHigh = na
var float nwogLow = na
var float nwogCE = na

// Power of Three
var string po3Phase = "ACCUMULATION"
var float accumulationHigh = na
var float accumulationLow = na

// DOL Engine
var float dolTarget = na
var int dolDirection = 0
var float dolProbability = 0.0
var string dolReason = ""

// Turtle Soup with Stalking Stages
var float recentSwingHigh = na
var float recentSwingLow = na
var bool swingHighSwept = false
var bool swingLowSwept = false
var int tsStalking = 0  // 0 = none, 1 = stalking high, -1 = stalking low
var string tsStage = "NONE"  // STALK, TRAP, CONFIRM, INVALID
var int tsStageBar = 0
var float tsEntryPrice = na

// Session tracking
var float asianHigh = na
var float asianLow = na
var float londonHigh = na
var float londonLow = na
var float nyHigh = na
var float nyLow = na
var float midnightOpen = na

// AMD (Power of 3) Engine - TRUE price-based detection
var int amdPhase = 0           // 0=None, 1=Accumulation, 2=Manipulation, 3=Distribution
var string amdStatus = ""       // Detailed status message
var bool asianHighSwept = false // Has Asian high been swept?
var bool asianLowSwept = false  // Has Asian low been swept?
var bool manipulationComplete = false  // Has Judas/manipulation finished?
var int manipDirection = 0      // Direction of manipulation: 1=swept high (fake bull), -1=swept low (fake bear)
var int expectedDirection = 0   // Expected true direction after manipulation: 1=bull, -1=bear
var float manipulationSwingHigh = na  // High of the manipulation move
var float manipulationSwingLow = na   // Low of the manipulation move
var bool distributionStarted = false  // Has true move begun?
var float amdEntryZoneTop = na  // Optimal entry zone after manipulation
var float amdEntryZoneBottom = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SEQUENCING - Multi-target DOL tracking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Previous Day High/Low
var float pdh = na
var float pdl = na
var bool pdhSwept = false
var bool pdlSwept = false
var int pdhSweptBar = na
var int pdlSweptBar = na

// Previous Week High/Low
var float pwh = na
var float pwl = na
var bool pwhSwept = false
var bool pwlSwept = false

// Session liquidity sweep tracking
var bool londonHighSwept = false
var bool londonLowSwept = false
var bool nyHighSwept = false
var bool nyLowSwept = false

// Day/Week tracking
var int currentDay = na
var int currentWeek = na
var float dayHigh = na
var float dayLow = na
var float weekHigh = na
var float weekLow = na

// Composite Score
var float compositeScore = 0.0
var int compositeTier = 0
var string patternName = ""

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        HELPER FUNCTIONS                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if in session
f_inSession(string sess) =>
    not na(time(timeframe.period, sess, i_timezone))

// Get current NY hour
f_nyHour() =>
    hour(time, i_timezone)

// Get current NY minute
f_nyMinute() =>
    minute(time, i_timezone)

// Calculate tick size
f_tickSize() =>
    syminfo.mintick

// Check if price is in range
f_inRange(float price, float top, float bottom) =>
    price >= bottom and price <= top

// Get mitigation percentage value
f_getMitPct() =>
    i_fvgMitigation == "25%" ? 0.25 : i_fvgMitigation == "50%" ? 0.50 : i_fvgMitigation == "75%" ? 0.75 : 1.0

// Clean old visuals from array
f_cleanOldOBs(array<OrderBlock> obs, int maxAge) =>
    if array.size(obs) > 0
        for i = array.size(obs) - 1 to 0
            ob = array.get(obs, i)
            if bar_index - ob.startBar > maxAge or ob.state == OB_VIOLATED
                if not na(ob.visual)
                    box.delete(ob.visual)
                if not na(ob.stateLabel)
                    label.delete(ob.stateLabel)
                array.remove(obs, i)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SESSION DETECTION                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

nyHour = f_nyHour()
nyMinute = f_nyMinute()

// Session definitions (NY Time)
asianSession = nyHour >= 20 or nyHour < 0
londonSession = nyHour >= 2 and nyHour < 5
londonOpen = nyHour >= 3 and nyHour < 4
nyAMSession = nyHour >= 9 and nyHour < 12
nyPMSession = nyHour >= 13 and nyHour < 16
nyAMOpen = nyHour >= 9 and nyHour < 10

// Killzones
asianKZ = nyHour >= 20 or nyHour < 0
londonKZ = nyHour >= 2 and nyHour < 5
nyAMKZ = nyHour >= 9 and nyHour < 11
nyPMKZ = nyHour >= 13 and nyHour < 15

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SILVER BULLET WINDOWS - Full hour windows per ICT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// London Silver Bullet: 3:00-4:00 AM NY
sb1 = nyHour == 3
// NY AM Silver Bullet: 10:00-11:00 AM NY
sb2 = nyHour == 10
// NY PM Silver Bullet: 2:00-3:00 PM NY
sb3 = nyHour == 14
inSilverBullet = sb1 or sb2 or sb3

// Silver Bullet Phase (for timing entries)
sbPhase = inSilverBullet ? (nyMinute < 20 ? "EARLY" : nyMinute < 40 ? "PRIME" : "LATE") : ""
sbPrime = inSilverBullet and nyMinute >= 10 and nyMinute <= 40  // Best window within SB

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACRO TIMES - ICT's time-based edge
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// :00 Top of Hour - Major liquidity events
macroTopOfHour = nyMinute >= 58 or nyMinute <= 2
// :30 Mid Hour - Secondary liquidity
macroMidHour = nyMinute >= 28 and nyMinute <= 32
// :50 Pre-Hour - Reversal window (last 10 min before hour)
macroPreHour = nyMinute >= 50 and nyMinute <= 57

isMacroTime = macroTopOfHour or macroMidHour or macroPreHour
macroType = macroTopOfHour ? ":00" : macroMidHour ? ":30" : macroPreHour ? ":50" : ""

// Power Hour windows (high volatility)
isPowerHour = (nyHour == 9 and nyMinute >= 30) or (nyHour == 10 and nyMinute < 30) or  // NY Open
              (nyHour == 15 and nyMinute >= 0 and nyMinute < 30)  // Last 30 min

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEEK & DESTROY DAYS - Wed/Thu often reverse
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
dayOfWeek = dayofweek(time, i_timezone)
isSeekDestroyDay = dayOfWeek == dayofweek.wednesday or dayOfWeek == dayofweek.thursday
isAccumulationDay = dayOfWeek == dayofweek.monday or dayOfWeek == dayofweek.tuesday
isExpansionDay = dayOfWeek == dayofweek.friday

// Midnight detection
isMidnight = nyHour == 0 and nyMinute == 0

// CBDR Session
inCBDRSession = f_inSession(i_cbdrSession)

// Judas Session
inJudasSession = f_inSession(i_judasSession)

// London Close Session (11AM-12PM NY)
inLondonCloseSession = f_inSession(i_lcSession)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRUE DAY DETECTION (6PM-6PM NY) - ICT's Institutional Trading Day
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float trueDayOpen = na
var float trueDayHigh = na
var float trueDayLow = na
var bool trueDayReset = false

// Detect 6PM NY (True Day Open)
isTrueDayOpen = nyHour == 18 and nyMinute == 0

if isTrueDayOpen and i_showTrueDay
    trueDayOpen := close
    trueDayHigh := high
    trueDayLow := low
    trueDayReset := true
else
    trueDayReset := false
    if i_showTrueDay and not na(trueDayHigh)
        if high > trueDayHigh
            trueDayHigh := high
        if low < trueDayLow
            trueDayLow := low

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LONDON CLOSE MANIPULATION DETECTION (11AM-12PM NY)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var float londonCloseHigh = na
var float londonCloseLow = na
var bool inLondonClose = false
var string lcManipulation = "NONE"

if inLondonCloseSession and i_showLondonClose
    if not inLondonClose[1]
        londonCloseHigh := high
        londonCloseLow := low
        inLondonClose := true
        lcManipulation := "NONE"
    else
        if high > londonCloseHigh
            londonCloseHigh := high
        if low < londonCloseLow
            londonCloseLow := low
else if inLondonClose[1] and not inLondonCloseSession
    inLondonClose := false

// Detect manipulation during London Close
if inLondonClose
    if high > londonCloseHigh[1] and close < open
        lcManipulation := "SWEEP_HIGH"
    else if low < londonCloseLow[1] and close > open
        lcManipulation := "SWEEP_LOW"

// London Close reversal signal
lcReversal = not inLondonClose and lcManipulation != "NONE" and
             ((lcManipulation == "SWEEP_HIGH" and msDirection == DIR_BEAR) or
              (lcManipulation == "SWEEP_LOW" and msDirection == DIR_BULL))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   LIQUIDITY LEVELS - PDH/PDL/PWH/PWL                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect new day (using NY timezone)
newDay = dayofweek(time, i_timezone) != dayofweek(time[1], i_timezone)
newWeek = weekofyear(time, i_timezone) != weekofyear(time[1], i_timezone)

// Track daily high/low and update PDH/PDL on new day
if newDay
    // Store yesterday's range as PDH/PDL
    pdh := dayHigh
    pdl := dayLow
    // Reset sweep flags for new day
    pdhSwept := false
    pdlSwept := false
    pdhSweptBar := na
    pdlSweptBar := na
    londonHighSwept := false
    londonLowSwept := false
    nyHighSwept := false
    nyLowSwept := false
    // Reset today's tracking
    dayHigh := high
    dayLow := low
else
    // Update today's high/low
    dayHigh := math.max(nz(dayHigh, high), high)
    dayLow := math.min(nz(dayLow, low), low)

// Track weekly high/low and update PWH/PWL on new week
if newWeek
    // Store last week's range as PWH/PWL
    pwh := weekHigh
    pwl := weekLow
    // Reset sweep flags for new week
    pwhSwept := false
    pwlSwept := false
    // Reset this week's tracking
    weekHigh := high
    weekLow := low
else
    // Update this week's high/low
    weekHigh := math.max(nz(weekHigh, high), high)
    weekLow := math.min(nz(weekLow, low), low)

// Track London session high/low
if londonSession
    if not londonSession[1]
        // Start of London session
        londonHigh := high
        londonLow := low
    else
        londonHigh := math.max(londonHigh, high)
        londonLow := math.min(londonLow, low)

// Track NY session high/low
if nyAMSession or nyPMSession
    if not (nyAMSession[1] or nyPMSession[1])
        // Start of NY session
        nyHigh := high
        nyLow := low
    else
        nyHigh := math.max(nyHigh, high)
        nyLow := math.min(nyLow, low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SWEEP DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// PDH/PDL sweep detection
if not pdhSwept and not na(pdh) and high > pdh
    pdhSwept := true
    pdhSweptBar := bar_index

if not pdlSwept and not na(pdl) and low < pdl
    pdlSwept := true
    pdlSweptBar := bar_index

// PWH/PWL sweep detection
if not pwhSwept and not na(pwh) and high > pwh
    pwhSwept := true

if not pwlSwept and not na(pwl) and low < pwl
    pwlSwept := true

// London session sweep detection
if not londonHighSwept and not na(londonHigh) and high > londonHigh and not londonSession
    londonHighSwept := true

if not londonLowSwept and not na(londonLow) and low < londonLow and not londonSession
    londonLowSwept := true

// NY session sweep detection
if not nyHighSwept and not na(nyHigh) and high > nyHigh and not (nyAMSession or nyPMSession)
    nyHighSwept := true

if not nyLowSwept and not na(nyLow) and low < nyLow and not (nyAMSession or nyPMSession)
    nyLowSwept := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SWING POINT DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect swing highs and lows using pivot
pivotHigh = ta.pivothigh(high, i_msLookback, i_msLookback)
pivotLow = ta.pivotlow(low, i_msLookback, i_msLookback)

isSwingHigh = not na(pivotHigh)
isSwingLow = not na(pivotLow)

// Update swing tracking
if isSwingHigh
    lastSwingHigh := pivotHigh
    lastSwingHighBar := bar_index - i_msLookback
    swingHighSwept := false
    newSH = SwingPoint.new(pivotHigh, bar_index - i_msLookback, DIR_BULL)
    if array.size(swingHighs) >= 20
        array.shift(swingHighs)
    array.push(swingHighs, newSH)

if isSwingLow
    lastSwingLow := pivotLow
    lastSwingLowBar := bar_index - i_msLookback
    swingLowSwept := false
    newSL = SwingPoint.new(pivotLow, bar_index - i_msLookback, DIR_BEAR)
    if array.size(swingLows) >= 20
        array.shift(swingLows)
    array.push(swingLows, newSL)

// Turtle Soup swing tracking
high20 = ta.highest(high, i_tsLookback)
low20 = ta.lowest(low, i_tsLookback)

recentSwingHigh := high20
recentSwingLow := low20

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        HTF BIAS DETECTION                                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Request HTF data
[htfHigh, htfLow, htfClose] = request.security(syminfo.tickerid, i_htfTimeframe, [high, low, close])

// HTF Swing detection (simplified)
htfPivotHigh = ta.pivothigh(htfHigh, i_htfLookback, i_htfLookback)
htfPivotLow = ta.pivotlow(htfLow, i_htfLookback, i_htfLookback)

var float htfLastSwingHigh = na
var float htfLastSwingLow = na

if not na(htfPivotHigh)
    htfLastSwingHigh := htfPivotHigh

if not na(htfPivotLow)
    htfLastSwingLow := htfPivotLow

// Determine HTF Bias
htfBullValid := not na(htfLastSwingLow) and htfClose > htfLastSwingLow
htfBearValid := not na(htfLastSwingHigh) and htfClose < htfLastSwingHigh

if i_htfBias
    htfBias := htfBullValid and not htfBearValid ? DIR_BULL : htfBearValid and not htfBullValid ? DIR_BEAR : htfBias

// Check if current setup aligns with HTF
htfAllowsBull = not i_htfBias or htfBias >= 0
htfAllowsBear = not i_htfBias or htfBias <= 0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MULTI-TIMEFRAME BIAS (ICT Method)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// MTF Bias: Determine bias on each timeframe using swing structure
// Per ICT: Bias is based on swing high/low breaks (BOS) and price position

// Function to calculate bias from swing levels
f_calcBias(float swingHigh, float swingLow, float closePrice) =>
    if na(swingHigh) or na(swingLow)
        0  // Neutral if no swings
    else if closePrice > swingHigh
        1  // Bullish - above swing high
    else if closePrice < swingLow
        -1  // Bearish - below swing low
    else
        0  // Neutral - between swings

// Request data from each timeframe
[wHigh, wLow, wClose, wPivotH, wPivotL] = request.security(syminfo.tickerid, "W", [high, low, close, ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)])
[dHigh, dLow, dClose, dPivotH, dPivotL] = request.security(syminfo.tickerid, "D", [high, low, close, ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)])
[h1High, h1Low, h1Close, h1PivotH, h1PivotL] = request.security(syminfo.tickerid, "60", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])
[m15High, m15Low, m15Close, m15PivotH, m15PivotL] = request.security(syminfo.tickerid, "15", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])
[m5High, m5Low, m5Close, m5PivotH, m5PivotL] = request.security(syminfo.tickerid, "5", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])

// Track swing levels for each timeframe
var float wSwingHigh = na, var float wSwingLow = na
var float dSwingHigh = na, var float dSwingLow = na
var float h1SwingHigh = na, var float h1SwingLow = na
var float m15SwingHigh = na, var float m15SwingLow = na
var float m5SwingHigh = na, var float m5SwingLow = na

// Update swing levels when new pivots form
if not na(wPivotH)
    wSwingHigh := wPivotH
if not na(wPivotL)
    wSwingLow := wPivotL
if not na(dPivotH)
    dSwingHigh := dPivotH
if not na(dPivotL)
    dSwingLow := dPivotL
if not na(h1PivotH)
    h1SwingHigh := h1PivotH
if not na(h1PivotL)
    h1SwingLow := h1PivotL
if not na(m15PivotH)
    m15SwingHigh := m15PivotH
if not na(m15PivotL)
    m15SwingLow := m15PivotL
if not na(m5PivotH)
    m5SwingHigh := m5PivotH
if not na(m5PivotL)
    m5SwingLow := m5PivotL

// Calculate bias for each timeframe
mtfBiasW = f_calcBias(wSwingHigh, wSwingLow, wClose)
mtfBiasD = f_calcBias(dSwingHigh, dSwingLow, dClose)
mtfBias1H = f_calcBias(h1SwingHigh, h1SwingLow, h1Close)
mtfBias15m = f_calcBias(m15SwingHigh, m15SwingLow, m15Close)
mtfBias5m = f_calcBias(m5SwingHigh, m5SwingLow, m5Close)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MARKET STRUCTURE (BOS/CHoCH)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bootstrap: Initialize msDirection on first valid swing comparison
// This fixes the "cold start" problem where CHoCH can't detect on chart start
var bool msInitialized = false

if not msInitialized and not na(lastSwingHigh) and not na(lastSwingLow)
    // Initialize based on current price relative to recent swings
    if close > lastSwingHigh
        msDirection := DIR_BULL
        msInitialized := true
    else if close < lastSwingLow
        msDirection := DIR_BEAR
        msInitialized := true
    else
        // Price between swings - use HTF bias if available, else use swing relationship
        if htfBias != 0
            msDirection := htfBias
            msInitialized := true
        else if lastSwingHighBar > lastSwingLowBar
            // More recent high = bullish structure forming
            msDirection := DIR_BULL
            msInitialized := true
        else if lastSwingLowBar > lastSwingHighBar
            // More recent low = bearish structure forming
            msDirection := DIR_BEAR
            msInitialized := true

// Break of Structure (continuation in current direction)
bullishBOS = close > lastSwingHigh and msDirection == DIR_BULL and not na(lastSwingHigh) and msInitialized
bearishBOS = close < lastSwingLow and msDirection == DIR_BEAR and not na(lastSwingLow) and msInitialized

// Change of Character (reversal against current direction)
bullishCHoCH = close > lastSwingHigh and msDirection == DIR_BEAR and not na(lastSwingHigh) and msInitialized
bearishCHoCH = close < lastSwingLow and msDirection == DIR_BULL and not na(lastSwingLow) and msInitialized

// First structure break when not initialized (treat as BOS to establish direction)
firstBullBreak = close > lastSwingHigh and msDirection == DIR_NEUTRAL and not na(lastSwingHigh)
firstBearBreak = close < lastSwingLow and msDirection == DIR_NEUTRAL and not na(lastSwingLow)

// Update market structure
if bullishBOS or bullishCHoCH or firstBullBreak
    msDirection := DIR_BULL
    bosDetected := bullishBOS or firstBullBreak
    chochDetected := bullishCHoCH
    msInitialized := true

if bearishBOS or bearishCHoCH or firstBearBreak
    msDirection := DIR_BEAR
    bosDetected := bearishBOS or firstBearBreak
    chochDetected := bearishCHoCH
    msInitialized := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        TURTLE SOUP DETECTION (Enhanced with Stalking)          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ATR for stalk distance calculation
atrVal = ta.atr(14)

// Turtle Soup: Failed breakout with reversal
tsBuffer = i_tsBuffer * f_tickSize()
stalkDist = atrVal * 0.5  // Distance to start stalking

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STALKING STAGES: ğŸ‘€ STALK â†’ ğŸ¯ TRAP â†’ TS CONFIRM â†’ ğŸš« INVALID
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if near swing high (stalking)
nearSwingHigh = not na(recentSwingHigh) and not swingHighSwept and high >= recentSwingHigh - stalkDist and high < recentSwingHigh

// Check if near swing low (stalking)
nearSwingLow = not na(recentSwingLow) and not swingLowSwept and low <= recentSwingLow + stalkDist and low > recentSwingLow

// STALK stage - approaching the high/low
if nearSwingHigh and tsStage != "TRAP" and tsStage != "CONFIRM"
    tsStage := "STALK_HIGH"
    tsStalking := 1
    tsStageBar := bar_index

if nearSwingLow and tsStage != "TRAP" and tsStage != "CONFIRM"
    tsStage := "STALK_LOW"
    tsStalking := -1
    tsStageBar := bar_index

// TRAP stage - price sweeps the level
if tsStalking == 1 and high > recentSwingHigh + tsBuffer
    if tsStage == "STALK_HIGH"
        tsStage := "TRAP"
        tsStageBar := bar_index

if tsStalking == -1 and low < recentSwingLow - tsBuffer
    if tsStage == "STALK_LOW"
        tsStage := "TRAP"
        tsStageBar := bar_index

// Bearish Turtle Soup CONFIRM: Sweep high, close back inside
bearishTS = i_showTurtleSoup and htfAllowsBear and not na(recentSwingHigh) and not swingHighSwept and high > recentSwingHigh + tsBuffer and close < recentSwingHigh and close < open

// Bullish Turtle Soup CONFIRM: Sweep low, close back inside
bullishTS = i_showTurtleSoup and htfAllowsBull and not na(recentSwingLow) and not swingLowSwept and low < recentSwingLow - tsBuffer and close > recentSwingLow and close > open

// CONFIRM stage
if bearishTS
    tsStage := "CONFIRM_BEAR"
    tsEntryPrice := close
    tsStalking := 1
    tsStageBar := bar_index

if bullishTS
    tsStage := "CONFIRM_BULL"
    tsEntryPrice := close
    tsStalking := -1
    tsStageBar := bar_index

// INVALID stage - if price continues in sweep direction
if tsStage == "TRAP" and tsStalking == 1
    if close > recentSwingHigh and close > open
        tsStage := "INVALID"
        tsStageBar := bar_index

if tsStage == "TRAP" and tsStalking == -1
    if close < recentSwingLow and close < open
        tsStage := "INVALID"
        tsStageBar := bar_index

// Reset after confirmation is old
if bar_index - tsStageBar > 10 and (tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" or tsStage == "INVALID")
    tsStage := "NONE"
    tsStalking := 0

// Update sweep tracking
if high > recentSwingHigh + tsBuffer
    swingHighSwept := true

if low < recentSwingLow - tsBuffer
    swingLowSwept := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        JUDAS SWING DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track Asian range for Judas reference
if asianSession
    if na(asianHigh) or nyHour == 20
        asianHigh := high
        asianLow := low
    else
        asianHigh := math.max(asianHigh, high)
        asianLow := math.min(asianLow, low)

// Judas Swing: False move during London opposite to true NY direction
bearishJudas = i_showJudas and inJudasSession and not na(asianHigh) and high > asianHigh and close < open and htfAllowsBear

bullishJudas = i_showJudas and inJudasSession and not na(asianLow) and low < asianLow and close > open and htfAllowsBull

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ORDER BLOCK DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Displacement detection (atrVal defined earlier in Turtle Soup section)
displacementUp = (close - open) > atrVal * 1.5 and close > open
displacementDown = (open - close) > atrVal * 1.5 and close < open

// Bullish OB: Last down candle before displacement up
bullishOB = close[1] < open[1] and displacementUp and close > high[1]

// Bearish OB: Last up candle before displacement down
bearishOB = close[1] > open[1] and displacementDown and close < low[1]

// ICT-style Order Block colors (blue for bullish, orange for bearish - per ICT videos)
obBullColor = #B3D9FF  // Soft pastel blue
obBearColor = #FFD4C4  // Soft pastel peach

// Create and manage Order Blocks - ICT style with labels
if bullishOB and i_showOB
    newOB = OrderBlock.new(
         high[1], low[1], bar_index - 1, DIR_BULL, OB_FRESH, false,
         box.new(bar_index - 1, high[1], bar_index + 20, low[1],
                 border_color=obBullColor, bgcolor=color.new(obBullColor, 60),
                 border_width=2, border_style=line.style_solid,
                 text="OB", text_color=obBullColor, text_size=size.tiny, text_halign=text.align_right),
         i_obShowLifecycle ? label.new(bar_index - 1, high[1], "â—",
                                       style=label.style_none, textcolor=color.new(obBullColor, 30), size=size.tiny) : na)
    if array.size(bullOBs) >= 10
        oldOB = array.shift(bullOBs)
        if not na(oldOB.visual)
            box.delete(oldOB.visual)
        if not na(oldOB.stateLabel)
            label.delete(oldOB.stateLabel)
    array.push(bullOBs, newOB)

if bearishOB and i_showOB
    newOB = OrderBlock.new(
         high[1], low[1], bar_index - 1, DIR_BEAR, OB_FRESH, false,
         box.new(bar_index - 1, high[1], bar_index + 20, low[1],
                 border_color=obBearColor, bgcolor=color.new(obBearColor, 60),
                 border_width=2, border_style=line.style_solid,
                 text="OB", text_color=obBearColor, text_size=size.tiny, text_halign=text.align_right),
         i_obShowLifecycle ? label.new(bar_index - 1, high[1], "â—",
                                       style=label.style_none, textcolor=color.new(obBearColor, 30), size=size.tiny) : na)
    if array.size(bearOBs) >= 10
        oldOB = array.shift(bearOBs)
        if not na(oldOB.visual)
            box.delete(oldOB.visual)
        if not na(oldOB.stateLabel)
            label.delete(oldOB.stateLabel)
    array.push(bearOBs, newOB)

// ICT-style Breaker colors (orange tones - violated OBs become support/resistance)
brkBullColor = #FF9100  // Bright orange for breakers
brkBearColor = #FF6D00  // Amber orange for bearish breaker

// Update OB Lifecycle States
f_updateOBState(array<OrderBlock> obs, bool isBull) =>
    if array.size(obs) > 0
        for i = 0 to array.size(obs) - 1
            ob = array.get(obs, i)
            mitPrice = i_obMitigation == "Wick" ? (isBull ? low : high) : i_obMitigation == "Close" ? close : (high + low) / 2

            // State transitions
            if ob.state == OB_FRESH
                // Move to propulsion after price moves away
                if isBull and close > ob.top * 1.001
                    ob.state := OB_PROPULSION
                else if not isBull and close < ob.bottom * 0.999
                    ob.state := OB_PROPULSION

            else if ob.state == OB_PROPULSION
                // Test when price returns
                if isBull and mitPrice <= ob.top and mitPrice >= ob.bottom
                    ob.state := OB_TESTED
                else if not isBull and mitPrice >= ob.bottom and mitPrice <= ob.top
                    ob.state := OB_TESTED

            else if ob.state == OB_TESTED
                // Mitigated if price pushes through 50%
                midPoint = (ob.top + ob.bottom) / 2
                if isBull and mitPrice < midPoint
                    ob.state := OB_MITIGATED
                else if not isBull and mitPrice > midPoint
                    ob.state := OB_MITIGATED

            else if ob.state == OB_MITIGATED
                // Violated if price closes beyond OB - becomes Breaker
                if isBull and close < ob.bottom
                    ob.state := OB_VIOLATED
                    ob.isBreaker := true
                    // Update box to Breaker style
                    if not na(ob.visual)
                        box.set_border_color(ob.visual, brkBearColor)
                        box.set_bgcolor(ob.visual, color.new(brkBearColor, 75))
                        box.set_text(ob.visual, "BRK")
                        box.set_text_color(ob.visual, brkBearColor)
                else if not isBull and close > ob.top
                    ob.state := OB_VIOLATED
                    ob.isBreaker := true
                    // Update box to Breaker style
                    if not na(ob.visual)
                        box.set_border_color(ob.visual, brkBullColor)
                        box.set_bgcolor(ob.visual, color.new(brkBullColor, 75))
                        box.set_text(ob.visual, "BRK")
                        box.set_text_color(ob.visual, brkBullColor)

            // Update label - Clean minimal indicators
            if not na(ob.stateLabel) and i_obShowLifecycle
                stateText = ob.state == OB_FRESH ? "â—" : ob.state == OB_PROPULSION ? "â—‰" : ob.state == OB_TESTED ? "â—" : ob.state == OB_MITIGATED ? "â—‹" : ob.isBreaker ? "âŠ˜" : "âœ•"
                label.set_text(ob.stateLabel, stateText)
                label.set_x(ob.stateLabel, bar_index)

f_updateOBState(bullOBs, true)
f_updateOBState(bearOBs, false)

// Clean old OBs
f_cleanOldOBs(bullOBs, i_obMaxAge)
f_cleanOldOBs(bearOBs, i_obMaxAge)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        REJECTION BLOCK DETECTION                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Rejection Block: Long wick that rejects from a level and closes outside
// Different from OB - shows where price aggressively rejected

// Calculate wick sizes
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low
bodySize = math.abs(close - open)
totalRange = high - low

// Rejection Block thresholds
minWickRatio = 0.6  // Wick must be 60%+ of total range
minWickATR = atrVal * 0.5  // Minimum wick size

// Bullish Rejection Block: Long lower wick rejecting (discount check done later)
bullishRejBlock = lowerWick > totalRange * minWickRatio and
                  lowerWick > minWickATR and
                  close > open

// Bearish Rejection Block: Long upper wick rejecting (premium check done later)
bearishRejBlock = upperWick > totalRange * minWickRatio and
                  upperWick > minWickATR and
                  close < open

// Store rejection block levels for reference
var float lastBullRejLevel = na
var float lastBearRejLevel = na
var int lastBullRejBar = na
var int lastBearRejBar = na

if bullishRejBlock
    lastBullRejLevel := low
    lastBullRejBar := bar_index

if bearishRejBlock
    lastBearRejLevel := high
    lastBearRejBar := bar_index

// Check if rejection block is recent and valid
hasRecentBullRej = not na(lastBullRejBar) and bar_index - lastBullRejBar <= 20
hasRecentBearRej = not na(lastBearRejBar) and bar_index - lastBearRejBar <= 20

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        FVG / IFVG DETECTION                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bullish FVG: Gap up (low > high[2])
bullishFVG = low > high[2] and close[1] > open[1]
bullishFVGTop = low
bullishFVGBottom = high[2]

// Bearish FVG: Gap down (high < low[2])
bearishFVG = high < low[2] and close[1] < open[1]
bearishFVGTop = low[2]
bearishFVGBottom = high

// Check minimum size
minFVGSize = i_fvgMinSize * f_tickSize()

// ICT-style FVG colors (gold/amber for visibility)
// ICT-style FVG colors (pink - per ICT videos)
fvgBullColor = #FFF3C4  // Soft pastel cream/gold for bullish FVG
fvgBearColor = #FFCDD2  // Soft pastel pink for bearish FVG

// Create FVGs - ICT style with labels
if bullishFVG and i_showFVG and (bullishFVGTop - bullishFVGBottom) >= minFVGSize
    mitPct = f_getMitPct()
    mitLevel = bullishFVGBottom + (bullishFVGTop - bullishFVGBottom) * mitPct
    newFVG = FVG.new(
         bullishFVGTop, bullishFVGBottom, bar_index, DIR_BULL, false, mitLevel,
         box.new(bar_index - 2, bullishFVGTop, bar_index + 15, bullishFVGBottom,
                 border_color=fvgBullColor, bgcolor=color.new(fvgBullColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="FVG", text_color=fvgBullColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bullFVGs) >= 15
        oldFVG = array.shift(bullFVGs)
        if not na(oldFVG.visual)
            box.delete(oldFVG.visual)
    array.push(bullFVGs, newFVG)

if bearishFVG and i_showFVG and (bearishFVGTop - bearishFVGBottom) >= minFVGSize
    mitPct = f_getMitPct()
    mitLevel = bearishFVGTop - (bearishFVGTop - bearishFVGBottom) * mitPct
    newFVG = FVG.new(
         bearishFVGTop, bearishFVGBottom, bar_index, DIR_BEAR, false, mitLevel,
         box.new(bar_index - 2, bearishFVGTop, bar_index + 15, bearishFVGBottom,
                 border_color=fvgBearColor, bgcolor=color.new(fvgBearColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="FVG", text_color=fvgBearColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bearFVGs) >= 15
        oldFVG = array.shift(bearFVGs)
        if not na(oldFVG.visual)
            box.delete(oldFVG.visual)
    array.push(bearFVGs, newFVG)

// Update FVG mitigation
f_updateFVGMitigation(array<FVG> fvgs, bool isBull) =>
    if array.size(fvgs) > 0
        for i = array.size(fvgs) - 1 to 0
            fvg = array.get(fvgs, i)
            if not fvg.mitigated
                if isBull and low <= fvg.mitLevel
                    fvg.mitigated := true
                    if not na(fvg.visual)
                        box.set_bgcolor(fvg.visual, color.new(color.gray, 90))
                else if not isBull and high >= fvg.mitLevel
                    fvg.mitigated := true
                    if not na(fvg.visual)
                        box.set_bgcolor(fvg.visual, color.new(color.gray, 90))

f_updateFVGMitigation(bullFVGs, true)
f_updateFVGMitigation(bearFVGs, false)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        IFVG (Inverse FVG) DETECTION                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IFVG: When price fills a FVG then reverses, the filled FVG becomes inverse zone
// Track recently mitigated FVGs and check for reversal

var array<FVG> bullIFVGs = array.new<FVG>()
var array<FVG> bearIFVGs = array.new<FVG>()

// Pastel IFVG colors (teal/cyan - distinct from FVG)
ifvgBearClr = #80DEEA  // Pastel cyan for bearish IFVG
ifvgBullClr = #A5D6A7  // Pastel green for bullish IFVG

// Check for IFVG creation from mitigated FVGs
f_checkIFVG(array<FVG> fvgs, array<FVG> ifvgs, bool wasBull) =>
    if array.size(fvgs) > 0
        for i = array.size(fvgs) - 1 to 0
            fvg = array.get(fvgs, i)
            // If FVG was just mitigated and we see reversal candle
            if fvg.mitigated and bar_index - fvg.startBar <= 20
                // Check for reversal after mitigation
                reversalCandle = wasBull ? (close < open and close < fvg.bottom) : (close > open and close > fvg.top)
                if reversalCandle and i_showIFVG
                    // Delete the original FVG box (transforms into IFVG)
                    if not na(fvg.visual)
                        box.delete(fvg.visual)

                    // Create IFVG (opposite direction)
                    newDir = wasBull ? DIR_BEAR : DIR_BULL
                    ifvgClr = wasBull ? ifvgBearClr : ifvgBullClr
                    newIFVG = FVG.new(
                         fvg.top, fvg.bottom, bar_index, newDir, false, (fvg.top + fvg.bottom) / 2,
                         box.new(bar_index - 1, fvg.top, bar_index + 10, fvg.bottom,
                                 border_color=ifvgClr, bgcolor=color.new(ifvgClr, 70),
                                 border_width=2, border_style=line.style_solid,
                                 text="IFVG", text_color=ifvgClr, text_size=size.tiny, text_halign=text.align_right))
                    if array.size(ifvgs) >= 5
                        oldIFVG = array.shift(ifvgs)
                        if not na(oldIFVG.visual)
                            box.delete(oldIFVG.visual)
                    array.push(ifvgs, newIFVG)
                    // Mark original as processed by moving far back
                    fvg.startBar := bar_index - 1000

f_checkIFVG(bullFVGs, bearIFVGs, true)
f_checkIFVG(bearFVGs, bullIFVGs, false)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        REJECTION BLOCK DETECTION                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Rejection Block: Long wick into a zone that rejects and closes outside
// Bullish RB: Long lower wick, closes in upper half (buying rejection at lows)
// Bearish RB: Long upper wick, closes in lower half (selling rejection at highs)

// Rejection Block Type
type RejBlock
    float top
    float bottom
    int startBar
    int direction
    box visual

var array<RejBlock> rejBlocks = array.new<RejBlock>()

// Rejection criteria thresholds (candle metrics already calculated above)
wickThreshold = 0.6
bodyThreshold = 0.4

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        LIQUIDITY DETECTION                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Equal Highs Detection
f_detectEqualHighs() =>
    found = false
    level = 0.0
    threshold = high * (i_eqThreshold / 100)
    for i = 5 to math.min(i_liqLookback, bar_index - 1)
        if math.abs(high - high[i]) <= threshold
            found := true
            level := math.max(high, high[i])
            break
    [found, level]

// Equal Lows Detection
f_detectEqualLows() =>
    found = false
    level = 0.0
    threshold = low * (i_eqThreshold / 100)
    for i = 5 to math.min(i_liqLookback, bar_index - 1)
        if math.abs(low - low[i]) <= threshold
            found := true
            level := math.min(low, low[i])
            break
    [found, level]

[hasEQH, eqhLevel] = f_detectEqualHighs()
[hasEQL, eqlLevel] = f_detectEqualLows()

// Track BSL/SSL
if hasEQH and i_showEQH
    newLiq = LiqLevel.new(eqhLevel, bar_index, 1, false, "EQH", na)
    if array.size(bslLevels) >= 10
        oldLiq = array.shift(bslLevels)
        if not na(oldLiq.visual)
            line.delete(oldLiq.visual)
    array.push(bslLevels, newLiq)

if hasEQL and i_showEQL
    newLiq = LiqLevel.new(eqlLevel, bar_index, 1, false, "EQL", na)
    if array.size(sslLevels) >= 10
        oldLiq = array.shift(sslLevels)
        if not na(oldLiq.visual)
            line.delete(oldLiq.visual)
    array.push(sslLevels, newLiq)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        VOLUME IMBALANCE (VI) DETECTION                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Volume Imbalance: Gap between consecutive candle bodies (not wicks)
// Bullish VI: Current candle body low > previous candle body high
// Bearish VI: Current candle body high < previous candle body low

viColor = #D4C4FF  // Soft pastel lavender for VI

// Body calculations
currBodyHigh = math.max(close, open)
currBodyLow = math.min(close, open)
prevBodyHigh = math.max(close[1], open[1])
prevBodyLow = math.min(close[1], open[1])

// Minimum VI size (to filter noise)
minVISize = atrVal * 0.3

// Bullish VI: Gap up between bodies
bullishVI = currBodyLow > prevBodyHigh and (currBodyLow - prevBodyHigh) >= minVISize
viTopBull = currBodyLow
viBottomBull = prevBodyHigh

// Bearish VI: Gap down between bodies
bearishVI = currBodyHigh < prevBodyLow and (prevBodyLow - currBodyHigh) >= minVISize
viTopBear = prevBodyLow
viBottomBear = currBodyHigh

// Create VI boxes
if bullishVI and i_showFVG
    newVI = VolumeImbalance.new(viTopBull, viBottomBull, bar_index, DIR_BULL, false,
         box.new(bar_index - 1, viTopBull, bar_index + 10, viBottomBull,
                 border_color=viColor, bgcolor=color.new(viColor, 65),
                 border_width=1, border_style=line.style_dotted,
                 text="VI", text_color=viColor, text_size=size.small, text_halign=text.align_right))
    if array.size(bullVIs) >= 10
        oldVI = array.shift(bullVIs)
        if not na(oldVI.visual)
            box.delete(oldVI.visual)
    array.push(bullVIs, newVI)

if bearishVI and i_showFVG
    newVI = VolumeImbalance.new(viTopBear, viBottomBear, bar_index, DIR_BEAR, false,
         box.new(bar_index - 1, viTopBear, bar_index + 10, viBottomBear,
                 border_color=viColor, bgcolor=color.new(viColor, 65),
                 border_width=1, border_style=line.style_dotted,
                 text="VI", text_color=viColor, text_size=size.small, text_halign=text.align_right))
    if array.size(bearVIs) >= 10
        oldVI = array.shift(bearVIs)
        if not na(oldVI.visual)
            box.delete(oldVI.visual)
    array.push(bearVIs, newVI)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SUSPENSION BLOCK DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Suspension Block: Single candle with Volume Imbalance at BOTH ends
// "Being suspended between two volume imbalances" - ICT
// Extremely powerful PD Array - acts like FVG but single candle

suspBlockBullColor = #C5E8FF  // Soft pastel sky blue for bullish
suspBlockBearColor = #FFE0D4  // Soft pastel coral for bearish

// Check for VI at both ends of a single candle
// VI HIGH: Gap between this candle's body high and next candle's body low
// VI LOW: Gap between previous candle's body high and this candle's body low

// For detection, we look back one bar to confirm the candle[1] has VI at both ends
prevCandleBodyHigh = math.max(close[1], open[1])
prevCandleBodyLow = math.min(close[1], open[1])
prevPrevBodyHigh = math.max(close[2], open[2])
currBodyLowForSusp = math.min(close, open)
currBodyHighForSusp = math.max(close, open)

// VI at LOW end of candle[1]: prevPrev body high < candle[1] body low
viAtLow = prevPrevBodyHigh < prevCandleBodyLow and (prevCandleBodyLow - prevPrevBodyHigh) > minVISize * 0.5

// VI at HIGH end of candle[1]: candle[1] body high < current body low (for bullish)
// OR current body high < candle[1] body low (for bearish confirmation after)
viAtHighBull = prevCandleBodyHigh < currBodyLowForSusp and (currBodyLowForSusp - prevCandleBodyHigh) > minVISize * 0.5
viAtHighBear = currBodyHighForSusp < prevCandleBodyLow and (prevCandleBodyLow - currBodyHighForSusp) > minVISize * 0.5

// Bullish Suspension Block: Up close candle with VI at both ends
bullishSuspBlock = viAtLow and viAtHighBull and close[1] > open[1]
suspBlockTopBull = currBodyLowForSusp  // VI HIGH level
suspBlockBottomBull = prevPrevBodyHigh  // VI LOW level

// Bearish Suspension Block: Down close candle with VI at both ends
bearishSuspBlock = viAtLow and viAtHighBear and close[1] < open[1]
suspBlockTopBear = prevCandleBodyLow  // Higher VI level
suspBlockBottomBear = currBodyHighForSusp  // Lower VI level

// Create Suspension Block boxes
if bullishSuspBlock and i_showFVG
    newSB = SuspensionBlock.new(suspBlockTopBull, suspBlockBottomBull, prevCandleBodyHigh, prevCandleBodyLow,
         bar_index - 1, DIR_BULL, false, false,
         box.new(bar_index - 2, suspBlockTopBull, bar_index + 15, suspBlockBottomBull,
                 border_color=suspBlockBullColor, bgcolor=color.new(suspBlockBullColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="SUSP", text_color=suspBlockBullColor, text_size=size.tiny, text_halign=text.align_right),
         label.new(bar_index - 1, suspBlockTopBull, "â¬¡",
                   style=label.style_none, textcolor=suspBlockBullColor, size=size.small))
    if array.size(bullSuspBlocks) >= 5
        oldSB = array.shift(bullSuspBlocks)
        if not na(oldSB.visual)
            box.delete(oldSB.visual)
        if not na(oldSB.nameLabel)
            label.delete(oldSB.nameLabel)
    array.push(bullSuspBlocks, newSB)

if bearishSuspBlock and i_showFVG
    newSB = SuspensionBlock.new(suspBlockTopBear, suspBlockBottomBear, prevCandleBodyHigh, prevCandleBodyLow,
         bar_index - 1, DIR_BEAR, false, false,
         box.new(bar_index - 2, suspBlockTopBear, bar_index + 15, suspBlockBottomBear,
                 border_color=suspBlockBearColor, bgcolor=color.new(suspBlockBearColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="SUSP", text_color=suspBlockBearColor, text_size=size.tiny, text_halign=text.align_right),
         label.new(bar_index - 1, suspBlockTopBear, "â¬¡",
                   style=label.style_none, textcolor=suspBlockBearColor, size=size.small))
    if array.size(bearSuspBlocks) >= 5
        oldSB = array.shift(bearSuspBlocks)
        if not na(oldSB.visual)
            box.delete(oldSB.visual)
        if not na(oldSB.nameLabel)
            label.delete(oldSB.nameLabel)
    array.push(bearSuspBlocks, newSB)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        LIQUIDITY VOID DETECTION                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Liquidity Void: Large displacement candle where price moved too fast
// Creates an area price will likely return to fill

liqVoidColor = #E8D4F0  // Soft pastel orchid

// Large candle detection (> 2x ATR)
largeCandle = totalRange > atrVal * 2

// Check if the large candle has no overlapping wicks from surrounding candles
// This creates a "void" in price delivery
noOverlapHigh = high[1] < low and high[2] < low  // Gap up void
noOverlapLow = low[1] > high and low[2] > high   // Gap down void

// Bullish Liquidity Void: Large up candle with gap
bullishLiqVoid = largeCandle and close > open and noOverlapHigh
liqVoidTopBull = low
liqVoidBottomBull = math.max(high[1], high[2])

// Bearish Liquidity Void: Large down candle with gap
bearishLiqVoid = largeCandle and close < open and noOverlapLow
liqVoidTopBear = math.min(low[1], low[2])
liqVoidBottomBear = high

// Create Liquidity Void boxes
if bullishLiqVoid and i_showFVG
    newLV = LiquidityVoid.new(liqVoidTopBull, liqVoidBottomBull, bar_index, DIR_BULL, false,
         box.new(bar_index - 2, liqVoidTopBull, bar_index + 12, liqVoidBottomBull,
                 border_color=liqVoidColor, bgcolor=color.new(liqVoidColor, 60),
                 border_width=1, border_style=line.style_dashed,
                 text="VOID", text_color=liqVoidColor, text_size=size.small, text_halign=text.align_right))
    if array.size(bullLiqVoids) >= 5
        oldLV = array.shift(bullLiqVoids)
        if not na(oldLV.visual)
            box.delete(oldLV.visual)
    array.push(bullLiqVoids, newLV)

if bearishLiqVoid and i_showFVG
    newLV = LiquidityVoid.new(liqVoidTopBear, liqVoidBottomBear, bar_index, DIR_BEAR, false,
         box.new(bar_index - 2, liqVoidTopBear, bar_index + 12, liqVoidBottomBear,
                 border_color=liqVoidColor, bgcolor=color.new(liqVoidColor, 60),
                 border_width=1, border_style=line.style_dashed,
                 text="VOID", text_color=liqVoidColor, text_size=size.small, text_halign=text.align_right))
    if array.size(bearLiqVoids) >= 5
        oldLV = array.shift(bearLiqVoids)
        if not na(oldLV.visual)
            box.delete(oldLV.visual)
    array.push(bearLiqVoids, newLV)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        NDOG (NEW DAY OPENING GAP) DETECTION                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NDOG: Gap between previous day's close and current day's open

ndogColor = #FFF59D  // Pastel yellow

// Detect new day
isNewTradingDay = ta.change(time("D")) != 0

if isNewTradingDay
    prevDayClose = close[1]
    todayOpen = open

    // Check for gap
    gapUp = todayOpen > prevDayClose
    gapDown = todayOpen < prevDayClose
    gapSize = math.abs(todayOpen - prevDayClose)

    // Only track significant gaps (> 0.1% of price)
    if gapSize > close * 0.001
        ndogHigh := gapUp ? todayOpen : prevDayClose
        ndogLow := gapUp ? prevDayClose : todayOpen
        ndogCE := (ndogHigh + ndogLow) / 2
        ndogFilled := false

// Check if NDOG is filled
if not na(ndogHigh) and not ndogFilled
    if low <= ndogCE and high >= ndogCE
        ndogFilled := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ORG (OPENING RANGE GAP) DETECTION                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORG: First 5 minutes of NY session range - often acts as magnet

orgColor = #A5D6A7  // Pastel green

// Track opening range during first 5 minutes of NY session
nySessionStart = nyHour == 9 and nyMinute >= 30 and nyMinute < 35

if nySessionStart
    if not orgTracking
        orgHigh := high
        orgLow := low
        orgTracking := true
        orgFilled := false
    else
        orgHigh := math.max(orgHigh, high)
        orgLow := math.min(orgLow, low)
else if orgTracking and nyHour == 9 and nyMinute >= 35
    // Opening range complete
    orgCE := (orgHigh + orgLow) / 2
    orgTracking := false

// Reset at end of day
if nyHour == 16
    orgTracking := false

// Check if ORG CE is touched
if not na(orgCE) and not orgFilled and not orgTracking
    if low <= orgCE and high >= orgCE
        orgFilled := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              3-DAY ORG CONFLUENCE (ICT's Lookback System)                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "I'm looking at previous opening range gaps in the last three days"

// Track 3-day ORG history on new day
if isNewTradingDay
    // Shift ORG history
    org3DaysAgo := org2DaysAgo
    org2DaysAgo := org1DayAgo
    org1DayAgo := orgCE
    orgDayCount := math.min(orgDayCount + 1, 3)

// Check 3-Day ORG Confluence - when price trades through all 3 levels
org3DayConfluence = orgDayCount >= 3 and not na(org1DayAgo) and not na(org2DaysAgo) and not na(org3DaysAgo)
orgConfluenceZone = org3DayConfluence and
     ((close >= math.min(org1DayAgo, org2DaysAgo, org3DaysAgo) and close <= math.max(org1DayAgo, org2DaysAgo, org3DaysAgo)) or
      (close >= math.min(org1DayAgo, org2DaysAgo) * 0.999 and close <= math.max(org1DayAgo, org2DaysAgo) * 1.001))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    REJECTION BLOCK DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Look for price to trade under down close candles closing prices.
// These are rejection blocks and they tend to promote new runs higher"
// Different from Order Block - this is the CLOSE price of a single candle

rejBlockColor = #E8D4F0  // Soft pastel lavender for rejection blocks

// Rejection Block criteria:
// 1. Long wick (60%+ of candle range)
// 2. Close against the wick direction (rejection)
// 3. In premium or discount zone
// Note: bullishRejBlock/bearishRejBlock already defined earlier in REJECTION BLOCK DETECTION section

// Create Rejection Blocks (using definitions from above)
if bullishRejBlock and i_showRejBlock
    newRB = RejectionBlock.new(close, high, low, bar_index, DIR_BULL, false,
         box.new(bar_index - 1, close, bar_index + 15, low,
                 border_color=rejBlockColor, bgcolor=color.new(rejBlockColor, 60),
                 border_width=1, border_style=line.style_dotted),
         label.new(bar_index, low, "RB", style=label.style_none,
                   textcolor=rejBlockColor, size=size.tiny))
    if array.size(bullRejBlocks) >= 8
        oldRB = array.shift(bullRejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
        if not na(oldRB.nameLabel)
            label.delete(oldRB.nameLabel)
    array.push(bullRejBlocks, newRB)

if bearishRejBlock and i_showRejBlock
    newRB = RejectionBlock.new(close, high, low, bar_index, DIR_BEAR, false,
         box.new(bar_index - 1, high, bar_index + 15, close,
                 border_color=rejBlockColor, bgcolor=color.new(rejBlockColor, 60),
                 border_width=1, border_style=line.style_dotted),
         label.new(bar_index, high, "RB", style=label.style_none,
                   textcolor=rejBlockColor, size=size.tiny))
    if array.size(bearRejBlocks) >= 8
        oldRB = array.shift(bearRejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
        if not na(oldRB.nameLabel)
            label.delete(oldRB.nameLabel)
    array.push(bearRejBlocks, newRB)

// Mitigate Rejection Blocks
if array.size(bullRejBlocks) > 0
    for i = array.size(bullRejBlocks) - 1 to 0
        rb = array.get(bullRejBlocks, i)
        if not rb.mitigated and low <= rb.level
            rb.mitigated := true

if array.size(bearRejBlocks) > 0
    for i = array.size(bearRejBlocks) - 1 to 0
        rb = array.get(bearRejBlocks, i)
        if not rb.mitigated and high >= rb.level
            rb.mitigated := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              WICK GRADIENT LEVELS (ICT's Notepad System)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Grade all premium candle wicks and anticipate the gradient levels...
// These are the things I have on my piece of paper"

wickGradientColor = #90CAF9  // Light blue for gradient levels

// Detect significant wicks for gradient tracking
minWickSize = ta.atr(14) * 1.5  // Significant wick = 1.5x ATR

// Premium Wick (long upper wick at relative highs)
isPremiumWick = upperWick > minWickSize and high >= ta.highest(high, 10)

// Discount Wick (long lower wick at relative lows)
isDiscountWick = lowerWick > minWickSize and low <= ta.lowest(low, 10)

// Create Premium Wick Gradient (on significant upper wicks)
if isPremiumWick
    // Calculate gradient levels on the wick
    wickBase = math.max(open, close)  // Where the wick starts
    wickTop = high                     // Where the wick ends
    wickSize = wickTop - wickBase

    newWG = WickGradient.new(
         wickTop,                      // 100% - Full wick extent
         wickBase + wickSize * 0.75,   // 75% level
         wickBase + wickSize * 0.50,   // 50% - CE
         wickBase + wickSize * 0.25,   // 25% level
         wickBase,                     // 0% - Wick base
         bar_index,
         DIR_BULL,
         true,
         line.new(bar_index, wickTop, bar_index + 20, wickTop, color=color.new(wickGradientColor, 60), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.75, bar_index + 20, wickBase + wickSize * 0.75, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.50, bar_index + 20, wickBase + wickSize * 0.50, color=color.new(#FFD700, 50), style=line.style_solid),  // CE highlighted
         line.new(bar_index, wickBase + wickSize * 0.25, bar_index + 20, wickBase + wickSize * 0.25, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase, bar_index + 20, wickBase, color=color.new(wickGradientColor, 60), style=line.style_dotted))

    // Limit array size
    if array.size(premiumWicks) >= 3
        oldWG = array.shift(premiumWicks)
        if not na(oldWG.line100)
            line.delete(oldWG.line100)
        if not na(oldWG.line75)
            line.delete(oldWG.line75)
        if not na(oldWG.line50)
            line.delete(oldWG.line50)
        if not na(oldWG.line25)
            line.delete(oldWG.line25)
        if not na(oldWG.line0)
            line.delete(oldWG.line0)
    array.push(premiumWicks, newWG)

// Create Discount Wick Gradient (on significant lower wicks)
if isDiscountWick
    // Calculate gradient levels on the wick
    wickTop = math.min(open, close)    // Where the wick starts
    wickBase = low                      // Where the wick ends
    wickSize = wickTop - wickBase

    newWG = WickGradient.new(
         wickBase,                     // 100% - Full wick extent (lowest)
         wickBase + wickSize * 0.25,   // 75% level
         wickBase + wickSize * 0.50,   // 50% - CE
         wickBase + wickSize * 0.75,   // 25% level
         wickTop,                      // 0% - Wick base
         bar_index,
         DIR_BEAR,
         true,
         line.new(bar_index, wickBase, bar_index + 20, wickBase, color=color.new(wickGradientColor, 60), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.25, bar_index + 20, wickBase + wickSize * 0.25, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.50, bar_index + 20, wickBase + wickSize * 0.50, color=color.new(#FFD700, 50), style=line.style_solid),  // CE highlighted
         line.new(bar_index, wickBase + wickSize * 0.75, bar_index + 20, wickBase + wickSize * 0.75, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickTop, bar_index + 20, wickTop, color=color.new(wickGradientColor, 60), style=line.style_dotted))

    // Limit array size
    if array.size(discountWicks) >= 3
        oldWG = array.shift(discountWicks)
        if not na(oldWG.line100)
            line.delete(oldWG.line100)
        if not na(oldWG.line75)
            line.delete(oldWG.line75)
        if not na(oldWG.line50)
            line.delete(oldWG.line50)
        if not na(oldWG.line25)
            line.delete(oldWG.line25)
        if not na(oldWG.line0)
            line.delete(oldWG.line0)
    array.push(discountWicks, newWG)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘          HIGH/LOW RESISTANCE LIQUIDITY RUN DETECTION                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "There's two types of trading conditions - High Resistance liquidity runs
// where the Market's having difficulties trying to run to the obvious liquidity...
// it teases you a lot."

// Calculate market condition metrics
lookbackBars = 20

// Count reversals (changes in direction)
priceUp = close > close[1]
priceDown = close < close[1]
dirChange = (priceUp and priceDown[1]) or (priceDown and priceUp[1])
reversalCount := 0
for i = 0 to lookbackBars - 1
    if (close[i] > close[i+1] and close[i+1] < close[i+2]) or (close[i] < close[i+1] and close[i+1] > close[i+2])
        reversalCount += 1

// Calculate average move size vs current move
currentMove = math.abs(close - close[lookbackBars])
expectedMove = ta.atr(lookbackBars) * lookbackBars * 0.3  // Expected directional move

// Pre-calculate ATR for consolidation check (can't call ta.atr inside loop)
atrForConsolidation = ta.atr(14) * 0.7

// Calculate time in consolidation (bars where range < ATR)
consolidationBars := 0
for i = 0 to lookbackBars - 1
    if (high[i] - low[i]) < atrForConsolidation
        consolidationBars += 1

// Liquidity Run Score (0-100, higher = more resistance)
resistanceScore = 0.0
resistanceScore += math.min(reversalCount * 5, 40)              // Reversals contribute up to 40
resistanceScore += math.min(consolidationBars * 2, 30)          // Consolidation up to 30
resistanceScore += currentMove < expectedMove ? 30 : 0          // Below expected move = 30

liqRunScore := resistanceScore

// Classify market type
if resistanceScore >= 65
    liqRunType := "HIGH_RESISTANCE"
    isJaggedMarket := true
    isSmoothMarket := false
else if resistanceScore <= 35
    liqRunType := "LOW_RESISTANCE"
    isJaggedMarket := false
    isSmoothMarket := true
else
    liqRunType := "NEUTRAL"
    isJaggedMarket := false
    isSmoothMarket := false

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              TIME-BASED RISK ADJUSTMENT (ICT's Weekly Rhythm)                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Monday/non-farm payroll weeks have out-of-the-gate excitement at 9-9:30.
// If Monday doesn't deliver, Tuesday will be wild."

// Reset time risk values
timeRiskMultiplier := 1.0
timeRiskReason := ""
isHighProbTime := false
isLowProbTime := false

// Day of week detection (used for time-based risk assessment)
currentDOW = dayofweek
isMonday = currentDOW == dayofweek.monday
isTuesday = currentDOW == dayofweek.tuesday
isWednesday = currentDOW == dayofweek.wednesday
isThursday = currentDOW == dayofweek.thursday
isFriday = currentDOW == dayofweek.friday

// Day of week assessment (using ternary chains to reduce local scopes)
// Monday
timeRiskMultiplier := isMonday and nyHour >= 9 and nyHour < 11 ? 1.2 : isMonday and nyHour >= 11 ? 0.8 : timeRiskMultiplier
timeRiskReason := isMonday and nyHour >= 9 and nyHour < 11 ? "MON PRIME" : isMonday and nyHour >= 11 ? "MON PM" : timeRiskReason
isHighProbTime := isMonday and nyHour >= 9 and nyHour < 11 ? true : isHighProbTime
// Tuesday
timeRiskMultiplier := isTuesday and nyHour >= 8 and nyHour < 11 ? 1.3 : isTuesday and nyHour >= 11 and nyHour < 14 ? 1.0 : isTuesday and nyHour >= 14 ? 0.7 : timeRiskMultiplier
timeRiskReason := isTuesday and nyHour >= 8 and nyHour < 11 ? "TUE PRIME" : isTuesday and nyHour >= 11 and nyHour < 14 ? "TUE MID" : isTuesday and nyHour >= 14 ? "TUE PM" : timeRiskReason
isHighProbTime := isTuesday and nyHour >= 8 and nyHour < 11 ? true : isHighProbTime
// Wednesday
timeRiskMultiplier := isWednesday and nyHour >= 8 and nyHour < 11 ? 0.9 : isWednesday and nyHour >= 11 ? 0.5 : timeRiskMultiplier
timeRiskReason := isWednesday and nyHour >= 8 and nyHour < 11 ? "WED AM" : isWednesday and nyHour >= 11 ? "WED CHOP" : timeRiskReason
isLowProbTime := isWednesday and nyHour >= 11 ? true : isLowProbTime
// Thursday
timeRiskMultiplier := isThursday and nyHour >= 8 and nyHour < 11 ? 0.8 : isThursday and nyHour >= 11 ? 0.6 : timeRiskMultiplier
timeRiskReason := isThursday and nyHour >= 8 and nyHour < 11 ? "THU REV" : isThursday and nyHour >= 11 ? "THU PM" : timeRiskReason
isLowProbTime := isThursday and nyHour >= 11 ? true : isLowProbTime
// Friday
timeRiskMultiplier := isFriday and nyHour >= 8 and nyHour < 12 ? 0.7 : isFriday and nyHour >= 12 ? 0.4 : timeRiskMultiplier
timeRiskReason := isFriday and nyHour >= 8 and nyHour < 12 ? "FRI AM" : isFriday and nyHour >= 12 ? "FRI EXIT" : timeRiskReason
isLowProbTime := isFriday and nyHour >= 12 ? true : isLowProbTime

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    DISCOUNT SENSITIVITY DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Discount sensitivity - when price honors these gradient levels with precision...
// when multiple PD arrays are present... that's discount sensitivity"

// Count confluences present at current price
// Note: Full discount sensitivity calculation is done later after all PD arrays are calculated
sensitivityCount := 0
sensitivityLevel := na
discountSensitivity := false

// Check gradient level proximity (wick gradients are available at this point)
if array.size(discountWicks) > 0
    for i = 0 to math.min(array.size(discountWicks) - 1, 2)
        wg = array.get(discountWicks, i)
        if wg.active
            // Check if price is at any gradient level (within 0.1%)
            tolerance = close * 0.001
            if math.abs(close - wg.wick50) < tolerance
                sensitivityCount += 1
                sensitivityLevel := wg.wick50
            else if math.abs(close - wg.wick25) < tolerance or math.abs(close - wg.wick75) < tolerance
                sensitivityCount += 1

// Note: Additional sensitivity checks (FVG, OB, OTE, Suspension Block, inDiscount)
// are calculated later in the SCORING section after those variables are defined

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              IMMEDIATE REBALANCE PATTERN DETECTION                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Next day we open and trade back down to the previous day's close...
// offering an immediate rebalance... very strong reaction"

// Pattern: Gap down â†’ Sweep below prev close â†’ Immediate reversal
prevDayCloseForRebal = close[1]

// Bullish Immediate Rebalance: Gapped down, swept below, now reversing up
bullRebalancePattern = open < prevDayCloseForRebal and              // Gap down from prev close
                       low < prevDayCloseForRebal * 0.998 and       // Swept below prev close
                       close > prevDayCloseForRebal and              // Closed back above
                       close > open                                   // Bullish candle

// Bearish Immediate Rebalance: Gapped up, swept above, now reversing down
bearRebalancePattern = open > prevDayCloseForRebal and              // Gap up from prev close
                       high > prevDayCloseForRebal * 1.002 and      // Swept above prev close
                       close < prevDayCloseForRebal and              // Closed back below
                       close < open                                   // Bearish candle

if bullRebalancePattern
    immediateRebalanceBull := true
    immediateRebalanceBear := false
    rebalanceLevel := prevDayCloseForRebal
    rebalanceBar := bar_index
else if bearRebalancePattern
    immediateRebalanceBull := false
    immediateRebalanceBear := true
    rebalanceLevel := prevDayCloseForRebal
    rebalanceBar := bar_index
else if bar_index - rebalanceBar > 10  // Reset after 10 bars
    immediateRebalanceBull := false
    immediateRebalanceBear := false

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              MARKET MAKER BUY/SELL MODEL (9/18 EMA)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Market makers will generally price markets lower to buy into that drop [BUY MODEL]
// versus the market maker sell model where they price markets higher to sell [SELL MODEL]"

ema9 = ta.ema(close, 9)
ema18 = ta.ema(close, 18)

// Buy Model: 9 EMA below 18 EMA (expect buying into dips)
// Sell Model: 9 EMA above 18 EMA (expect selling into rallies)
if ema9 < ema18
    mmModel := "BUY_MODEL"
    mmModelBullish := true
    mmModelBearish := false
else if ema9 > ema18
    mmModel := "SELL_MODEL"
    mmModelBullish := false
    mmModelBearish := true
else
    mmModel := "NEUTRAL"
    mmModelBullish := false
    mmModelBearish := false

// EMA crossover detection for model changes
mmModelCrossBull = ta.crossover(ema9, ema18)   // Transitioning to Sell Model
mmModelCrossBear = ta.crossunder(ema9, ema18)  // Transitioning to Buy Model

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              POWER OF THREE MATURITY (Young vs Mature Swings)                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Daily swings are maturing into key support resistance...
// avoid the New York open setups if daily swings are maturing"

// Calculate swing ages in bars (convert to approximate days)
barsPerDay = timeframe.isintraday ? (1440 / timeframe.multiplier) : 1

// Update swing high age
if not na(lastSwingHighBar)
    swingHighAge := int((bar_index - lastSwingHighBar) / barsPerDay)
else
    swingHighAge := 0

// Update swing low age
if not na(lastSwingLowBar)
    swingLowAge := int((bar_index - lastSwingLowBar) / barsPerDay)
else
    swingLowAge := 0

// Classify swing maturity
// Young: 1-3 days - can absorb more displacement
// Mature: 5+ days - likely to reverse at next touch
matureSwingHigh := swingHighAge >= 5
matureSwingLow := swingLowAge >= 5
youngSwingHigh := swingHighAge >= 1 and swingHighAge <= 3
youngSwingLow := swingLowAge >= 1 and swingLowAge <= 3

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              LONGEST WICK CE DETECTION                                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Consequent encroachment of the longest wick... this is the longest one
// so consequent encroachment is right there"

// Find the longest wick in the lookback period
wickLookback = 20
longestUpperWick = 0.0
longestLowerWick = 0.0
longestUpperBar = 0
longestLowerBar = 0

for i = 0 to wickLookback - 1
    upperWickI = high[i] - math.max(open[i], close[i])
    lowerWickI = math.min(open[i], close[i]) - low[i]

    if upperWickI > longestUpperWick
        longestUpperWick := upperWickI
        longestUpperBar := i

    if lowerWickI > longestLowerWick
        longestLowerWick := lowerWickI
        longestLowerBar := i

// Determine which wick is THE longest (upper or lower)
if longestUpperWick > longestLowerWick
    // Upper wick is longest - premium wick
    longestWickDirection := 1
    longestWickBar := bar_index - longestUpperBar
    wickBase = math.max(open[longestUpperBar], close[longestUpperBar])
    longestWickHigh := high[longestUpperBar]
    longestWickLow := wickBase
    longestWickCE := wickBase + longestUpperWick / 2  // CE = midpoint
else
    // Lower wick is longest - discount wick
    longestWickDirection := -1
    longestWickBar := bar_index - longestLowerBar
    wickTop = math.min(open[longestLowerBar], close[longestLowerBar])
    longestWickHigh := wickTop
    longestWickLow := low[longestLowerBar]
    longestWickCE := low[longestLowerBar] + longestLowerWick / 2  // CE = midpoint

// Check if price is at the longest wick CE
atLongestWickCE = not na(longestWickCE) and math.abs(close - longestWickCE) < close * 0.001

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              INSTITUTIONAL ORDER FLOW DRILL ENTRY                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Institutional order flow drill - which is an entry into a PARTIAL fair value gap"

// IOF Drill: Enter at 50% of FVG (not full mitigation)
iofDrillLong := false
iofDrillShort := false
iofEntryLevel := na

// Check for bullish IOF Drill - enter at 50% into bearish FVG (SIBI)
if array.size(bearFVGs) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bearFVGs) - 1, 3)
        fvg = array.get(bearFVGs, i)
        if not fvg.mitigated
            fvgMid = (fvg.top + fvg.bottom) / 2
            // Price is at the 50% level of FVG (partial fill)
            if close <= fvg.top and close >= fvgMid and close > fvg.bottom
                iofDrillLong := true
                iofEntryLevel := fvgMid
                break

// Check for bearish IOF Drill - enter at 50% into bullish FVG (BISI)
if array.size(bullFVGs) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bullFVGs) - 1, 3)
        fvg = array.get(bullFVGs, i)
        if not fvg.mitigated
            fvgMid = (fvg.top + fvg.bottom) / 2
            // Price is at the 50% level of FVG (partial fill)
            if close >= fvg.bottom and close <= fvgMid and close < fvg.top
                iofDrillShort := true
                iofEntryLevel := fvgMid
                break

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        IPDA DATA RANGES                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IPDA lookbacks
high20IPDA = ta.highest(high, 20)
low20IPDA = ta.lowest(low, 20)
high40IPDA = ta.highest(high, 40)
low40IPDA = ta.lowest(low, 40)
high60IPDA = ta.highest(high, 60)
low60IPDA = ta.lowest(low, 60)

// Previous Week High/Low (approximation)
barsPerWeek = 5 * 24 * (60 / timeframe.multiplier)
weeklyBars = math.min(barsPerWeek, 500)
pwHigh = ta.highest(high, int(weeklyBars))
pwLow = ta.lowest(low, int(weeklyBars))

// Previous Month High/Low
barsPerMonth = weeklyBars * 4
monthlyBars = math.min(barsPerMonth, 2000)
pmHigh = ta.highest(high, int(math.min(monthlyBars, bar_index)))
pmLow = ta.lowest(low, int(math.min(monthlyBars, bar_index)))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        WEEKLY & QUARTERLY PROFILES                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Weekly Profile Detection
// ICT teaches specific weekly patterns based on day of week
// Note: currentDOW and day flags already defined in TIME-BASED RISK section above

// Weekly Profile Types based on ICT teachings:
// - Classic: Mon/Tue consolidation, Wed reversal, Thu/Fri expansion
// - Seek & Destroy: Wed/Thu reversals trap traders
var string weeklyProfile = "DEVELOPING"
var float mondayHigh = na
var float mondayLow = na

// Track weekly range
if isMonday and (not isMonday[1] or na(weekHigh))
    weekHigh := high
    weekLow := low
    mondayHigh := high
    mondayLow := low
    weeklyProfile := "ACCUMULATION"
else if not isMonday and isMonday[1]
    mondayHigh := high[1]
    mondayLow := low[1]

if not na(weekHigh)
    weekHigh := math.max(weekHigh, high)
    weekLow := math.min(weekLow, low)

// Detect weekly profile pattern
if isTuesday
    weeklyProfile := "ACCUMULATION"
else if isWednesday
    // Wednesday is often manipulation/reversal day
    weeklyProfile := "MANIPULATION"
else if isThursday
    weeklyProfile := "DISTRIBUTION"
else if isFriday
    weeklyProfile := "DISTRIBUTION"

// Quarterly Shift Detection
// Q1: Jan-Mar, Q2: Apr-Jun, Q3: Jul-Sep, Q4: Oct-Dec
currentMonth = month
isQ1 = currentMonth >= 1 and currentMonth <= 3
isQ2 = currentMonth >= 4 and currentMonth <= 6
isQ3 = currentMonth >= 7 and currentMonth <= 9
isQ4 = currentMonth >= 10 and currentMonth <= 12

// Quarterly shift months (first month of quarter often sees direction change)
isQuarterStart = currentMonth == 1 or currentMonth == 4 or currentMonth == 7 or currentMonth == 10
quarterName = isQ1 ? "Q1" : isQ2 ? "Q2" : isQ3 ? "Q3" : "Q4"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        OPENING RANGE GAP (ORG)                                 â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Opening Range Gap: Gap between previous session close and current session open
// This is a key ICT concept for gap trading

var float prevDayClose = na
var float currentDayOpen = na
// Note: orgHigh, orgLow, orgCE already defined in global variables section
var bool hasORG = false
var bool gapIsAbove = false  // true = gap above price, false = gap below price
var float gapFillPct = 0.0   // 0-100% fill progress

// Detect new day (for intraday timeframes)
isNewDay = ta.change(time("D")) != 0

if isNewDay
    prevDayClose := close[1]
    currentDayOpen := open
    // ORG exists if there's a gap
    if not na(prevDayClose) and math.abs(currentDayOpen - prevDayClose) > atrVal * 0.25
        orgHigh := math.max(prevDayClose, currentDayOpen)
        orgLow := math.min(prevDayClose, currentDayOpen)
        orgCE := (orgHigh + orgLow) / 2
        hasORG := true
        // Determine if gap is above or below (at creation)
        gapIsAbove := currentDayOpen > prevDayClose  // Gap up = gap is above
    else
        hasORG := false
        gapFillPct := 0.0

// Calculate gap fill percentage dynamically
if hasORG and not na(orgHigh) and not na(orgLow)
    float gapSize = orgHigh - orgLow
    if gapSize > 0
        // Determine current gap position relative to price
        gapIsAbove := close < orgLow  // Gap is above if price is below gap low

        // Calculate fill based on how much price has penetrated the gap
        if close >= orgHigh
            gapFillPct := 100.0  // Fully filled from below
        else if close <= orgLow
            gapFillPct := 0.0    // Not filled yet (price below gap)
        else
            // Price is inside the gap - calculate percentage
            gapFillPct := ((close - orgLow) / gapSize) * 100.0

        // For gap downs (gap below price), invert the calculation
        if not gapIsAbove and close <= orgLow
            gapFillPct := 100.0
        else if not gapIsAbove and close >= orgHigh
            gapFillPct := 0.0
        else if not gapIsAbove and close > orgLow and close < orgHigh
            gapFillPct := ((orgHigh - close) / gapSize) * 100.0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SEEK & DESTROY DETECTION                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Seek & Destroy: ICT concept where Wed/Thu are reversal days that trap traders
// Market sweeps one side of Monday's range then reverses

// S&D Profile Detection
var bool seekDestroyDay = false
var string sdPhase = "NONE"  // SEEK, DESTROY, COMPLETE

// Wed/Thu are primary S&D days
seekDestroyDay := isWednesday or isThursday

// Detect S&D pattern
sdSeekingHigh = seekDestroyDay and not na(mondayHigh) and high > mondayHigh
sdSeekingLow = seekDestroyDay and not na(mondayLow) and low < mondayLow

// Phase detection
if seekDestroyDay
    if sdSeekingHigh and close < mondayHigh and close < open
        sdPhase := "DESTROY_BEARS"  // Swept high, reversing down
    else if sdSeekingLow and close > mondayLow and close > open
        sdPhase := "DESTROY_BULLS"  // Swept low, reversing up
    else if sdSeekingHigh or sdSeekingLow
        sdPhase := "SEEK"  // Currently seeking liquidity
    else
        sdPhase := "WATCH"  // S&D day but no sweep yet
else
    sdPhase := "NONE"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        CBDR (Central Bank Dealers Range)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track CBDR session
if inCBDRSession and i_showCBDR
    if not inCBDR[1] or na(cbdrHigh)
        cbdrHigh := high
        cbdrLow := low
        inCBDR := true
    else
        cbdrHigh := math.max(cbdrHigh, high)
        cbdrLow := math.min(cbdrLow, low)
else if inCBDR[1] and not inCBDRSession
    cbdrRange := cbdrHigh - cbdrLow
    inCBDR := false

// CBDR SD Projections
cbdrSD1High = not na(cbdrHigh) ? cbdrHigh + cbdrRange * i_cbdrSD : na
cbdrSD1Low = not na(cbdrLow) ? cbdrLow - cbdrRange * i_cbdrSD : na

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        NWOG (New Week Opening Gap)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect new week
isNewWeek = dayofweek == dayofweek.monday and dayofweek[1] != dayofweek.monday

if isNewWeek and i_showNWOG
    // NWOG = Gap between Friday close and Sunday/Monday open
    float newNwogHigh = math.max(close[1], open)
    float newNwogLow = math.min(close[1], open)
    float newNwogCE = (newNwogHigh + newNwogLow) / 2

    // Add new NWOG to beginning of arrays (index 0 = most recent)
    array.unshift(nwogHighs, newNwogHigh)
    array.unshift(nwogLows, newNwogLow)
    array.unshift(nwogCEs, newNwogCE)

    // Trim arrays to max weeks
    while array.size(nwogHighs) > i_nwogWeeks
        array.pop(nwogHighs)
        array.pop(nwogLows)
        array.pop(nwogCEs)

    // Update single variables for backward compatibility
    nwogHigh := newNwogHigh
    nwogLow := newNwogLow
    nwogCE := newNwogCE
    newWeekStart := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        PREMIUM / DISCOUNT ZONES                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculate range
rangeHigh = ta.highest(high, i_pdLookback)
rangeLow = ta.lowest(low, i_pdLookback)
rangeSize = rangeHigh - rangeLow
equilibrium = rangeLow + rangeSize * 0.5

// Zones
premiumZone = rangeLow + rangeSize * 0.7
discountZone = rangeLow + rangeSize * 0.3

inPremium = close > premiumZone
inDiscount = close < discountZone
atEquilibrium = close >= discountZone and close <= premiumZone

// OTE Zone (62-79%)
oteTop = msDirection == DIR_BULL ? rangeLow + rangeSize * 0.79 : rangeHigh - rangeSize * 0.62
oteBottom = msDirection == DIR_BULL ? rangeLow + rangeSize * 0.62 : rangeHigh - rangeSize * 0.79
inOTE = f_inRange(close, math.max(oteTop, oteBottom), math.min(oteTop, oteBottom))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REJECTION BLOCK DETECTION (uses inPremium/inDiscount defined above)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bullish Rejection Block: Long lower wick at discount
bullishRejection = i_showRejBlock and totalRange > 0 and lowerWick / totalRange >= wickThreshold and bodySize / totalRange <= bodyThreshold and close > open and inDiscount

// Bearish Rejection Block: Long upper wick at premium
bearishRejection = i_showRejBlock and totalRange > 0 and upperWick / totalRange >= wickThreshold and bodySize / totalRange <= bodyThreshold and close < open and inPremium

// ICT-style Rejection Block colors (green/red - per ICT discount/premium)
rbBullColor = #D4EDDA  // Soft pastel mint for bullish rejection (discount)
rbBearColor = #FFE0E0  // Soft pastel rose for bearish rejection (premium)
rbDotsColor = #FFEB3B  // Pac-Man yellow for strength dots

// RB Strength scoring function
f_rbStrength(float wickPct, float bodyPct, bool inKZ) =>
    score = 1  // Base score
    if wickPct >= 0.70
        score += 1  // Extra long wick
    if inKZ or bodyPct <= 0.30
        score += 1  // In killzone or extra small body
    score

// Create Rejection Blocks - ICT style with strength dots
if bullishRejection
    wickPct = lowerWick / totalRange
    bodyPct = bodySize / totalRange
    kzActive = londonKZ or nyAMKZ or nyPMKZ or inSilverBullet
    rbScore = f_rbStrength(wickPct, bodyPct, kzActive)
    rbDots = rbScore >= 3 ? "â—â—â—" : rbScore >= 2 ? "â—â—â—‹" : "â—â—‹â—‹"
    newRB = RejBlock.new(
         math.max(close, open), low, bar_index, DIR_BULL,
         box.new(bar_index, math.max(close, open), bar_index + 15, low,
                 border_color=rbBullColor, bgcolor=color.new(rbBullColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="RB " + rbDots, text_color=rbDotsColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(rejBlocks) >= 8
        oldRB = array.shift(rejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
    array.push(rejBlocks, newRB)

if bearishRejection
    wickPct = upperWick / totalRange
    bodyPct = bodySize / totalRange
    kzActive = londonKZ or nyAMKZ or nyPMKZ or inSilverBullet
    rbScore = f_rbStrength(wickPct, bodyPct, kzActive)
    rbDots = rbScore >= 3 ? "â—â—â—" : rbScore >= 2 ? "â—â—â—‹" : "â—â—‹â—‹"
    newRB = RejBlock.new(
         high, math.min(close, open), bar_index, DIR_BEAR,
         box.new(bar_index, high, bar_index + 15, math.min(close, open),
                 border_color=rbBearColor, bgcolor=color.new(rbBearColor, 55),
                 border_width=2, border_style=line.style_solid,
                 text="RB " + rbDots, text_color=rbDotsColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(rejBlocks) >= 8
        oldRB = array.shift(rejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
    array.push(rejBlocks, newRB)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   POWER OF THREE (AMD) - PRICE-BASED ENGINE                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ICT's Power of 3: ACCUMULATION â†’ MANIPULATION â†’ DISTRIBUTION
// This is NOT just time-based - it's based on PRICE ACTION within those times

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 1: ACCUMULATION (Asian Session) - Build the range
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if asianSession
    po3Phase := "ACCUMULATION"
    amdPhase := 1

    // Reset at start of Asian session (new day cycle)
    if nyHour == 20 or na(accumulationHigh)
        accumulationHigh := high
        accumulationLow := low
        // Reset manipulation tracking for new day
        asianHighSwept := false
        asianLowSwept := false
        manipulationComplete := false
        manipDirection := 0
        expectedDirection := 0
        distributionStarted := false
        manipulationSwingHigh := na
        manipulationSwingLow := na
    else
        accumulationHigh := math.max(accumulationHigh, high)
        accumulationLow := math.min(accumulationLow, low)

    amdStatus := "ACCUMULATION - Range building [" + str.tostring(accumulationHigh, format.mintick) + " / " + str.tostring(accumulationLow, format.mintick) + "]"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 2: MANIPULATION (London/Early NY) - Judas sweep detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
else if (londonSession or nyAMSession) and not manipulationComplete
    po3Phase := "MANIPULATION"
    amdPhase := 2

    // Check for Asian High sweep (fake bullish move â†’ expect bearish)
    if not asianHighSwept and not na(accumulationHigh) and high > accumulationHigh
        asianHighSwept := true
        manipDirection := 1  // Swept high = fake bull
        expectedDirection := -1  // Expect bear after
        manipulationSwingHigh := high
        amdStatus := "MANIPULATION - Asian HIGH SWEPT! Expect reversal DOWN"

    // Check for Asian Low sweep (fake bearish move â†’ expect bullish)
    if not asianLowSwept and not na(accumulationLow) and low < accumulationLow
        asianLowSwept := true
        manipDirection := -1  // Swept low = fake bear
        expectedDirection := 1  // Expect bull after
        manipulationSwingLow := low
        amdStatus := "MANIPULATION - Asian LOW SWEPT! Expect reversal UP"

    // Track manipulation swing extremes
    if manipDirection == 1 and not na(manipulationSwingHigh)
        manipulationSwingHigh := math.max(manipulationSwingHigh, high)
    if manipDirection == -1 and not na(manipulationSwingLow)
        manipulationSwingLow := math.min(manipulationSwingLow, low)

    // Detect manipulation completion (reversal confirmation)
    // After sweeping high, look for bearish CHoCH/displacement
    if manipDirection == 1 and asianHighSwept
        if bearishCHoCH or (displacementDown and close < accumulationHigh)
            manipulationComplete := true
            amdEntryZoneTop := manipulationSwingHigh
            amdEntryZoneBottom := accumulationHigh
            amdStatus := "JUDAS COMPLETE - Reversal DOWN confirmed, seeking SSL"

    // After sweeping low, look for bullish CHoCH/displacement
    if manipDirection == -1 and asianLowSwept
        if bullishCHoCH or (displacementUp and close > accumulationLow)
            manipulationComplete := true
            amdEntryZoneTop := accumulationLow
            amdEntryZoneBottom := manipulationSwingLow
            amdStatus := "JUDAS COMPLETE - Reversal UP confirmed, seeking BSL"

    // No sweep yet
    if not asianHighSwept and not asianLowSwept
        amdStatus := "MANIPULATION - Watching for Asian range sweep..."

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 3: DISTRIBUTION (Post-Manipulation) - True move to DOL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
else if manipulationComplete or nyPMSession
    po3Phase := "DISTRIBUTION"
    amdPhase := 3

    if manipulationComplete
        distributionStarted := true
        if expectedDirection == 1
            amdStatus := "DISTRIBUTION - True move UP to BSL"
        else if expectedDirection == -1
            amdStatus := "DISTRIBUTION - True move DOWN to SSL"
        else
            amdStatus := "DISTRIBUTION - True move in progress"
    else
        amdStatus := "DISTRIBUTION - NY PM session (late distribution)"

// Default: No clear phase
else
    po3Phase := "NONE"
    amdPhase := 0
    amdStatus := "No active AMD phase"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMD CONFLUENCE - Boost score when aligned with manipulation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
amdAligned = (manipulationComplete and expectedDirection == 1 and msDirection == DIR_BULL) or
             (manipulationComplete and expectedDirection == -1 and msDirection == DIR_BEAR)

// AMD provides strong directional bias after Judas completes
amdBiasBull = manipulationComplete and expectedDirection == 1
amdBiasBear = manipulationComplete and expectedDirection == -1

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        2022 MODEL DETECTION                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 2022 Model: Sweep + Displacement + FVG
sweepLows = low < low20IPDA[1] and close > open
sweepHighs = high > high20IPDA[1] and close < open

model2022Bull = i_show2022 and sweepLows[1] and displacementUp and bullishFVG
model2022Bear = i_show2022 and sweepHighs[1] and displacementDown and bearishFVG

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ¦„ UNICORN MODEL DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Unicorn Model: Breaker Block that contains/overlaps an FVG
// This creates an institutional "unicorn" entry zone with multiple confluences

// Check if any breaker block overlaps with an FVG
var bool unicornBull = false
var bool unicornBear = false
unicornBull := false
unicornBear := false

// Scan for breaker + FVG overlap (Unicorn conditions)
// Check bullish breakers
if array.size(bullOBs) > 0
    for i = 0 to math.min(array.size(bullOBs) - 1, 5)
        ob = array.get(bullOBs, i)
        if ob.isBreaker
            // Check if this breaker overlaps with any bullish FVG
            if array.size(bullFVGs) > 0
                for j = 0 to math.min(array.size(bullFVGs) - 1, 3)
                    fvg = array.get(bullFVGs, j)
                    if fvg.top >= ob.bottom and fvg.bottom <= ob.top
                        unicornBull := true
                        break

// Check bearish breakers
if array.size(bearOBs) > 0
    for i = 0 to math.min(array.size(bearOBs) - 1, 5)
        ob = array.get(bearOBs, i)
        if ob.isBreaker
            // Check if this breaker overlaps with any bearish FVG
            if array.size(bearFVGs) > 0
                for j = 0 to math.min(array.size(bearFVGs) - 1, 3)
                    fvg = array.get(bearFVGs, j)
                    if fvg.top >= ob.bottom and fvg.bottom <= ob.top
                        unicornBear := true
                        break

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ”„ AMD FRACTAL (Nested AMD)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// AMD within AMD: Track if we're seeing nested accumulation-manipulation-distribution
// HTF AMD phase combined with LTF AMD phase alignment

var string htfAMDPhase = "NONE"
var string ltfAMDPhase = "NONE"
var bool amdFractalBull = false
var bool amdFractalBear = false

// HTF AMD based on session structure
htfAMDPhase := asianSession ? "ACCUMULATION" : londonSession ? "MANIPULATION" : nyAMSession ? "DISTRIBUTION" : "NONE"

// Pre-calculate ATR values (must be called on every bar)
atr5 = ta.atr(5)
atr20 = ta.atr(20)

// LTF AMD based on intraday price action (within NY session)
if nyAMSession or nyPMSession
    // Check for mini accumulation (consolidation after manipulation)
    isLTFAccumulation = atr5 < atr20 * 0.7  // Low volatility = accumulation
    isLTFManipulation = displacementUp or displacementDown  // Displacement = manipulation
    isLTFDistribution = bullishCHoCH or bearishCHoCH  // CHoCH = distribution starting

    ltfAMDPhase := isLTFAccumulation ? "ACC" : isLTFManipulation ? "MAN" : isLTFDistribution ? "DIST" : "NONE"

// AMD Fractal alignment: HTF Distribution + LTF showing same direction
amdFractalBull := htfAMDPhase == "DISTRIBUTION" and ltfAMDPhase == "DIST" and bullishCHoCH
amdFractalBear := htfAMDPhase == "DISTRIBUTION" and ltfAMDPhase == "DIST" and bearishCHoCH

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“Š MMXM (Market Maker Model)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Market Maker Buy/Sell Model: Complete sequence detection
// Buy Model: Sweep SSL â†’ Displacement Up â†’ FVG â†’ OTE Entry
// Sell Model: Sweep BSL â†’ Displacement Down â†’ FVG â†’ OTE Entry

var bool mmxmBullSetup = false
var bool mmxmBearSetup = false
var int mmxmBullBar = 0
var int mmxmBearBar = 0

// Detect MMXM Buy Model (Smart Money Accumulation)
if sweepLows[1] and displacementUp and bullishFVG and inDiscount
    mmxmBullSetup := true
    mmxmBullBar := bar_index
else if bar_index - mmxmBullBar > 20  // Reset after 20 bars
    mmxmBullSetup := false

// Detect MMXM Sell Model (Smart Money Distribution)
if sweepHighs[1] and displacementDown and bearishFVG and inPremium
    mmxmBearSetup := true
    mmxmBearBar := bar_index
else if bar_index - mmxmBearBar > 20  // Reset after 20 bars
    mmxmBearSetup := false

// MMXM confirmation when price enters OTE zone after setup
mmxmBullConfirm = mmxmBullSetup and inOTE and msDirection == DIR_BULL
mmxmBearConfirm = mmxmBearSetup and inOTE and msDirection == DIR_BEAR

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“… SEASONAL TENDENCIES                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ICT Seasonal Tendencies based on typical market behavior
// Q1 (Jan-Mar): Dollar strength, indices weakness
// Q2 (Apr-Jun): Dollar weakness, commodities rally
// Q3 (Jul-Sep): Summer doldrums, low volatility
// Q4 (Oct-Dec): Year-end rally, risk-on

// Use currentMonth already defined earlier (line ~1105)
currentQuarter = currentMonth <= 3 ? 1 : currentMonth <= 6 ? 2 : currentMonth <= 9 ? 3 : 4

// Seasonal bias for US indices/risk assets
seasonalBullish = currentQuarter == 4 or currentMonth == 4 or currentMonth == 7  // Oct-Dec, April, July
seasonalBearish = currentMonth == 9 or currentMonth == 2  // September, February (historically weak)
seasonalNeutral = not seasonalBullish and not seasonalBearish

// Seasonal strength indicator
var string seasonalTendency = "NEUTRAL"
seasonalTendency := seasonalBullish ? "BULLISH SEASON" : seasonalBearish ? "BEARISH SEASON" : "NEUTRAL SEASON"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“ˆ COT DATA (Placeholder)                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// NOTE: COT (Commitment of Traders) data requires external data feed
// Pine Script doesn't have native access to COT reports
// This is a placeholder for when external data integration is available
// Users can manually set COT bias based on weekly COT report

var string cotBias = "NEUTRAL"  // User can override via input
// Future enhancement: Connect to external COT data source

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MIDNIGHT OPEN TRACKING                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if isMidnight
    midnightOpen := open

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              ğŸ¯ COMPREHENSIVE ICT SCORING ENGINE (Cortex-Derived)              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 1: FOUNDATION SCORE (0-30 points) - MUST HAVE for valid setup
// Based on ICT's core hierarchy: Market Structure â†’ Liquidity â†’ HTF Alignment
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

foundationScore = 0.0
var bool hasFoundationComplete = false

// 1A. MARKET STRUCTURE (0-10 points) - 8,016 Cortex mentions
hasMSClear = msDirection == DIR_BULL or msDirection == DIR_BEAR
hasCHoCH = bullishCHoCH or bearishCHoCH
hasBOS = bullishBOS or bearishBOS

// Market structure score (ternary to reduce scopes)
foundationScore += hasMSClear ? 5 : 0
foundationScore += hasMSClear and hasCHoCH ? 3 : hasMSClear and hasBOS ? 2 : 0

// 1B. LIQUIDITY TARGET IDENTIFIED (0-10 points) - 7,892 Cortex mentions
nearestBSL = array.size(bslLevels) > 0 ? array.get(bslLevels, array.size(bslLevels) - 1).level : na
nearestSSL = array.size(sslLevels) > 0 ? array.get(sslLevels, array.size(sslLevels) - 1).level : na
hasLiquidityTarget = (msDirection == DIR_BULL and not na(nearestBSL)) or (msDirection == DIR_BEAR and not na(nearestSSL))

distToBSL = not na(nearestBSL) ? math.abs(close - nearestBSL) : 9999
distToSSL = not na(nearestSSL) ? math.abs(close - nearestSSL) : 9999
isNearLiquidity = (msDirection == DIR_BULL and distToBSL < distToSSL * 0.7) or (msDirection == DIR_BEAR and distToSSL < distToBSL * 0.7)

// Liquidity score (ternary to reduce scopes)
foundationScore += hasLiquidityTarget ? 6 : 0
foundationScore += hasLiquidityTarget and isNearLiquidity ? 4 : 0

// 1C. HTF ALIGNMENT (0-10 points) - Critical for confluence
hasHTFAlignment = (htfBias == DIR_BULL and msDirection == DIR_BULL) or (htfBias == DIR_BEAR and msDirection == DIR_BEAR)
hasMTFAlignment = (mtfBiasW == 1 and mtfBiasD == 1 and mtfBias1H == 1) or (mtfBiasW == -1 and mtfBiasD == -1 and mtfBias1H == -1)

// HTF score (ternary to reduce scopes)
foundationScore += hasHTFAlignment ? 6 : 0
foundationScore += hasHTFAlignment and hasMTFAlignment ? 4 : 0

hasFoundationComplete := foundationScore >= 20  // Need 20/30 for valid foundation

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 2: ENTRY ZONE SCORE (0-25 points) - WHERE to enter
// Based on ICT's entry zones: Premium/Discount â†’ OTE â†’ Order Block
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

zoneScore = 0.0
var bool hasZoneAlignment = false

// 2A. PREMIUM/DISCOUNT ALIGNMENT (0-10 points) - 6,234 Cortex mentions
isCorrectZone = (inDiscount and msDirection == DIR_BULL) or (inPremium and msDirection == DIR_BEAR)
isWrongZone = (inPremium and msDirection == DIR_BULL) or (inDiscount and msDirection == DIR_BEAR)

// Zone score (ternary to reduce scopes)
zoneScore += isCorrectZone ? 10 : isWrongZone ? -5 : 0
zoneScore += inOTE ? 10 : 0  // OTE zone

// 2C. ORDER BLOCK ENTRY (0-5 points) - 5,891 Cortex mentions
atBullOB = false
atBearOB = false

if array.size(bullOBs) > 0
    for i = 0 to math.min(array.size(bullOBs) - 1, 5)
        ob = array.get(bullOBs, i)
        if ob.state == OB_TESTED and f_inRange(close, ob.top, ob.bottom)
            atBullOB := true
            break

if array.size(bearOBs) > 0
    for i = 0 to math.min(array.size(bearOBs) - 1, 5)
        ob = array.get(bearOBs, i)
        if ob.state == OB_TESTED and f_inRange(close, ob.top, ob.bottom)
            atBearOB := true
            break

hasFreshOB = (atBullOB and msDirection == DIR_BULL) or (atBearOB and msDirection == DIR_BEAR)
zoneScore += hasFreshOB ? 5 : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 2D: PD ARRAY PROXIMITY SCORING (0-15 points) - NEW COMPREHENSIVE SYSTEM
// Each PD array adds value when price is near it and direction aligned
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pdArrayScore = 0.0
var bool hasSuspensionBlock = false
var bool hasVolumeImbalance = false
var bool hasLiquidityVoid = false
hasSuspensionBlock := false
hasVolumeImbalance := false
hasLiquidityVoid := false

// Check Suspension Blocks (MOST POWERFUL - 5 points)
// ICT: "Extremely powerful PD Array - one of the most powerful"
if array.size(bullSuspBlocks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullSuspBlocks) - 1, 3)
        sb = array.get(bullSuspBlocks, i)
        if not sb.mitigated and close <= sb.top and close >= sb.bottom * 0.995
            hasSuspensionBlock := true
            pdArrayScore += 5
            break
        else if not sb.mitigated and close > sb.top and close < sb.top * 1.01
            hasSuspensionBlock := true
            pdArrayScore += 3  // Nearby but not in
            break

if array.size(bearSuspBlocks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearSuspBlocks) - 1, 3)
        sb = array.get(bearSuspBlocks, i)
        if not sb.mitigated and close >= sb.bottom and close <= sb.top * 1.005
            hasSuspensionBlock := true
            pdArrayScore += 5
            break
        else if not sb.mitigated and close < sb.bottom and close > sb.bottom * 0.99
            hasSuspensionBlock := true
            pdArrayScore += 3
            break

// Check Volume Imbalances (3 points)
if array.size(bullVIs) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullVIs) - 1, 5)
        vi = array.get(bullVIs, i)
        if not vi.filled and close >= vi.bottom and close <= vi.top
            hasVolumeImbalance := true
            pdArrayScore += 3
            break

if array.size(bearVIs) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearVIs) - 1, 5)
        vi = array.get(bearVIs, i)
        if not vi.filled and close >= vi.bottom and close <= vi.top
            hasVolumeImbalance := true
            pdArrayScore += 3
            break

// Check Liquidity Voids (3 points - price drawn to fill)
if array.size(bullLiqVoids) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullLiqVoids) - 1, 3)
        lv = array.get(bullLiqVoids, i)
        if not lv.filled and close >= lv.bottom and close <= lv.top
            hasLiquidityVoid := true
            pdArrayScore += 3
            break

if array.size(bearLiqVoids) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearLiqVoids) - 1, 3)
        lv = array.get(bearLiqVoids, i)
        if not lv.filled and close >= lv.bottom and close <= lv.top
            hasLiquidityVoid := true
            pdArrayScore += 3
            break

// Check NDOG (2 points - New Day Opening Gap)
hasNDOGAlignment = false
if not na(ndogCE) and not ndogFilled
    if msDirection == DIR_BULL and close < ndogCE and close > ndogLow
        hasNDOGAlignment := true
        pdArrayScore += 2
    else if msDirection == DIR_BEAR and close > ndogCE and close < ndogHigh
        hasNDOGAlignment := true
        pdArrayScore += 2

// Check ORG (2 points - Opening Range Gap)
hasORGAlignment = false
if not na(orgCE) and not orgFilled and not orgTracking
    if msDirection == DIR_BULL and close < orgCE and close > orgLow
        hasORGAlignment := true
        pdArrayScore += 2
    else if msDirection == DIR_BEAR and close > orgCE and close < orgHigh
        hasORGAlignment := true
        pdArrayScore += 2

// Add PD Array score to zone score (capped contribution)
zoneScore += math.min(pdArrayScore, 15)

hasZoneAlignment := zoneScore >= 15  // Need 15/40 for good zone (expanded)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 3: CONFIRMATION SCORE (0-20 points) - Validates entry
// Based on ICT confirmations: FVG â†’ Displacement â†’ Killzone â†’ Silver Bullet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

confirmationScore = 0.0

// 3A. FVG PRESENT (0-5 points) - 4,567 Cortex mentions
bullFVGAbove = false
bearFVGBelow = false

if array.size(bullFVGs) > 0
    for i = 0 to math.min(array.size(bullFVGs) - 1, 5)
        fvg = array.get(bullFVGs, i)
        if not fvg.mitigated and fvg.bottom > close
            bullFVGAbove := true
            break

if array.size(bearFVGs) > 0
    for i = 0 to math.min(array.size(bearFVGs) - 1, 5)
        fvg = array.get(bearFVGs, i)
        if not fvg.mitigated and fvg.top < close
            bearFVGBelow := true
            break

hasFVGTarget = (bullFVGAbove and msDirection == DIR_BULL) or (bearFVGBelow and msDirection == DIR_BEAR)
hasFVGPresent = array.size(bullFVGs) > 0 or array.size(bearFVGs) > 0

// Confirmation scores (ternary to reduce scopes)
confirmationScore += hasFVGTarget ? 5 : hasFVGPresent ? 2 : 0

// 3B. DISPLACEMENT (0-5 points) - 2,123 Cortex mentions
hasDisplacement = (displacementUp and msDirection == DIR_BULL) or (displacementDown and msDirection == DIR_BEAR)
confirmationScore += hasDisplacement ? 5 : 0

// 3C. KILLZONE TIMING (0-5 points) - 3,892 Cortex mentions
hasKillzone = londonKZ or nyAMKZ or nyPMKZ
confirmationScore += hasKillzone ? 5 : 0

// 3D. SILVER BULLET WINDOW (0-5 points) - 3,456 Cortex mentions
hasSilverBullet = inSilverBullet
confirmationScore += hasSilverBullet ? 5 : 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 4: COMBINATION BONUSES (0-25 points) - ICT's preferred confluences
// Based on Cortex co-mention analysis of high-probability combinations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Pre-calculate values needed for combo scoring
hasModel2022 = model2022Bull or model2022Bear
hasUnicorn = unicornBull or unicornBear
var int confluenceCount = 0  // Will be updated in CONFLUENCE section below
var float stopLoss = na      // Will be calculated later in visualization section
var float riskReward = 0.0   // Will be calculated later in visualization section

comboScore = 0.0

// Combos 1-12: Using ternary to reduce local scopes
comboScore += hasLiquidityTarget and inOTE ? 8 : 0                    // Combo 1: Liquidity + OTE
comboScore += hasFVGPresent and isCorrectZone ? 5 : 0                 // Combo 2: FVG + Zone
comboScore += inOTE and hasFreshOB ? 5 : 0                            // Combo 3: OTE + OB
comboScore += hasDisplacement and hasFVGPresent ? 4 : 0               // Combo 4: Displacement + FVG
comboScore += hasMTFAlignment and hasKillzone ? 3 : 0                 // Combo 5: MTF + Killzone
comboScore += amdAligned ? 10 : 0                                     // Combo 6: AMD Alignment
comboScore += manipulationComplete and inOTE ? 5 : 0                  // Combo 7: Post-Judas + OTE
comboScore += sbPrime and hasFVGPresent ? 6 : 0                       // Combo 8: SB Prime + FVG
comboScore += isMacroTime and hasDisplacement ? 4 : 0                 // Combo 9: Macro + Displacement
comboScore += isSeekDestroyDay and hasCHoCH ? 3 : 0                   // Combo 10: S&D + CHoCH
hasRejBlock = (hasRecentBullRej and msDirection == DIR_BULL) or (hasRecentBearRej and msDirection == DIR_BEAR)
comboScore += hasRejBlock and isCorrectZone ? 5 : 0                   // Combo 11: Rej Block + Zone
comboScore += isPowerHour and confluenceCount >= 5 ? 3 : 0            // Combo 12: Power Hour

// Combos 13-20: PD Array Combos (ternary to reduce scopes)
comboScore += hasSuspensionBlock and inOTE ? 8 : 0                    // Combo 13: Susp Block + OTE
comboScore += hasSuspensionBlock and hasFVGPresent ? 5 : 0            // Combo 14: Susp Block + FVG
comboScore += hasVolumeImbalance and hasFreshOB ? 4 : 0               // Combo 15: VI + OB
comboScore += hasLiquidityVoid and hasDisplacement ? 4 : 0            // Combo 16: LV + Displacement
comboScore += hasNDOGAlignment and sbPrime ? 5 : 0                    // Combo 17: NDOG + SB
comboScore += hasORGAlignment and isMacroTime ? 4 : 0                 // Combo 18: ORG + Macro
pdArrayCount = (hasSuspensionBlock ? 1 : 0) + (hasVolumeImbalance ? 1 : 0) + (hasLiquidityVoid ? 1 : 0) + (hasFVGPresent ? 1 : 0) + (hasFreshOB ? 1 : 0)
comboScore += pdArrayCount >= 3 ? 6 : pdArrayCount >= 2 ? 3 : 0       // Combo 19: Stacked PD Arrays
comboScore += hasSuspensionBlock and hasKillzone ? 4 : 0              // Combo 20: Susp Block + KZ

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW HIDDEN GEM COMBOS (Combos 21-27)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check for Rejection Block proximity
hasRejectionBlock = false
if array.size(bullRejBlocks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullRejBlocks) - 1, 3)
        rb = array.get(bullRejBlocks, i)
        if not rb.mitigated and close >= rb.level * 0.998 and close <= rb.level * 1.002
            hasRejectionBlock := true
            break
if array.size(bearRejBlocks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearRejBlocks) - 1, 3)
        rb = array.get(bearRejBlocks, i)
        if not rb.mitigated and close >= rb.level * 0.998 and close <= rb.level * 1.002
            hasRejectionBlock := true
            break

// Combos 21-25 (ternary to reduce scopes)
comboScore += hasRejectionBlock and inOTE ? 5 : 0                     // Combo 21: Rej Block + OTE
comboScore += hasRejectionBlock and hasFVGPresent ? 4 : 0             // Combo 22: Rej Block + FVG
comboScore += orgConfluenceZone ? 6 : 0                               // Combo 23: 3-Day ORG
comboScore += discountSensitivity ? 7 : 0                             // Combo 24: Discount Sensitivity
comboScore += isSmoothMarket and (msDirection == DIR_BULL or msDirection == DIR_BEAR) ? 5 : 0  // Combo 25

// Combo 26: Wick Gradient CE test (price at consequent encroachment)
hasWickGradientCE = false
if array.size(discountWicks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(discountWicks) - 1, 2)
        wg = array.get(discountWicks, i)
        if wg.active and math.abs(close - wg.wick50) < close * 0.001
            hasWickGradientCE := true
            break
if array.size(premiumWicks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(premiumWicks) - 1, 2)
        wg = array.get(premiumWicks, i)
        if wg.active and math.abs(close - wg.wick50) < close * 0.001
            hasWickGradientCE := true
            break

// Combos 26-35 (ternary to reduce scopes)
comboScore += hasWickGradientCE ? 4 : 0                               // Combo 26: Wick Gradient CE
comboScore += isHighProbTime and (hasSuspensionBlock or hasModel2022 or hasUnicorn) ? 6 : 0  // Combo 27
comboScore += immediateRebalanceBull and msDirection == DIR_BULL ? 8 : 0  // Combo 28a: Immediate Rebal
comboScore += immediateRebalanceBear and msDirection == DIR_BEAR ? 8 : 0  // Combo 28b
comboScore += mmModelBullish and msDirection == DIR_BULL and inDiscount ? 5 : 0  // Combo 29a: MM Model
comboScore += mmModelBearish and msDirection == DIR_BEAR and inPremium ? 5 : 0   // Combo 29b
comboScore += youngSwingHigh and msDirection == DIR_BEAR and (hasSuspensionBlock or hasFVGPresent) ? 4 : 0  // Combo 30a
comboScore += youngSwingLow and msDirection == DIR_BULL and (hasSuspensionBlock or hasFVGPresent) ? 4 : 0   // Combo 30b
comboScore -= matureSwingHigh and msDirection == DIR_BEAR and nyHour >= 9 and nyHour <= 11 ? 3 : 0  // Combo 31a penalty
comboScore -= matureSwingLow and msDirection == DIR_BULL and nyHour >= 9 and nyHour <= 11 ? 3 : 0   // Combo 31b penalty
comboScore += atLongestWickCE ? 5 : 0                                 // Combo 32: Longest Wick CE
comboScore += atLongestWickCE and longestWickDirection == -1 and msDirection == DIR_BULL ? 3 : 0  // Combo 33a
comboScore += atLongestWickCE and longestWickDirection == 1 and msDirection == DIR_BEAR ? 3 : 0   // Combo 33b
comboScore += iofDrillLong ? 6 : 0                                    // Combo 34a: IOF Drill Long
comboScore += iofDrillShort ? 6 : 0                                   // Combo 34b: IOF Drill Short
comboScore += (iofDrillLong or iofDrillShort) and inOTE and hasKillzone ? 4 : 0  // Combo 35

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 5: TRIGGER DETECTION - What fires the signal
// High-conviction setups that represent complete ICT models
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var string activeTrigger = "NONE"
var float triggerMultiplier = 1.0
activeTrigger := "NONE"
triggerMultiplier := 0.7  // Default: no trigger = 70% of score (capped at MODERATE)

// Detect which trigger is active (priority order)
// Note: hasModel2022 and hasUnicorn already defined above in COMBO section
hasTurtleSoup = bullishTS or bearishTS
hasJudas = bullishJudas or bearishJudas
hasMMXM = mmxmBullConfirm or mmxmBearConfirm
hasAMDFractal = amdFractalBull or amdFractalBear

// Trigger detection using ternary to reduce scopes (priority order)
activeTrigger := hasUnicorn ? "UNICORN" : hasMMXM ? "MMXM" : hasModel2022 ? "2022 MODEL" : hasTurtleSoup ? "TURTLE SOUP" : hasAMDFractal ? "AMD FRACTAL" : hasJudas ? "JUDAS SWING" : hasCHoCH ? "CHoCH" : hasBOS ? "BOS" : hasSilverBullet and hasKillzone ? "SILVER BULLET" : "NONE"
triggerMultiplier := hasUnicorn ? 1.25 : hasMMXM ? 1.2 : hasModel2022 ? 1.2 : hasTurtleSoup ? 1.15 : hasAMDFractal ? 1.1 : hasJudas ? 1.1 : hasCHoCH ? 1.0 : hasBOS ? 0.9 : hasSilverBullet and hasKillzone ? 1.0 : 0.7

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATE FINAL COMPOSITE SCORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Raw score out of 100
rawScore = foundationScore + zoneScore + confirmationScore + comboScore

// Apply trigger multiplier
adjustedScore = rawScore * triggerMultiplier

// Apply TIME-BASED RISK adjustment (ICT's weekly rhythm)
// Tuesday PRIME boosts, Wednesday 11am+ penalizes
adjustedScore := adjustedScore * timeRiskMultiplier

// Apply HIGH/LOW RESISTANCE LIQUIDITY RUN adjustment (ternary to reduce scopes)
adjustedScore := isJaggedMarket ? adjustedScore * 0.85 : isSmoothMarket ? adjustedScore * 1.05 : adjustedScore

// Cap at 100
compositeScore := math.min(adjustedScore, 100)

// Store individual layer scores for display
var float displayFoundation = 0.0
var float displayZone = 0.0
var float displayConfirmation = 0.0
var float displayCombo = 0.0
displayFoundation := foundationScore
displayZone := zoneScore
displayConfirmation := confirmationScore
displayCombo := comboScore

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETERMINE DIRECTION (separate from quality score)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Direction based on market structure (ternary to reduce scopes)
dolDirection := msDirection == DIR_BULL ? DIR_BULL : msDirection == DIR_BEAR ? DIR_BEAR : DIR_NEUTRAL
dolTarget := msDirection == DIR_BULL ? (not na(nearestBSL) ? nearestBSL : high20IPDA) : msDirection == DIR_BEAR ? (not na(nearestSSL) ? nearestSSL : low20IPDA) : equilibrium

// Legacy probability for compatibility (now based on composite score)
dolProbability := compositeScore

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILD REASON STRING WITH LAYER BREAKDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Build reason string (ternary to reduce scopes)
dolReason := dolDirection == DIR_BULL ? "BULLISH" : dolDirection == DIR_BEAR ? "BEARISH" : "NEUTRAL - AWAITING STRUCTURE"
dolReason += dolDirection != DIR_NEUTRAL and hasHTFAlignment ? " â€¢ HTF" : ""
dolReason += dolDirection == DIR_BULL and isCorrectZone ? " â€¢ DISCOUNT" : dolDirection == DIR_BEAR and isCorrectZone ? " â€¢ PREMIUM" : ""
dolReason += dolDirection != DIR_NEUTRAL and inOTE ? " â€¢ OTE" : ""
dolReason += dolDirection != DIR_NEUTRAL and hasFreshOB ? " â€¢ OB" : ""
dolReason += dolDirection != DIR_NEUTRAL and hasDisplacement ? " â€¢ DISP" : ""
dolReason += dolDirection != DIR_NEUTRAL and hasKillzone ? " â€¢ KZ" : ""
dolReason += dolDirection != DIR_NEUTRAL and activeTrigger != "NONE" ? " â€¢ " + activeTrigger : ""

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        COMPOSITE TIER ASSIGNMENT                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tier requirements (absolute, not relative)
// ELITE: 85+ with high-conviction trigger and complete foundation
// PREMIUM: 70-84 with any trigger and good foundation
// STRONG: 55-69 with foundation
// MODERATE: 40-54
// WEAK: <40

isHighConvictionTrigger = hasUnicorn or hasMMXM or hasModel2022 or hasTurtleSoup
isAnyTrigger = activeTrigger != "NONE"

// Count total confluences for display (ternary to reduce scopes)
confluenceCount := (hasMSClear ? 1 : 0) + (hasHTFAlignment ? 1 : 0) + (hasMTFAlignment ? 1 : 0) + (hasLiquidityTarget ? 1 : 0) + (isCorrectZone ? 1 : 0) + (inOTE ? 1 : 0) + (hasFreshOB ? 1 : 0) + (hasFVGPresent ? 1 : 0) + (hasDisplacement ? 1 : 0) + (hasKillzone ? 1 : 0) + (hasSilverBullet ? 1 : 0) + (isHighConvictionTrigger ? 2 : 0)

// Assign tier with requirements (ternary to reduce scopes)
compositeTier := compositeScore >= 85 and isHighConvictionTrigger and hasFoundationComplete ? TIER_1 : compositeScore >= 70 and isAnyTrigger and hasFoundationComplete ? TIER_2 : compositeScore >= 55 and hasFoundationComplete ? TIER_3 : compositeScore >= 40 ? TIER_4 : TIER_5

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN NAMES (Based on active trigger and tier)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
patternName := ""

// TIER 1 ELITE - Highest probability setups
// Pattern names using nested ternary to reduce scopes
patternName := compositeTier == TIER_1 ? (activeTrigger == "UNICORN" ? "ğŸ¦„ UNICORN SETUP" : activeTrigger == "MMXM" ? "ğŸ“Š MMXM CONFIRMED" : activeTrigger == "2022 MODEL" and hasMTFAlignment ? "ğŸ’ DIAMOND SETUP" : activeTrigger == "2022 MODEL" ? "ğŸ† THE APEX" : activeTrigger == "TURTLE SOUP" and hasSilverBullet ? "ğŸ† PERFECT STORM" : confluenceCount >= 10 ? "ğŸ† MEGA CONFLUENCE" : "ğŸ† ELITE SETUP") : compositeTier == TIER_2 ? (activeTrigger == "UNICORN" ? "ğŸ¦„ UNICORN ZONE" : activeTrigger == "MMXM" ? "ğŸ“Š MMXM SETUP" : activeTrigger == "AMD FRACTAL" ? "ğŸ”„ AMD FRACTAL" : activeTrigger == "TURTLE SOUP" ? "â­ SWEET SPOT" : activeTrigger == "JUDAS SWING" ? "â­ JUDAS TRAP" : activeTrigger == "2022 MODEL" ? "â­ 2022 ENTRY" : activeTrigger == "SILVER BULLET" ? "â­ BULLET TIME" : confluenceCount >= 7 ? "â­ PREMIUM SETUP" : "â­ STRONG BIAS") : compositeTier == TIER_3 ? (inOTE and isCorrectZone ? "ğŸ¥ˆ OTE ZONE" : activeTrigger == "TURTLE SOUP" ? "ğŸ¥ˆ SOUP ALIGNED" : hasDisplacement and hasFreshOB ? "ğŸ¥ˆ OB PLAY" : activeTrigger == "CHoCH" ? "ğŸ¥ˆ CHoCH ENTRY" : activeTrigger == "BOS" ? "ğŸ¥ˆ BOS PLAY" : hasSilverBullet ? "ğŸ¥ˆ BULLET WINDOW" : "ğŸ¥ˆ GOOD SETUP") : compositeTier == TIER_4 ? (isCorrectZone ? "ğŸ¥‰ ZONE PLAY" : hasDisplacement ? "ğŸ¥‰ MOMENTUM" : hasFreshOB ? "ğŸ¥‰ OB WATCH" : hasKillzone ? "ğŸ¥‰ KILLZONE" : "ğŸ¥‰ DEVELOPING") : (hasFVGPresent ? "âš ï¸ FVG ONLY" : hasKillzone ? "âš ï¸ WAITING" : "âš ï¸ NO SETUP")

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   ğŸ•¹ï¸ PAC-MAN ARCADE GAME STATE LOGIC ğŸ•¹ï¸                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GAME STATE MACHINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Power Mode: All conditions aligned - eat the ghosts!
powerModeCondition = compositeTier <= TIER_2 and inOTE and hasKillzone and isAnyTrigger

if powerModeCondition and not powerModeActive
    powerModeActive := true
    powerModeTimer := POWER_MODE_DURATION

if powerModeActive
    powerModeTimer := powerModeTimer - 1
    if powerModeTimer <= 0
        powerModeActive := false

// Game State Transitions
if powerModeActive
    gameState := "POWER_MODE"
else if compositeTier == TIER_1
    gameState := "BONUS_STAGE"
else if compositeTier == TIER_2 or compositeTier == TIER_3
    gameState := "PLAYING"
else if compositeTier == TIER_4 and confluenceCount >= 3
    gameState := "READY"
else
    gameState := "ATTRACT"

// Level based on composite tier (inverted - higher tier = higher level)
currentLevel := compositeTier == TIER_1 ? 5 : compositeTier == TIER_2 ? 4 : compositeTier == TIER_3 ? 3 : compositeTier == TIER_4 ? 2 : 1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ARCADE SCORING SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculate score based on composite score (scaled to arcade points)
basePoints = compositeScore * 100

// Combo system - consecutive bars with good confluence
if confluenceCount >= 5
    comboCount := comboCount + 1
    comboMultiplier := math.min(comboCount, 8)  // Max 8x multiplier
else if confluenceCount < 3
    comboCount := 0
    comboMultiplier := 1

// Calculate arcade score
arcadeScore := int(basePoints * comboMultiplier)

// Update high score
if arcadeScore > highScore
    highScore := arcadeScore

// Ghost eaten scoring (when liquidity is swept)
if pdhSwept or pdlSwept or pwhSwept or pwlSwept
    ghostsEaten := ghostsEaten + 1
    // Classic Pac-Man ghost scoring: 200, 400, 800, 1600
    ghostIndex = math.min(ghostsEaten, 4)
    lastGhostPoints := ghostIndex == 1 ? 200 : ghostIndex == 2 ? 400 : ghostIndex == 3 ? 800 : 1600

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FRUIT R:R TARGET SYSTEM (Pac-Man Bonus Fruits)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Determine current fruit based on R:R potential (ternary to reduce scopes)
currentFruit := na(riskReward) ? "" : riskReward >= 5 ? "ğŸ”‘" : riskReward >= 4 ? "ğŸ””" : riskReward >= 3 ? "ğŸ‡" : riskReward >= 2.5 ? "ğŸ" : riskReward >= 2 ? "ğŸŠ" : riskReward >= 1.5 ? "ğŸ“" : "ğŸ’"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   ğŸ“Š SETUP TRACKING & OUTCOME DETECTION ğŸ“Š                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETECT NEW SETUP (Tier 1-3 with valid entry conditions)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// A valid setup is generated when:
// - Tier 1, 2, or 3
// - Has a trigger pattern
// - Has valid stop loss and target
// - Not already tracking an active trade

// Calculate stop loss for tracking (using swing levels)
trackingStopLoss = dolDirection == DIR_BULL ? lastSwingLow : lastSwingHigh

newSetupGenerated = (compositeTier <= TIER_3) and isAnyTrigger and not na(trackingStopLoss) and not na(dolTarget) and not hasActiveTrade and barstate.isconfirmed

if newSetupGenerated
    // Record the new setup
    hasActiveTrade := true
    activeEntry := close
    activeStop := trackingStopLoss
    activeTarget := dolTarget
    activeDirection := dolDirection
    activeBar := bar_index
    activePattern := activeTrigger
    activeTier := compositeTier
    totalSetupsGenerated := totalSetupsGenerated + 1

    // Create trade record
    newTrade = TradeRecord.new()
    newTrade.barIndex := bar_index
    newTrade.setupType := activeTrigger
    newTrade.tier := compositeTier
    newTrade.direction := dolDirection
    newTrade.entryPrice := close
    newTrade.stopLoss := stopLoss
    newTrade.target := dolTarget
    newTrade.rr := riskReward
    newTrade.outcome := "PENDING"
    newTrade.pnlPercent := 0.0
    newTrade.confluenceCount := confluenceCount
    newTrade.inKillzone := hasKillzone
    newTrade.inOTE := inOTE

    // Add to session trades (limit to 100)
    if array.size(sessionTrades) >= 100
        array.shift(sessionTrades)
    array.push(sessionTrades, newTrade)
    sessionPending := sessionPending + 1

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRACK TRADE OUTCOME (Target Hit vs Stop Hit)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if hasActiveTrade
    // Check for LONG trade outcome
    if activeDirection == DIR_BULL
        // Target hit (WIN)
        if high >= activeTarget
            hasActiveTrade := false
            sessionWins := sessionWins + 1
            sessionPending := sessionPending - 1
            actualRR = (activeTarget - activeEntry) / (activeEntry - activeStop)
            sessionTotalRR := sessionTotalRR + actualRR
            if actualRR > sessionBestRR
                sessionBestRR := actualRR

            // Update tier stats
            if activeTier == TIER_1
                tier1Wins := tier1Wins + 1
            else if activeTier == TIER_2
                tier2Wins := tier2Wins + 1
            else if activeTier == TIER_3
                tier3Wins := tier3Wins + 1

            // Update pattern stats
            if activePattern == "UNICORN"
                unicornWins := unicornWins + 1
            else if activePattern == "MMXM"
                mmxmWins := mmxmWins + 1
            else if activePattern == "2022 MODEL"
                model2022Wins := model2022Wins + 1
            else if activePattern == "TURTLE SOUP"
                turtleSoupWins := turtleSoupWins + 1
            else if activePattern == "JUDAS SWING"
                judasWins := judasWins + 1

            // Update last trade record
            if array.size(sessionTrades) > 0
                lastTrade = array.get(sessionTrades, array.size(sessionTrades) - 1)
                lastTrade.outcome := "WIN"
                lastTrade.pnlPercent := actualRR

        // Stop hit (LOSS)
        else if low <= activeStop
            hasActiveTrade := false
            sessionLosses := sessionLosses + 1
            sessionPending := sessionPending - 1
            actualRR = -1.0  // Lost 1R
            sessionTotalRR := sessionTotalRR + actualRR
            if actualRR < sessionWorstRR or sessionWorstRR == 0
                sessionWorstRR := actualRR

            // Update tier stats
            if activeTier == TIER_1
                tier1Losses := tier1Losses + 1
            else if activeTier == TIER_2
                tier2Losses := tier2Losses + 1
            else if activeTier == TIER_3
                tier3Losses := tier3Losses + 1

            // Update pattern stats
            if activePattern == "UNICORN"
                unicornLosses := unicornLosses + 1
            else if activePattern == "MMXM"
                mmxmLosses := mmxmLosses + 1
            else if activePattern == "2022 MODEL"
                model2022Losses := model2022Losses + 1
            else if activePattern == "TURTLE SOUP"
                turtleSoupLosses := turtleSoupLosses + 1
            else if activePattern == "JUDAS SWING"
                judasLosses := judasLosses + 1

            // Update last trade record
            if array.size(sessionTrades) > 0
                lastTrade = array.get(sessionTrades, array.size(sessionTrades) - 1)
                lastTrade.outcome := "LOSS"
                lastTrade.pnlPercent := actualRR

    // Check for SHORT trade outcome
    else if activeDirection == DIR_BEAR
        // Target hit (WIN)
        if low <= activeTarget
            hasActiveTrade := false
            sessionWins := sessionWins + 1
            sessionPending := sessionPending - 1
            actualRR = (activeEntry - activeTarget) / (activeStop - activeEntry)
            sessionTotalRR := sessionTotalRR + actualRR
            if actualRR > sessionBestRR
                sessionBestRR := actualRR

            // Update tier stats
            if activeTier == TIER_1
                tier1Wins := tier1Wins + 1
            else if activeTier == TIER_2
                tier2Wins := tier2Wins + 1
            else if activeTier == TIER_3
                tier3Wins := tier3Wins + 1

            // Update pattern stats
            if activePattern == "UNICORN"
                unicornWins := unicornWins + 1
            else if activePattern == "MMXM"
                mmxmWins := mmxmWins + 1
            else if activePattern == "2022 MODEL"
                model2022Wins := model2022Wins + 1
            else if activePattern == "TURTLE SOUP"
                turtleSoupWins := turtleSoupWins + 1
            else if activePattern == "JUDAS SWING"
                judasWins := judasWins + 1

            // Update last trade record
            if array.size(sessionTrades) > 0
                lastTrade = array.get(sessionTrades, array.size(sessionTrades) - 1)
                lastTrade.outcome := "WIN"
                lastTrade.pnlPercent := actualRR

        // Stop hit (LOSS)
        else if high >= activeStop
            hasActiveTrade := false
            sessionLosses := sessionLosses + 1
            sessionPending := sessionPending - 1
            actualRR = -1.0
            sessionTotalRR := sessionTotalRR + actualRR
            if actualRR < sessionWorstRR or sessionWorstRR == 0
                sessionWorstRR := actualRR

            // Update tier stats
            if activeTier == TIER_1
                tier1Losses := tier1Losses + 1
            else if activeTier == TIER_2
                tier2Losses := tier2Losses + 1
            else if activeTier == TIER_3
                tier3Losses := tier3Losses + 1

            // Update pattern stats
            if activePattern == "UNICORN"
                unicornLosses := unicornLosses + 1
            else if activePattern == "MMXM"
                mmxmLosses := mmxmLosses + 1
            else if activePattern == "2022 MODEL"
                model2022Losses := model2022Losses + 1
            else if activePattern == "TURTLE SOUP"
                turtleSoupLosses := turtleSoupLosses + 1
            else if activePattern == "JUDAS SWING"
                judasLosses := judasLosses + 1

            // Update last trade record
            if array.size(sessionTrades) > 0
                lastTrade = array.get(sessionTrades, array.size(sessionTrades) - 1)
                lastTrade.outcome := "LOSS"
                lastTrade.pnlPercent := actualRR

    // Timeout after 50 bars (invalidate stale setups)
    if bar_index - activeBar > 50
        hasActiveTrade := false
        sessionPending := sessionPending - 1
        if array.size(sessionTrades) > 0
            lastTrade = array.get(sessionTrades, array.size(sessionTrades) - 1)
            lastTrade.outcome := "TIMEOUT"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATE SESSION STATISTICS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

totalCompleted = sessionWins + sessionLosses
winRate = totalCompleted > 0 ? (sessionWins / totalCompleted) * 100 : 0.0
avgRR = totalCompleted > 0 ? sessionTotalRR / totalCompleted : 0.0
expectancy = totalCompleted > 0 ? (winRate/100 * avgRR) - ((100-winRate)/100 * 1.0) : 0.0

// Tier win rates
tier1WinRate = (tier1Wins + tier1Losses) > 0 ? (tier1Wins / (tier1Wins + tier1Losses)) * 100 : 0.0
tier2WinRate = (tier2Wins + tier2Losses) > 0 ? (tier2Wins / (tier2Wins + tier2Losses)) * 100 : 0.0
tier3WinRate = (tier3Wins + tier3Losses) > 0 ? (tier3Wins / (tier3Wins + tier3Losses)) * 100 : 0.0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ¨ VISUAL RENDERING                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION BACKGROUNDS - Very subtle, non-distracting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sessionColor = asianSession ? color.new(#9C27B0, 97) : londonSession ? color.new(#2196F3, 97) : nyAMSession ? color.new(#4CAF50, 97) : nyPMSession ? color.new(#FF9800, 97) : na

// Session/Killzone/Silver Bullet backgrounds combined to reduce plot count
combinedBg = inSilverBullet and i_showSilverBullet ? color.new(#00E5FF, 93) : (asianKZ or londonKZ or nyAMKZ or nyPMKZ) and i_showKillzones ? color.new(#FFC107, 95) : i_showSessions ? sessionColor : na
bgcolor(combinedBg, title="Session/KZ Background")

// BOS/CHoCH labels removed to reduce plot count - structure shown via dashboard and zones

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TURTLE SOUP LABELS (Clean style)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Turtle Soup - clean minimal badge
plotshape(i_showTurtleSoup and bullishTS, title="Turtle Soup Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(i_bullColor, 20), text="TS", textcolor=color.white, size=size.small)
plotshape(i_showTurtleSoup and bearishTS, title="Turtle Soup Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(i_bearColor, 20), text="TS", textcolor=color.white, size=size.small)

// Judas labels removed to reduce plot count - shown in dashboard AMD phase

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEY MODEL LABELS (Combined to reduce plot count - info shown in dashboard)
// Only showing UNICORN (highest conviction) as chart label
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(unicornBull and barstate.isconfirmed, title="Unicorn Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#AA00FF, 10), text="ğŸ¦„", textcolor=color.white, size=size.small)
plotshape(unicornBear and barstate.isconfirmed, title="Unicorn Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#AA00FF, 10), text="ğŸ¦„", textcolor=color.white, size=size.small)

// 2022 MODEL, MMXM, AMD FRACTAL signals shown in dashboard pattern name instead of chart labels

// Swing points and EQH/EQL removed to reduce plot count - tracked via info table

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OTE SPAWN ZONE - Dashed lines with levels
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line oteLine62 = na
var line oteLine705 = na
var line oteLine79 = na
var label oteLabel62 = na
var label oteLabel705 = na
var label oteLabel79 = na

// OTE color - ICT cyan
oteLineColor = #00BCD4

if i_showOTE and barstate.islast
    // Clean up old lines
    if not na(oteLine62)
        line.delete(oteLine62)
    if not na(oteLine705)
        line.delete(oteLine705)
    if not na(oteLine79)
        line.delete(oteLine79)
    if not na(oteLabel62)
        label.delete(oteLabel62)
    if not na(oteLabel705)
        label.delete(oteLabel705)
    if not na(oteLabel79)
        label.delete(oteLabel79)

    // Calculate OTE levels (62%, 70.5%, 79% of the range)
    float ote62 = rangeLow + rangeSize * 0.62
    float ote705 = rangeLow + rangeSize * 0.705
    float ote79 = rangeLow + rangeSize * 0.79

    // Draw dashed lines for each OTE level - subtle reference lines (dimmer)
    oteLine62 := line.new(bar_index - 50, ote62, bar_index + 10, ote62,
         color=color.new(oteLineColor, 75), width=1, style=line.style_dotted)
    oteLine705 := line.new(bar_index - 50, ote705, bar_index + 10, ote705,
         color=color.new(oteLineColor, 60), width=1, style=line.style_dotted)
    oteLine79 := line.new(bar_index - 50, ote79, bar_index + 10, ote79,
         color=color.new(oteLineColor, 75), width=1, style=line.style_dotted)

    // Labels UNDER line, right-aligned (dimmer to match lines)
    float labelOffset = rangeSize * 0.015
    oteLabel62 := label.new(bar_index + 10, ote62 - labelOffset, "62%",
         style=label.style_none, textcolor=color.new(oteLineColor, 60), size=size.tiny, textalign=text.align_right)
    oteLabel705 := label.new(bar_index + 10, ote705 - labelOffset, "OTE",
         style=label.style_none, textcolor=color.new(oteLineColor, 50), size=size.tiny, textalign=text.align_right)
    oteLabel79 := label.new(bar_index + 10, ote79 - labelOffset, "79%",
         style=label.style_none, textcolor=color.new(oteLineColor, 60), size=size.tiny, textalign=text.align_right)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LONGEST WICK CE - ICT's Special Level (Hidden Gem)
// "Consequent encroachment of the longest wick... that's the one that matters"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line longestWickCELine = na
var label longestWickCELabel = na

// Color based on wick direction
lwceColor = longestWickDirection == 1 ? #FF5252 : longestWickDirection == -1 ? #00E676 : #78909C

if barstate.islast and not na(longestWickCE)
    // Clean up old
    if not na(longestWickCELine)
        line.delete(longestWickCELine)
    if not na(longestWickCELabel)
        label.delete(longestWickCELabel)

    // Draw the Longest Wick CE line - distinctive teal with circle markers
    longestWickCELine := line.new(bar_index - 30, longestWickCE, bar_index + 15, longestWickCE,
         color=color.new(#00BFA5, 40), width=2, style=line.style_dotted)

    // Label with direction indicator
    lwceText = longestWickDirection == 1 ? "âŠ• LW-CE â–¼" : longestWickDirection == -1 ? "âŠ• LW-CE â–²" : "âŠ• LW-CE"
    longestWickCELabel := label.new(bar_index + 15, longestWickCE, lwceText,
         style=label.style_none, textcolor=color.new(#00BFA5, 20), size=size.tiny, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKET MAKER MODEL STATE - 9/18 EMA Visual (Hidden Gem)
// "Market makers will generally price markets lower to buy [BUY MODEL]"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var label mmModelLabel = na

if barstate.islast
    // Clean up old
    if not na(mmModelLabel)
        label.delete(mmModelLabel)

    // Position in top-left area of chart (below price)
    mmLabelY = low - (high - low) * 0.15
    mmLabelColor = mmModelBullish ? #00E676 : mmModelBearish ? #FF5252 : #78909C
    mmLabelText = mmModelBullish ? "ğŸŸ¢ MM BUY MODEL" : mmModelBearish ? "ğŸ”´ MM SELL MODEL" : "âšª MM NEUTRAL"

    mmModelLabel := label.new(bar_index + 2, mmLabelY, mmLabelText,
         style=label.style_none, textcolor=mmLabelColor, size=size.small, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM/DISCOUNT ZONES - Subtle reference lines
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(i_showPDZones ? premiumZone : na, "Premium Zone", color=color.new(i_bearColor, 80), linewidth=1, style=plot.style_linebr)
plot(i_showPDZones ? discountZone : na, "Discount Zone", color=color.new(i_bullColor, 80), linewidth=1, style=plot.style_linebr)
plot(i_showEQ ? equilibrium : na, "Equilibrium", color=color.new(#78909C, 60), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CBDR GRID - Subtle background grid lines (toggle-able)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line cbdrGridHigh = na
var line cbdrGridLow = na
var line cbdrGridSD1High = na
var line cbdrGridSD1Low = na
var label cbdrLabelHigh = na
var label cbdrLabelLow = na
var label cbdrLabelSD1High = na
var label cbdrLabelSD1Low = na

// Draw CBDR as subtle grid on last bar only
if barstate.islast and i_showCBDR
    // Clean up previous grid lines and labels
    if not na(cbdrGridHigh)
        line.delete(cbdrGridHigh)
    if not na(cbdrGridLow)
        line.delete(cbdrGridLow)
    if not na(cbdrGridSD1High)
        line.delete(cbdrGridSD1High)
    if not na(cbdrGridSD1Low)
        line.delete(cbdrGridSD1Low)
    if not na(cbdrLabelHigh)
        label.delete(cbdrLabelHigh)
    if not na(cbdrLabelLow)
        label.delete(cbdrLabelLow)
    if not na(cbdrLabelSD1High)
        label.delete(cbdrLabelSD1High)
    if not na(cbdrLabelSD1Low)
        label.delete(cbdrLabelSD1Low)

    // Subtle grid color
    cbdrGridColor = color.new(color.teal, 85)
    cbdrSDColor = color.new(color.teal, 90)

    // CBDR High/Low - subtle dotted lines extending full width
    if not na(cbdrHigh)
        cbdrGridHigh := line.new(bar_index - 200, cbdrHigh, bar_index + 30, cbdrHigh,
             color=cbdrGridColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelHigh := label.new(bar_index + 30, cbdrHigh, "CBDR Hi",
             style=label.style_none, textcolor=color.new(color.teal, 50), size=size.tiny, textalign=text.align_left)

    if not na(cbdrLow)
        cbdrGridLow := line.new(bar_index - 200, cbdrLow, bar_index + 30, cbdrLow,
             color=cbdrGridColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelLow := label.new(bar_index + 30, cbdrLow, "CBDR Lo",
             style=label.style_none, textcolor=color.new(color.teal, 50), size=size.tiny, textalign=text.align_left)

    // SD Projections - even more subtle, with labels
    if i_showCBDRProjections and not na(cbdrSD1High)
        cbdrGridSD1High := line.new(bar_index - 200, cbdrSD1High, bar_index + 30, cbdrSD1High,
             color=cbdrSDColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelSD1High := label.new(bar_index + 30, cbdrSD1High, "SD+",
             style=label.style_none, textcolor=color.new(color.teal, 70), size=size.tiny, textalign=text.align_left)

    if i_showCBDRProjections and not na(cbdrSD1Low)
        cbdrGridSD1Low := line.new(bar_index - 200, cbdrSD1Low, bar_index + 30, cbdrSD1Low,
             color=cbdrSDColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelSD1Low := label.new(bar_index + 30, cbdrSD1Low, "SD-",
             style=label.style_none, textcolor=color.new(color.teal, 70), size=size.tiny, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NWOG ZONE - Multi-week display with progressive fading
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box[] nwogBoxes = array.new_box(0)
var line[] nwogCELines = array.new_line(0)

// Clean up old boxes and lines on last bar
if barstate.islast
    // Delete existing boxes using while loop (safer for empty arrays)
    while array.size(nwogBoxes) > 0
        box.delete(array.pop(nwogBoxes))

    // Delete existing CE lines
    while array.size(nwogCELines) > 0
        line.delete(array.pop(nwogCELines))

    // Draw new boxes for each stored NWOG
    int nwogCount = array.size(nwogHighs)
    if i_showNWOG and nwogCount > 0
        for i = 0 to nwogCount - 1
            float h = array.get(nwogHighs, i)
            float l = array.get(nwogLows, i)
            float ce = array.get(nwogCEs, i)

            // Pastel periwinkle for NWOG - progressive fading for older weeks
            nwogColor = #B39DDB  // Pastel purple/periwinkle
            int fadeLevel = 0 + (i * 15)  // 0, 15, 30, 45, 60 for 5 weeks
            int bgFade = 70 + (i * 5)     // 70, 75, 80, 85, 90 for 5 weeks
            fadeLevel := math.min(fadeLevel, 70)
            bgFade := math.min(bgFade, 90)

            // Label: NWOG-1 (current) through NWOG-5 (oldest)
            string nwogLabel = "NWOG-" + str.tostring(i + 1)

            // Draw box relative to current bar (safe approach)
            int boxLeft = bar_index - 50
            box newBox = box.new(boxLeft, h, bar_index + 10, l,
                 border_color=color.new(nwogColor, fadeLevel), bgcolor=color.new(nwogColor, bgFade),
                 border_width=2, border_style=line.style_solid,
                 text=nwogLabel, text_color=color.new(nwogColor, fadeLevel), text_size=size.tiny, text_halign=text.align_right)
            array.push(nwogBoxes, newBox)

            // Draw CE line for each NWOG
            if i_showNWOGCE
                int ceFade = 20 + (i * 15)  // 20, 35, 50, 65, 80 for 5 weeks
                ceFade := math.min(ceFade, 80)
                line ceLine = line.new(boxLeft, ce, bar_index + 10, ce,
                     color=color.new(nwogColor, ceFade), width=i == 0 ? 2 : 1, style=line.style_dashed)
                array.push(nwogCELines, ceLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPENING RANGE GAP (ORG) VISUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box orgBox = na
gapColor = #FFCC80  // Pastel orange for Opening Range Gap

if hasORG and not na(orgHigh) and not na(orgLow) and barstate.islast
    if not na(orgBox)
        box.delete(orgBox)
    orgBox := box.new(bar_index - 20, orgHigh, bar_index + 5, orgLow,
         border_color=gapColor, bgcolor=color.new(gapColor, 75),
         border_width=2, border_style=line.style_solid,
         text="GAP", text_color=gapColor, text_size=size.tiny, text_halign=text.align_right)

// GAP CE line
plot(hasORG and not na(orgCE) ? orgCE : na, "GAP CE", color=color.new(gapColor, 30), linewidth=2, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MIDNIGHT OPEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(i_showMidnight and not na(midnightOpen) ? midnightOpen : na, "Midnight Open", color=color.new(color.white, 50), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IPDA LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IPDA plots reduced to stay under 64 plot limit
plot(i_ipda60 and i_showIPDA ? high60IPDA : na, "IPDA 60 High", color=color.new(color.blue, 60), linewidth=1, style=plot.style_linebr)
plot(i_ipda60 and i_showIPDA ? low60IPDA : na, "IPDA 60 Low", color=color.new(color.blue, 60), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAC-MAN DOL PATH VISUALIZATION - Sleek arcade style
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAC-MAN DOL PATH - Dynamic Multi-Waypoint "Most Likely Path"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line[] dolPathLines = array.new_line(0)
var label[] dolPathLabels = array.new_label(0)

// Pac-Man themed colors
pacmanYellow = #FFEB3B  // Classic Pac-Man yellow
pacmanGold = #FFC107    // Golden pellets
pacmanCyan = #00BCD4    // Path color

if i_showDOL and i_showPacMan and barstate.islast
    // Clean up old visuals
    while array.size(dolPathLines) > 0
        line.delete(array.pop(dolPathLines))
    while array.size(dolPathLabels) > 0
        label.delete(array.pop(dolPathLabels))

    // Determine visual style based on setup quality
    tradeReady = (compositeTier == TIER_1 or compositeTier == TIER_2) and
                 (manipulationComplete or amdPhase == 3) and
                 dolDirection != DIR_NEUTRAL
    highConf = compositeTier <= TIER_3 and dolDirection != DIR_NEUTRAL

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BUILD WAYPOINT ARRAY - Collect all liquidity targets sorted by distance
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Arrays to hold waypoint data (parallel arrays for level, name, strength)
    var float[] wpLevels = array.new_float(0)
    var string[] wpNames = array.new_string(0)
    var int[] wpStrength = array.new_int(0)  // Higher = stronger draw

    // Clear previous waypoints
    array.clear(wpLevels)
    array.clear(wpNames)
    array.clear(wpStrength)

    if dolDirection == DIR_BULL
        // Collect all UNSWEPT targets ABOVE current price
        // BSL (60 IPDA) - Strongest draw
        if not na(high60IPDA) and high60IPDA > close
            array.push(wpLevels, high60IPDA)
            array.push(wpNames, "BSL")
            array.push(wpStrength, 100)

        // PWH - Strong weekly level
        if not pwhSwept and not na(pwh) and pwh > close
            array.push(wpLevels, pwh)
            array.push(wpNames, "PWH")
            array.push(wpStrength, 80)

        // PDH - Daily level
        if not pdhSwept and not na(pdh) and pdh > close
            array.push(wpLevels, pdh)
            array.push(wpNames, "PDH")
            array.push(wpStrength, 60)

        // London High - Session level
        if not londonHighSwept and not na(londonHigh) and londonHigh > close and not londonSession
            array.push(wpLevels, londonHigh)
            array.push(wpNames, "LDN")
            array.push(wpStrength, 40)

        // NY High - Session level
        if not nyHighSwept and not na(nyHigh) and nyHigh > close and not (nyAMSession or nyPMSession)
            array.push(wpLevels, nyHigh)
            array.push(wpNames, "NY")
            array.push(wpStrength, 30)

    else if dolDirection == DIR_BEAR
        // Collect all UNSWEPT targets BELOW current price
        // SSL (60 IPDA) - Strongest draw
        if not na(low60IPDA) and low60IPDA < close
            array.push(wpLevels, low60IPDA)
            array.push(wpNames, "SSL")
            array.push(wpStrength, 100)

        // PWL - Strong weekly level
        if not pwlSwept and not na(pwl) and pwl < close
            array.push(wpLevels, pwl)
            array.push(wpNames, "PWL")
            array.push(wpStrength, 80)

        // PDL - Daily level
        if not pdlSwept and not na(pdl) and pdl < close
            array.push(wpLevels, pdl)
            array.push(wpNames, "PDL")
            array.push(wpStrength, 60)

        // London Low - Session level
        if not londonLowSwept and not na(londonLow) and londonLow < close and not londonSession
            array.push(wpLevels, londonLow)
            array.push(wpNames, "LDN")
            array.push(wpStrength, 40)

        // NY Low - Session level
        if not nyLowSwept and not na(nyLow) and nyLow < close and not (nyAMSession or nyPMSession)
            array.push(wpLevels, nyLow)
            array.push(wpNames, "NY")
            array.push(wpStrength, 30)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SORT WAYPOINTS BY DISTANCE (nearest first for the path)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    numWaypoints = array.size(wpLevels)

    // Simple bubble sort by distance from close
    if numWaypoints > 1
        for i = 0 to numWaypoints - 2
            for j = 0 to numWaypoints - i - 2
                dist1 = math.abs(array.get(wpLevels, j) - close)
                dist2 = math.abs(array.get(wpLevels, j + 1) - close)
                if dist1 > dist2
                    // Swap all parallel arrays
                    tempLevel = array.get(wpLevels, j)
                    tempName = array.get(wpNames, j)
                    tempStr = array.get(wpStrength, j)
                    array.set(wpLevels, j, array.get(wpLevels, j + 1))
                    array.set(wpNames, j, array.get(wpNames, j + 1))
                    array.set(wpStrength, j, array.get(wpStrength, j + 1))
                    array.set(wpLevels, j + 1, tempLevel)
                    array.set(wpNames, j + 1, tempName)
                    array.set(wpStrength, j + 1, tempStr)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART PULLBACK SYSTEM - Multi-factor retracement analysis
    // Priority: 1) FVG  2) Order Block  3) Liquidity  4) Equilibrium  5) OTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Limit to max 5 waypoints for clean visualization
    maxWaypoints = math.min(numWaypoints, 5)

    if maxWaypoints > 0
        // Starting point
        prevX = bar_index + 2
        prevY = close
        xSpacingToTarget = 8   // bars to reach target
        xSpacingPullback = 4   // bars for pullback

        // Choose colors based on setup quality - MORE VISIBLE
        pathColor = tradeReady ? pacmanYellow : highConf ? pacmanGold : color.new(pacmanCyan, 20)
        pullbackColor = tradeReady ? color.new(pacmanYellow, 30) : highConf ? color.new(pacmanGold, 40) : color.new(pacmanCyan, 50)
        fvgPbColor = color.new(#7C4DFF, 30)   // Purple for FVG pullback
        obPbColor = color.new(#2196F3, 30)    // Blue for OB pullback
        liqPbColor = color.new(#FF9800, 30)   // Orange for liquidity sweep
        suspPbColor = color.new(#00E676, 20)  // Bright green for Suspension Block (highest priority)
        viPbColor = color.new(#E040FB, 30)    // Magenta for Volume Imbalance
        lvPbColor = color.new(#FF1744, 30)    // Red for Liquidity Void
        rejPbColor = color.new(#FFAB00, 25)   // Amber for Rejection Block (ICT hidden gem)
        lwCEPbColor = color.new(#00BFA5, 25)  // Teal for Longest Wick CE (ICT hidden gem)
        wgCEPbColor = color.new(#B388FF, 25)  // Light purple for Wick Gradient CE (ICT notepad)
        pathWidth = tradeReady ? 3 : highConf ? 3 : 2
        pathStyle = tradeReady ? line.style_solid : line.style_dashed

        // Draw Pac-Man at start if trade ready
        if tradeReady
            pacmanIcon = dolDirection == DIR_BULL ? "á—§" : "á—¤"
            pacmanLabel = label.new(bar_index + 1, close, pacmanIcon,
                 style=label.style_none, textcolor=pacmanYellow, size=size.large)
            array.push(dolPathLabels, pacmanLabel)

        // Draw realistic zigzag path through each waypoint
        for i = 0 to maxWaypoints - 1
            wpLevel = array.get(wpLevels, i)
            wpName = array.get(wpNames, i)
            wpStr = array.get(wpStrength, i)

            // Calculate the move from previous point to this target
            moveSize = wpLevel - prevY
            moveHigh = math.max(prevY, wpLevel)
            moveLow = math.min(prevY, wpLevel)

            // â•â•â• STEP 1: Draw line from previous point TO the target â•â•â•
            targetX = prevX + xSpacingToTarget
            targetY = wpLevel

            targetLine = line.new(prevX, prevY, targetX, targetY,
                 color=pathColor, width=pathWidth, style=pathStyle)
            array.push(dolPathLines, targetLine)

            // Draw waypoint marker at target
            if tradeReady
                dotSize = wpStr >= 80 ? size.large : wpStr >= 50 ? size.normal : size.small
                dotLabel = label.new(targetX, targetY, "â—",
                     style=label.style_none, textcolor=pacmanYellow, size=dotSize)
                array.push(dolPathLabels, dotLabel)
            else
                dotLabel = label.new(targetX, targetY, "â€¢",
                     style=label.style_none, textcolor=pathColor, size=size.small)
                array.push(dolPathLabels, dotLabel)

            // Add waypoint name label - MORE VISIBLE
            labelY = dolDirection == DIR_BULL ? targetY * 0.9998 : targetY * 1.0002
            nameLabel = label.new(targetX, labelY, wpName,
                 style=label.style_none, textcolor=color.new(pathColor, 0), size=size.small, textalign=text.align_center)
            array.push(dolPathLabels, nameLabel)

            // â•â•â• STEP 2: SMART PULLBACK - Find best retracement level â•â•â•
            if i < maxWaypoints - 1
                float pullbackY = na
                string pbReason = ""
                color pbColor = pullbackColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 0: SUSPENSION BLOCK (ICT's MOST POWERFUL PD Array)
                // Single candle with Volume Imbalance at BOTH ends
                // "Being suspended between two volume imbalances" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if dolDirection == DIR_BULL
                    if array.size(bullSuspBlocks) > 0
                        for j = 0 to math.min(array.size(bullSuspBlocks) - 1, 3)
                            sb = array.get(bullSuspBlocks, j)
                            // Unmitigated Suspension Block in our pullback zone
                            if not sb.mitigated and sb.top < targetY and sb.bottom > moveLow
                                pullbackY := sb.top  // Retrace to top of Suspension Block
                                pbReason := "SUSP"
                                pbColor := suspPbColor
                                break
                else if dolDirection == DIR_BEAR
                    if array.size(bearSuspBlocks) > 0
                        for j = 0 to math.min(array.size(bearSuspBlocks) - 1, 3)
                            sb = array.get(bearSuspBlocks, j)
                            if not sb.mitigated and sb.bottom > targetY and sb.top < moveHigh
                                pullbackY := sb.bottom  // Retrace to bottom of Suspension Block
                                pbReason := "SUSP"
                                pbColor := suspPbColor
                                break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 1: Check for unfilled FVG in the pullback zone
                // Price loves to retrace to fill imbalances
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Bullish move - look for bearish FVG (SIBI) below target to fill
                        if array.size(bearFVGs) > 0
                            for j = 0 to math.min(array.size(bearFVGs) - 1, 8)
                                fvg = array.get(bearFVGs, j)
                                // FVG is in our pullback zone (between prevY and targetY)
                                if not fvg.mitigated and fvg.top < targetY and fvg.bottom > moveLow
                                    pullbackY := fvg.top  // Retrace to top of bearish FVG
                                    pbReason := "FVG"
                                    pbColor := fvgPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        // Bearish move - look for bullish FVG (BISI) above target to fill
                        if array.size(bullFVGs) > 0
                            for j = 0 to math.min(array.size(bullFVGs) - 1, 8)
                                fvg = array.get(bullFVGs, j)
                                if not fvg.mitigated and fvg.bottom > targetY and fvg.top < moveHigh
                                    pullbackY := fvg.bottom  // Retrace to bottom of bullish FVG
                                    pbReason := "FVG"
                                    pbColor := fvgPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 2: Volume Imbalance (Gap between consecutive bodies)
                // Strong institutional price action - gap must be filled
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bearVIs) > 0
                            for j = 0 to math.min(array.size(bearVIs) - 1, 5)
                                vi = array.get(bearVIs, j)
                                if not vi.filled and vi.top < targetY and vi.bottom > moveLow
                                    pullbackY := vi.top  // Retrace to top of Volume Imbalance
                                    pbReason := "VI"
                                    pbColor := viPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bullVIs) > 0
                            for j = 0 to math.min(array.size(bullVIs) - 1, 5)
                                vi = array.get(bullVIs, j)
                                if not vi.filled and vi.bottom > targetY and vi.top < moveHigh
                                    pullbackY := vi.bottom  // Retrace to bottom of Volume Imbalance
                                    pbReason := "VI"
                                    pbColor := viPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 3: Check for Order Block to retest
                // Institutions defend their entry points
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Look for bullish OB (support) below target
                        if array.size(bullOBs) > 0
                            for j = 0 to math.min(array.size(bullOBs) - 1, 5)
                                ob = array.get(bullOBs, j)
                                // Fresh or Tested OB in our range
                                if (ob.state == OB_FRESH or ob.state == OB_TESTED) and ob.top < targetY and ob.top > moveLow
                                    pullbackY := ob.top  // Retrace to top of OB
                                    pbReason := "OB"
                                    pbColor := obPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        // Look for bearish OB (resistance) above target
                        if array.size(bearOBs) > 0
                            for j = 0 to math.min(array.size(bearOBs) - 1, 5)
                                ob = array.get(bearOBs, j)
                                if (ob.state == OB_FRESH or ob.state == OB_TESTED) and ob.bottom > targetY and ob.bottom < moveHigh
                                    pullbackY := ob.bottom  // Retrace to bottom of OB
                                    pbReason := "OB"
                                    pbColor := obPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 4: Liquidity Void (Large displacement gap)
                // Price must fill this inefficiency before continuing
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bearLiqVoids) > 0
                            for j = 0 to math.min(array.size(bearLiqVoids) - 1, 3)
                                lv = array.get(bearLiqVoids, j)
                                if not lv.filled and lv.top < targetY and lv.bottom > moveLow
                                    pullbackY := lv.top  // Retrace to top of Liquidity Void
                                    pbReason := "LV"
                                    pbColor := lvPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bullLiqVoids) > 0
                            for j = 0 to math.min(array.size(bullLiqVoids) - 1, 3)
                                lv = array.get(bullLiqVoids, j)
                                if not lv.filled and lv.bottom > targetY and lv.top < moveHigh
                                    pullbackY := lv.bottom  // Retrace to bottom of Liquidity Void
                                    pbReason := "LV"
                                    pbColor := lvPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 5: Check for nearby liquidity to sweep
                // Price hunts stops before continuing
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Look for sellside liquidity (equal lows, session lows) to sweep
                        // Check session lows that haven't been swept
                        if not londonLowSwept and not na(londonLow) and londonLow < targetY and londonLow > moveLow
                            pullbackY := londonLow * 0.9998  // Sweep just below
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                        else if not nyLowSwept and not na(nyLow) and nyLow < targetY and nyLow > moveLow
                            pullbackY := nyLow * 0.9998
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                    else if dolDirection == DIR_BEAR
                        // Look for buyside liquidity (equal highs, session highs) to sweep
                        if not londonHighSwept and not na(londonHigh) and londonHigh > targetY and londonHigh < moveHigh
                            pullbackY := londonHigh * 1.0002  // Sweep just above
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                        else if not nyHighSwept and not na(nyHigh) and nyHigh > targetY and nyHigh < moveHigh
                            pullbackY := nyHigh * 1.0002
                            pbReason := "LIQ"
                            pbColor := liqPbColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 6: REJECTION BLOCK (ICT Hidden Gem)
                // Single candle close rejection - different from Order Block
                // "This is the close that gets REJECTED" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bullRejBlocks) > 0
                            for j = 0 to math.min(array.size(bullRejBlocks) - 1, 5)
                                rb = array.get(bullRejBlocks, j)
                                if not rb.mitigated and rb.level < targetY and rb.level > moveLow
                                    pullbackY := rb.level  // Retrace to rejection level
                                    pbReason := "REJ"
                                    pbColor := rejPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bearRejBlocks) > 0
                            for j = 0 to math.min(array.size(bearRejBlocks) - 1, 5)
                                rb = array.get(bearRejBlocks, j)
                                if not rb.mitigated and rb.level > targetY and rb.level < moveHigh
                                    pullbackY := rb.level  // Retrace to rejection level
                                    pbReason := "REJ"
                                    pbColor := rejPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 7: LONGEST WICK CE (ICT Hidden Gem)
                // "Find THE longest wick, use ONLY its CE" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if not na(longestWickCE) and longestWickDirection != 0
                        // Use longest wick CE if it's in our pullback zone
                        if dolDirection == DIR_BULL and longestWickCE < targetY and longestWickCE > moveLow
                            pullbackY := longestWickCE
                            pbReason := "LW-CE"
                            pbColor := lwCEPbColor
                        else if dolDirection == DIR_BEAR and longestWickCE > targetY and longestWickCE < moveHigh
                            pullbackY := longestWickCE
                            pbReason := "LW-CE"
                            pbColor := lwCEPbColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 8: WICK GRADIENT CE (ICT Notepad System)
                // "0/25/50/75/100% on wicks" - ICT's notepad levels
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(discountWicks) > 0
                            for j = 0 to math.min(array.size(discountWicks) - 1, 4)
                                wg = array.get(discountWicks, j)
                                if wg.active and wg.wick50 < targetY and wg.wick50 > moveLow
                                    pullbackY := wg.wick50  // Retrace to wick CE (50%)
                                    pbReason := "WG-CE"
                                    pbColor := wgCEPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(premiumWicks) > 0
                            for j = 0 to math.min(array.size(premiumWicks) - 1, 4)
                                wg = array.get(premiumWicks, j)
                                if wg.active and wg.wick50 > targetY and wg.wick50 < moveHigh
                                    pullbackY := wg.wick50  // Retrace to wick CE (50%)
                                    pbReason := "WG-CE"
                                    pbColor := wgCEPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 9: Equilibrium (50%) - Fair value of the move
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    // Check if we're in a strong trend (use shallower pullback)
                    // or ranging (use equilibrium)
                    eqLevel = targetY - (moveSize * 0.5)

                    // Use equilibrium if move was large (strong momentum = shallow retrace)
                    if math.abs(moveSize) > math.abs(targetY * 0.005)  // > 0.5% move
                        pullbackY := eqLevel
                        pbReason := "EQ"

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 10: OTE Zone (0.618-0.786) - Fallback
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    // Dynamic OTE based on volatility
                    // Calm market = deeper retrace (0.79), volatile = shallower (0.62)
                    // Using global atrVal instead of ta.atr(14) inside conditional
                    volatilityRatio = atrVal / close
                    oteLevel = volatilityRatio > 0.02 ? 0.618 : volatilityRatio > 0.01 ? 0.705 : 0.786

                    pullbackY := targetY - (moveSize * oteLevel)
                    pbReason := "OTE"

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // DRAW THE PULLBACK
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pullbackX = targetX + xSpacingPullback

                // Draw pullback line - thicker for visibility, keep dotted
                pullbackLine = line.new(targetX, targetY, pullbackX, pullbackY,
                     color=pbColor, width=2, style=line.style_dotted)
                array.push(dolPathLines, pullbackLine)

                // Pullback marker with reason
                // Marker symbols: SUSP=â˜… VI=â—† LV=â–¼ FVG=â—ˆ OB=â–  LIQ=â—‡ REJ=â— LW-CE=âŠ• WG-CE=âŠ™ EQ=â—¦ OTE=â—‹
                pbMarkerText = pbReason == "SUSP" ? "â˜…" : pbReason == "VI" ? "â—†" : pbReason == "LV" ? "â–¼" : pbReason == "FVG" ? "â—ˆ" : pbReason == "OB" ? "â– " : pbReason == "LIQ" ? "â—‡" : pbReason == "REJ" ? "â—" : pbReason == "LW-CE" ? "âŠ•" : pbReason == "WG-CE" ? "âŠ™" : pbReason == "EQ" ? "â—¦" : "â—‹"
                pbMarker = label.new(pullbackX, pullbackY, pbMarkerText,
                     style=label.style_none, textcolor=pbColor, size=size.tiny)
                array.push(dolPathLabels, pbMarker)

                // Add reason label (tiny, below marker)
                if pbReason != ""
                    reasonY = dolDirection == DIR_BULL ? pullbackY * 0.9997 : pullbackY * 1.0003
                    reasonLabel = label.new(pullbackX, reasonY, pbReason,
                         style=label.style_none, textcolor=color.new(pbColor, 30), size=size.tiny, textalign=text.align_center)
                    array.push(dolPathLabels, reasonLabel)

                // Update previous point to pullback location for next segment
                prevX := pullbackX
                prevY := pullbackY
            else
                // Last waypoint - no pullback needed
                prevX := targetX
                prevY := targetY

        // Add final target marker
        if tradeReady
            finalLabel = label.new(prevX + 3, prevY, "ğŸ¯",
                 style=label.style_none, textcolor=pacmanYellow, size=size.normal)
            array.push(dolPathLabels, finalLabel)

    else
        // No waypoints found - draw simple arrow to dolTarget if available
        if not na(dolTarget) and dolDirection != DIR_NEUTRAL
            arrowColor = dolDirection == DIR_BULL ? color.new(i_bullColor, 50) : color.new(i_bearColor, 50)
            simpleLine = line.new(bar_index + 2, close, bar_index + 14, dolTarget,
                 color=arrowColor, width=1, style=line.style_arrow_right)
            array.push(dolPathLines, simpleLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ‘» GHOST LIQUIDITY TARGETS - PAC-MAN ARCADE MODE (Simplified)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var label blinkyLabel = na
var label clydeLabel = na

if i_showPacMan and barstate.islast and not i_cleanMode
    label.delete(blinkyLabel)
    label.delete(clydeLabel)
    blinkyLabel := label.new(bar_index + 20, high60IPDA, "ğŸ‘» BSL", style=label.style_none, textcolor=#FF0000, size=size.normal)
    clydeLabel := label.new(bar_index + 20, low60IPDA, "ğŸ‘» SSL", style=label.style_none, textcolor=#FFB852, size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SEQUENCING - Visual Lines (Simplified)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line pdhLine = na, var line pdlLine = na, var line pwhLine = na, var line pwlLine = na
var label pdhLabel = na, var label pdlLabel = na, var label pwhLabel = na, var label pwlLabel = na

if barstate.islast
    line.delete(pdhLine), line.delete(pdlLine), line.delete(pwhLine), line.delete(pwlLine)
    label.delete(pdhLabel), label.delete(pdlLabel), label.delete(pwhLabel), label.delete(pwlLabel)

    if not na(pdh)
        pdhLine := line.new(bar_index - 20, pdh, bar_index + 40, pdh, color=color.new(#FF9800, pdhSwept ? 70 : 20), width=2)
        pdhLabel := label.new(bar_index + 40, pdh, pdhSwept ? "PDH âœ—" : "PDH", style=label.style_none, textcolor=#FF9800, size=size.small)
    if not na(pdl)
        pdlLine := line.new(bar_index - 20, pdl, bar_index + 40, pdl, color=color.new(#FF9800, pdlSwept ? 70 : 20), width=2)
        pdlLabel := label.new(bar_index + 40, pdl, pdlSwept ? "PDL âœ—" : "PDL", style=label.style_none, textcolor=#FF9800, size=size.small)
    if not na(pwh)
        pwhLine := line.new(bar_index - 20, pwh, bar_index + 40, pwh, color=color.new(#E040FB, pwhSwept ? 70 : 20), width=2)
        pwhLabel := label.new(bar_index + 40, pwh, pwhSwept ? "PWH âœ—" : "PWH", style=label.style_none, textcolor=#E040FB, size=size.small)
    if not na(pwl)
        pwlLine := line.new(bar_index - 20, pwl, bar_index + 40, pwl, color=color.new(#E040FB, pwlSwept ? 70 : 20), width=2)
        pwlLabel := label.new(bar_index + 40, pwl, pwlSwept ? "PWL âœ—" : "PWL", style=label.style_none, textcolor=#E040FB, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE TIER SIGNALS (Only on TRUE high-confluence events)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tier 1 requires ACTUAL confluence events, not just high probability
// Must have at least one of these triggers: Model2022, TurtleSoup, Judas, or CHoCH
hasTriggerEvent = model2022Bull or model2022Bear or bullishTS or bearishTS or bullishJudas or bearishJudas or bullishCHoCH or bearishCHoCH or unicornBull or unicornBear or mmxmBullConfirm or mmxmBearConfirm or amdFractalBull or amdFractalBear

tier1Bull = i_showComposite and compositeTier == TIER_1 and dolDirection == DIR_BULL and hasTriggerEvent
tier1Bear = i_showComposite and compositeTier == TIER_1 and dolDirection == DIR_BEAR and hasTriggerEvent
tier2Bull = i_showComposite and compositeTier == TIER_2 and dolDirection == DIR_BULL
tier2Bear = i_showComposite and compositeTier == TIER_2 and dolDirection == DIR_BEAR

// Tier labels removed to reduce plot count - tier shown in dashboard
// Entry zone box below provides visual for ELITE/PREMIUM setups

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTRY ZONE BOX & TARGET ARROW (For ELITE/PREMIUM setups)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box entryZoneBox = na
var line targetArrow = na
var label targetLabel = na
var label entryLabel = na

// Only show entry zone for high-tier setups on last bar
if i_showComposite and barstate.islast and (compositeTier == TIER_1 or compositeTier == TIER_2)
    // Clean up previous drawings
    if not na(entryZoneBox)
        box.delete(entryZoneBox)
    if not na(targetArrow)
        line.delete(targetArrow)
    if not na(targetLabel)
        label.delete(targetLabel)
    if not na(entryLabel)
        label.delete(entryLabel)

    // Determine entry zone boundaries (OTE zone) - using rangeHigh/rangeLow from P/D calculation
    entryRange = rangeHigh - rangeLow
    ote62 = dolDirection == DIR_BULL ? rangeLow + entryRange * 0.62 : rangeHigh - entryRange * 0.62
    ote79 = dolDirection == DIR_BULL ? rangeLow + entryRange * 0.79 : rangeHigh - entryRange * 0.79

    // Entry zone box GLOW effect (bright, vibrant colors)
    entryBoxColor = compositeTier == TIER_1 ? color.new(#00FF88, 70) : color.new(#00E676, 75)
    entryBorderColor = compositeTier == TIER_1 ? color.new(#00FF88, 0) : color.new(#00E676, 10)

    // Draw entry zone box with pattern name inside
    patternTextColor = compositeTier == TIER_1 ? #00FF88 : #00E676

    if dolDirection == DIR_BULL
        entryZoneBox := box.new(bar_index - 15, ote79, bar_index + 3, ote62,
             bgcolor=entryBoxColor, border_color=entryBorderColor, border_width=2,
             text=patternName, text_color=patternTextColor, text_size=size.small,
             text_halign=text.align_center, text_valign=text.align_top)
        entryLabel := label.new(bar_index + 4, ote62, "ENTRY",
             style=label.style_none, textcolor=color.new(entryBorderColor, 30), size=size.tiny)
    else if dolDirection == DIR_BEAR
        entryZoneBox := box.new(bar_index - 15, ote62, bar_index + 3, ote79,
             bgcolor=entryBoxColor, border_color=entryBorderColor, border_width=2,
             text=patternName, text_color=patternTextColor, text_size=size.small,
             text_halign=text.align_center, text_valign=text.align_top)
        entryLabel := label.new(bar_index + 4, ote62, "ENTRY",
             style=label.style_none, textcolor=color.new(entryBorderColor, 30), size=size.tiny)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STOP LOSS & RISK:REWARD CALCULATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Find optimal stop loss level (using global var stopLoss)
    stopLoss := na
    slReason = ""

    if dolDirection == DIR_BULL
        // For longs, SL below: OB low, FVG low, recent swing low, or OTE bottom
        slCandidate1 = ote62 - (entryRange * 0.05)  // Just below OTE
        slCandidate2 = na(lastBullRejLevel) ? slCandidate1 : lastBullRejLevel * 0.999

        // Check for nearby OB to place SL below
        if array.size(bullOBs) > 0
            for i = 0 to math.min(array.size(bullOBs) - 1, 3)
                ob = array.get(bullOBs, i)
                if ob.state == OB_TESTED and ob.bottom < ote62 and ob.bottom > rangeLow
                    stopLoss := ob.bottom * 0.999
                    slReason := "OB"
                    break

        if na(stopLoss)
            stopLoss := slCandidate1
            slReason := "OTE"

    else if dolDirection == DIR_BEAR
        // For shorts, SL above: OB high, FVG high, recent swing high, or OTE top
        slCandidate1 = ote62 + (entryRange * 0.05)  // Just above OTE
        slCandidate2 = na(lastBearRejLevel) ? slCandidate1 : lastBearRejLevel * 1.001

        // Check for nearby OB to place SL above
        if array.size(bearOBs) > 0
            for i = 0 to math.min(array.size(bearOBs) - 1, 3)
                ob = array.get(bearOBs, i)
                if ob.state == OB_TESTED and ob.top > ote62 and ob.top < rangeHigh
                    stopLoss := ob.top * 1.001
                    slReason := "OB"
                    break

        if na(stopLoss)
            stopLoss := slCandidate1
            slReason := "OTE"

    // Calculate Risk:Reward
    entryPrice = (ote62 + ote79) / 2  // Middle of OTE
    riskPips = math.abs(entryPrice - stopLoss)
    rewardPips = math.abs(dolTarget - entryPrice)
    riskReward := riskPips > 0 ? rewardPips / riskPips : 0

    // Draw target arrow to liquidity
    targetArrowColor = dolDirection == DIR_BULL ? color.new(#00E676, 20) : color.new(#FF1744, 20)

    if dolDirection == DIR_BULL and not na(dolTarget)
        targetArrow := line.new(bar_index, close, bar_index + 8, dolTarget,
             color=targetArrowColor, width=2, style=line.style_arrow_right)
        targetLabel := label.new(bar_index + 9, dolTarget, "TARGET\n" + str.tostring(dolTarget, format.mintick),
             style=label.style_none, textcolor=targetArrowColor, size=size.tiny)
    else if dolDirection == DIR_BEAR and not na(dolTarget)
        targetArrow := line.new(bar_index, close, bar_index + 8, dolTarget,
             color=targetArrowColor, width=2, style=line.style_arrow_right)
        targetLabel := label.new(bar_index + 9, dolTarget, "TARGET\n" + str.tostring(dolTarget, format.mintick),
             style=label.style_none, textcolor=targetArrowColor, size=size.tiny)

    // Draw Stop Loss line
    var line slLine = na
    var label slLabel = na
    if not na(slLine)
        line.delete(slLine)
    if not na(slLabel)
        label.delete(slLabel)

    if not na(stopLoss)
        slLineColor = color.new(#FF5252, 30)
        slLine := line.new(bar_index - 15, stopLoss, bar_index + 3, stopLoss,
             color=slLineColor, width=1, style=line.style_dashed)
        slLabel := label.new(bar_index + 4, stopLoss, "SL (" + slReason + ")",
             style=label.style_none, textcolor=slLineColor, size=size.tiny)

    // Draw R:R label
    var label rrLabel = na
    if not na(rrLabel)
        label.delete(rrLabel)

    rrColor = riskReward >= 3.0 ? #00E676 : riskReward >= 2.0 ? #69F0AE : riskReward >= 1.5 ? #FFD740 : #FF9800
    rrText = "R:R " + str.tostring(riskReward, "#.#") + ":1"
    rrLabel := label.new(bar_index - 18, entryPrice, rrText,
         style=label.style_none, textcolor=color.new(rrColor, 0), size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// "TAKE THE TRADE" SIGNAL CALCULATION (must be before table uses it)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Create the TAKE THE TRADE conditions (must be calculated outside barstate.islast block)
var bool takeTradeSignalBull = false
var bool takeTradeSignalBear = false

// Update on every bar for proper alerting
takeTradeCondition = (compositeTier == TIER_1 or compositeTier == TIER_2) and
                     (sbPrime or isMacroTime) and
                     isAnyTrigger and
                     inOTE

takeTradeSignalBull := takeTradeCondition and dolDirection == DIR_BULL
takeTradeSignalBear := takeTradeCondition and dolDirection == DIR_BEAR

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOL PROBABILITY DASHBOARD (GOD MODE INFO TABLE) - SLEEK ARCADE DESIGN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Simplified Dashboard Colors
var color tableBg = color.new(#0D0D0D, 5)
var color textDim = color.new(#8892B0, 0)
var color textBright = color.new(#E6F1FF, 0)

// Compact table (17 rows - essential ICT info)
var table infoTable = table.new(position.middle_right, 2, 17, bgcolor=tableBg, border_width=0, frame_width=2, frame_color=color.new(#2121DE, 30))

if i_showDOLTable and barstate.islast
    // Row 0: Direction
    dirText = dolDirection == DIR_BULL ? "â–² LONG" : dolDirection == DIR_BEAR ? "â–¼ SHORT" : "â—† NEUTRAL"
    dirColor = dolDirection == DIR_BULL ? i_bullColor : dolDirection == DIR_BEAR ? i_bearColor : i_neutralColor
    table.cell(infoTable, 0, 0, dirText, text_color=dirColor, text_size=size.normal, bgcolor=color.new(dirColor, 85), text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Row 1: Tier + Pattern
    tierLabel = compositeTier == TIER_1 ? "ELITE" : compositeTier == TIER_2 ? "PREMIUM" : compositeTier == TIER_3 ? "STRONG" : compositeTier == TIER_4 ? "MODERATE" : "WEAK"
    tierColor = compositeTier == TIER_1 ? #00E676 : compositeTier == TIER_2 ? #69F0AE : compositeTier == TIER_3 ? #FFD740 : compositeTier == TIER_4 ? #FF9800 : #FF5252
    table.cell(infoTable, 0, 1, tierLabel + " | " + patternName, text_color=tierColor, text_size=size.small, bgcolor=color.new(tierColor, 90), text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 1, 1, 1)

    // Row 2: MTF Bias (compact)
    wA = mtfBiasW == 1 ? "â†‘" : mtfBiasW == -1 ? "â†“" : "â€”"
    dA = mtfBiasD == 1 ? "â†‘" : mtfBiasD == -1 ? "â†“" : "â€”"
    hA = mtfBias1H == 1 ? "â†‘" : mtfBias1H == -1 ? "â†“" : "â€”"
    bullCnt = (mtfBiasW == 1 ? 1 : 0) + (mtfBiasD == 1 ? 1 : 0) + (mtfBias1H == 1 ? 1 : 0)
    bearCnt = (mtfBiasW == -1 ? 1 : 0) + (mtfBiasD == -1 ? 1 : 0) + (mtfBias1H == -1 ? 1 : 0)
    mtfCol = bullCnt >= 2 ? i_bullColor : bearCnt >= 2 ? i_bearColor : textDim
    table.cell(infoTable, 0, 2, "MTF", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 2, "W" + wA + " D" + dA + " 1H" + hA, text_color=mtfCol, text_size=size.small, bgcolor=tableBg)

    // Row 3: Zone
    zoneText = inPremium ? "PREMIUM" : inDiscount ? "DISCOUNT" : inOTE ? "â—‰ OTE" : "EQ"
    zoneColor = inOTE ? #00BCD4 : inDiscount ? i_bullColor : inPremium ? i_bearColor : textDim
    table.cell(infoTable, 0, 3, "Zone", text_color=textDim, text_size=size.tiny, bgcolor=inOTE ? color.new(#00BCD4, 90) : tableBg)
    table.cell(infoTable, 1, 3, zoneText, text_color=zoneColor, text_size=size.small, bgcolor=inOTE ? color.new(#00BCD4, 90) : tableBg)

    // Row 4: Session
    sessName = inSilverBullet ? "â—‰ SILVER BULLET" : londonKZ or nyAMKZ or nyPMKZ ? "â—‰ KILLZONE" : asianSession ? "ASIA" : londonSession ? "LONDON" : nyAMSession ? "NY-AM" : "OFF"
    table.cell(infoTable, 0, 4, "Session", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 4, sessName, text_color=inSilverBullet ? #00E5FF : textBright, text_size=size.small, bgcolor=tableBg)

    // Row 5: Turtle Soup Stage
    tsText = tsStage == "STALK_HIGH" or tsStage == "STALK_LOW" ? "â— STALK" : tsStage == "TRAP" ? "â—‰ TRAP" : tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" ? "âœ“ CONFIRM" : "â€”"
    tsColor = tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" ? #00E676 : tsStage == "TRAP" ? #FFD740 : textDim
    table.cell(infoTable, 0, 5, "Turtle Soup", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 5, tsText, text_color=tsColor, text_size=size.small, bgcolor=tableBg)

    // Row 6: AMD Phase
    amdText = amdPhase == 1 ? "ACCUM" : amdPhase == 2 ? (asianHighSwept ? "JUDAS â–²" : asianLowSwept ? "JUDAS â–¼" : "MANIP") : amdPhase == 3 ? "DIST" : "â€”"
    table.cell(infoTable, 0, 6, "AMD", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 6, amdText, text_color=manipulationComplete ? dirColor : textDim, text_size=size.small, bgcolor=tableBg)

    // Row 7: Liquidity Sequence (key targets)
    liqSeq = ""
    if dolDirection == DIR_BULL
        if not pdhSwept and not na(pdh) and pdh > close
            liqSeq := "PDHâ†’"
        if not pwhSwept and not na(pwh) and pwh > close
            liqSeq := liqSeq + "PWH"
    else if dolDirection == DIR_BEAR
        if not pdlSwept and not na(pdl) and pdl < close
            liqSeq := "PDLâ†’"
        if not pwlSwept and not na(pwl) and pwl < close
            liqSeq := liqSeq + "PWL"
    liqSeq := liqSeq == "" ? "â€”" : liqSeq
    table.cell(infoTable, 0, 7, "Liq Path", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 7, liqSeq, text_color=dirColor, text_size=size.small, bgcolor=tableBg)

    // Row 8: Confluence
    table.cell(infoTable, 0, 8, "Confluence", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 8, str.tostring(confluenceCount) + "/16", text_color=confluenceCount >= 8 ? #00E676 : textBright, text_size=size.small, bgcolor=tableBg)

    // Row 9: Target
    table.cell(infoTable, 0, 9, "Target", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 9, not na(dolTarget) ? str.tostring(dolTarget, format.mintick) : "â€”", text_color=dirColor, text_size=size.small, bgcolor=tableBg)

    // Row 10: R:R
    table.cell(infoTable, 0, 10, "R:R", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 10, str.tostring(riskReward, "#.#") + ":1", text_color=riskReward >= 2 ? #00E676 : textBright, text_size=size.small, bgcolor=tableBg)

    // Row 11: Key Factors
    table.cell(infoTable, 0, 11, dolReason, text_color=textDim, text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 11, 1, 11)

    // Row 12: Day Type
    dayTypeText = isSeekDestroyDay ? "âš” SEEK&DESTROY" : isExpansionDay ? "ğŸ“ˆ EXPANSION" : isAccumulationDay ? "ğŸ“¦ ACCUMULATION" : "â€”"
    dayTypeCol = isSeekDestroyDay ? #FF9800 : isExpansionDay ? #4CAF50 : isAccumulationDay ? #2196F3 : textDim
    table.cell(infoTable, 0, 12, "Day", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 12, dayTypeText, text_color=dayTypeCol, text_size=size.small, bgcolor=tableBg)

    // Row 13: PD Arrays Active (using ternary to avoid extra scopes)
    pdActive = (hasSuspensionBlock ? "SB " : "") + (hasFVGPresent ? "FVG " : "") + (hasVolumeImbalance ? "VI " : "") + (hasLiquidityVoid ? "LV " : "") + (hasNDOGAlignment ? "NDOG " : "") + (hasFreshOB ? "OB" : "")
    table.cell(infoTable, 0, 13, "PD Arrays", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 13, pdActive == "" ? "â€”" : pdActive, text_color=hasSuspensionBlock ? #00E5FF : textBright, text_size=size.tiny, bgcolor=tableBg)

    // Row 14: Time Risk
    trCol = timeRiskMultiplier >= 1.2 ? #00E676 : timeRiskMultiplier >= 1.0 ? textBright : timeRiskMultiplier >= 0.7 ? #FFD740 : #FF5252
    table.cell(infoTable, 0, 14, "Time Risk", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 14, timeRiskReason + " Ã—" + str.tostring(timeRiskMultiplier, "#.#"), text_color=trCol, text_size=size.small, bgcolor=tableBg)

    // Row 15: Discount Sensitivity
    sensText = discountSensitivity ? "â—‰ ACTIVE " + str.tostring(sensitivityCount) + "/6" : "â€”"
    sensCol = discountSensitivity ? #00E5FF : textDim
    table.cell(infoTable, 0, 15, "Sensitivity", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(infoTable, 1, 15, sensText, text_color=sensCol, text_size=size.small, bgcolor=discountSensitivity ? color.new(#00E5FF, 90) : tableBg)

    // Row 16: Take Trade Signal
    takeIt = (takeTradeSignalBull or takeTradeSignalBear) ? "ğŸš€ TAKE IT!" : "â€”"
    table.cell(infoTable, 0, 16, takeIt, text_color=(takeTradeSignalBull or takeTradeSignalBear) ? #00FF00 : textDim, text_size=size.small, bgcolor=(takeTradeSignalBull or takeTradeSignalBear) ? color.new(#00FF00, 80) : tableBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 16, 1, 16)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// "TAKE THE TRADE" VISUAL SIGNAL LABELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plotshape(takeTradeSignalBull and barstate.isconfirmed, title="ğŸš€ TAKE THE TRADE Long",
     style=shape.labelup, location=location.belowbar,
     color=color.new(#00FF00, 0), text="ğŸš€ TAKE IT", textcolor=color.white, size=size.normal)

plotshape(takeTradeSignalBear and barstate.isconfirmed, title="ğŸš€ TAKE THE TRADE Short",
     style=shape.labeldown, location=location.abovebar,
     color=color.new(#FF0000, 0), text="ğŸš€ TAKE IT", textcolor=color.white, size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š PERFORMANCE TRACKING TABLE (Simplified)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table statsTable = table.new(position.top_left, 2, 4, bgcolor=color.new(#0D0D0D, 10), border_width=0)

if barstate.islast and totalSetupsGenerated > 0
    table.cell(statsTable, 0, 0, "ğŸ“Š STATS", text_color=#FFD700, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 1, 0, str.tostring(winRate, "#") + "% Win", text_color=winRate >= 50 ? #00E676 : #FF5252, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 0, 1, "Setups", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 1, 1, str.tostring(totalSetupsGenerated), text_color=textBright, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 0, 2, "Avg R:R", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 1, 2, str.tostring(avgRR, "#.#"), text_color=avgRR >= 1.5 ? #00E676 : textBright, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 0, 3, "Total R", text_color=textDim, text_size=size.tiny, bgcolor=tableBg)
    table.cell(statsTable, 1, 3, str.tostring(sessionTotalRR, "#.#"), text_color=sessionTotalRR >= 0 ? #00E676 : #FF5252, text_size=size.tiny, bgcolor=tableBg)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS (Enhanced with TAKE THE TRADE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸš€ TAKE THE TRADE - Ultimate alert (highest priority)
alertcondition(takeTradeSignalBull, title="ğŸš€ TAKE THE TRADE Long", message="ğŸš€ TAKE THE TRADE LONG on {{ticker}} - All conditions aligned! Silver Bullet + OTE + Trigger!")
alertcondition(takeTradeSignalBear, title="ğŸš€ TAKE THE TRADE Short", message="ğŸš€ TAKE THE TRADE SHORT on {{ticker}} - All conditions aligned! Silver Bullet + OTE + Trigger!")

// Tier 1 alerts (most important)
alertcondition(tier1Bull, title="ğŸ† Tier 1 Long", message="ğŸ† TIER 1 LONG SETUP on {{ticker}} - Maximum confluence!")
alertcondition(tier1Bear, title="ğŸ† Tier 1 Short", message="ğŸ† TIER 1 SHORT SETUP on {{ticker}} - Maximum confluence!")

// 2022 Model alerts
alertcondition(model2022Bull, title="ğŸ“š 2022 Model Long", message="ğŸ“š 2022 MODEL LONG on {{ticker}} - Sweep + Displacement + FVG")
alertcondition(model2022Bear, title="ğŸ“š 2022 Model Short", message="ğŸ“š 2022 MODEL SHORT on {{ticker}} - Sweep + Displacement + FVG")

// Unicorn Model alerts (high conviction)
alertcondition(unicornBull, title="ğŸ¦„ Unicorn Long", message="ğŸ¦„ UNICORN SETUP LONG on {{ticker}} - Breaker + FVG confluence!")
alertcondition(unicornBear, title="ğŸ¦„ Unicorn Short", message="ğŸ¦„ UNICORN SETUP SHORT on {{ticker}} - Breaker + FVG confluence!")

// MMXM alerts
alertcondition(mmxmBullConfirm, title="ğŸ“Š MMXM Long", message="ğŸ“Š MMXM BUY MODEL on {{ticker}} - Market Maker sequence confirmed!")
alertcondition(mmxmBearConfirm, title="ğŸ“Š MMXM Short", message="ğŸ“Š MMXM SELL MODEL on {{ticker}} - Market Maker sequence confirmed!")

// AMD Fractal alerts
alertcondition(amdFractalBull, title="ğŸ”„ AMD Fractal Long", message="ğŸ”„ AMD FRACTAL LONG on {{ticker}} - Nested AMD alignment!")
alertcondition(amdFractalBear, title="ğŸ”„ AMD Fractal Short", message="ğŸ”„ AMD FRACTAL SHORT on {{ticker}} - Nested AMD alignment!")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PD ARRAY ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Suspension Block alerts (ICT's most powerful PD Array)
suspBlockBullAlert = hasSuspensionBlock and msDirection == DIR_BULL and inDiscount
suspBlockBearAlert = hasSuspensionBlock and msDirection == DIR_BEAR and inPremium
alertcondition(suspBlockBullAlert, title="â˜… Suspension Block Long", message="â˜… SUSPENSION BLOCK LONG on {{ticker}} - ICT's most powerful PD Array in discount zone!")
alertcondition(suspBlockBearAlert, title="â˜… Suspension Block Short", message="â˜… SUSPENSION BLOCK SHORT on {{ticker}} - ICT's most powerful PD Array in premium zone!")

// Volume Imbalance alerts
viLongAlert = hasVolumeImbalance and msDirection == DIR_BULL and inOTE
viShortAlert = hasVolumeImbalance and msDirection == DIR_BEAR and inOTE
alertcondition(viLongAlert, title="â—† Volume Imbalance Long", message="â—† VOLUME IMBALANCE LONG on {{ticker}} - Gap between candle bodies in OTE zone!")
alertcondition(viShortAlert, title="â—† Volume Imbalance Short", message="â—† VOLUME IMBALANCE SHORT on {{ticker}} - Gap between candle bodies in OTE zone!")

// Liquidity Void alerts
lvLongAlert = hasLiquidityVoid and msDirection == DIR_BULL
lvShortAlert = hasLiquidityVoid and msDirection == DIR_BEAR
alertcondition(lvLongAlert, title="â–¼ Liquidity Void Long", message="â–¼ LIQUIDITY VOID LONG on {{ticker}} - Large inefficiency to be filled!")
alertcondition(lvShortAlert, title="â–¼ Liquidity Void Short", message="â–¼ LIQUIDITY VOID SHORT on {{ticker}} - Large inefficiency to be filled!")

// NDOG (New Day Opening Gap) alerts
ndogActive = not na(ndogHigh) and not ndogFilled
ndogLongAlert = ndogActive and close > ndogCE and msDirection == DIR_BULL
ndogShortAlert = ndogActive and close < ndogCE and msDirection == DIR_BEAR
alertcondition(ndogLongAlert, title="â¬š NDOG Long", message="â¬š NDOG LONG on {{ticker}} - Price above New Day Opening Gap CE!")
alertcondition(ndogShortAlert, title="â¬š NDOG Short", message="â¬š NDOG SHORT on {{ticker}} - Price below New Day Opening Gap CE!")

// Combined PD Array Stack alert (multiple PD arrays aligned)
pdStackAlert = (hasSuspensionBlock ? 1 : 0) + (hasVolumeImbalance ? 1 : 0) + (hasLiquidityVoid ? 1 : 0) >= 2 and (msDirection == DIR_BULL or msDirection == DIR_BEAR)
alertcondition(pdStackAlert, title="ğŸ”¥ PD Array Stack", message="ğŸ”¥ MULTIPLE PD ARRAYS STACKED on {{ticker}} - High probability zone!")

// Suspension Block + OTE Combo (highest conviction)
suspOTECombo = hasSuspensionBlock and inOTE
alertcondition(suspOTECombo, title="ğŸ’ Suspension Block + OTE", message="ğŸ’ SUSPENSION BLOCK IN OTE on {{ticker}} - ICT's highest probability entry!")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW HIDDEN GEM ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Rejection Block alerts
rbLongAlert = hasRejectionBlock and msDirection == DIR_BULL and inDiscount
rbShortAlert = hasRejectionBlock and msDirection == DIR_BEAR and inPremium
alertcondition(rbLongAlert, title="â¬¡ Rejection Block Long", message="â¬¡ REJECTION BLOCK LONG on {{ticker}} - Wick rejection in discount zone!")
alertcondition(rbShortAlert, title="â¬¡ Rejection Block Short", message="â¬¡ REJECTION BLOCK SHORT on {{ticker}} - Wick rejection in premium zone!")

// 3-Day ORG Confluence alert
alertcondition(orgConfluenceZone, title="ğŸ“Š 3-Day ORG Confluence", message="ğŸ“Š 3-DAY ORG CONFLUENCE on {{ticker}} - Price respecting 3 days of opening range gaps!")

// Discount Sensitivity alert (high probability bounce)
alertcondition(discountSensitivity, title="ğŸ¯ Discount Sensitivity", message="ğŸ¯ DISCOUNT SENSITIVITY on {{ticker}} - 3+ confluences honoring gradient levels - Expect bounce!")

// Market Condition alerts
alertcondition(isJaggedMarket, title="âš¡ High Resistance Market", message="âš¡ HIGH RESISTANCE MARKET on {{ticker}} - Choppy conditions, reduce position size!")
alertcondition(isSmoothMarket, title="ğŸŒŠ Low Resistance Market", message="ğŸŒŠ LOW RESISTANCE MARKET on {{ticker}} - Smooth conditions, targets easier to reach!")

// Time-Based Risk alerts
alertcondition(isHighProbTime and (compositeTier == TIER_1 or compositeTier == TIER_2), title="ğŸ”¥ High Prob Time + Setup", message="ğŸ”¥ HIGH PROBABILITY TIME + SETUP on {{ticker}} - Best day/time with strong confluence!")
alertcondition(isLowProbTime and compositeScore >= 60, title="âš ï¸ Low Prob Time Warning", message="âš ï¸ LOW PROB TIME on {{ticker}} - Good setup but risky time window - Consider reducing size!")

// Wick Gradient CE test alert
alertcondition(hasWickGradientCE, title="ğŸ“ Wick Gradient CE Test", message="ğŸ“ WICK GRADIENT CE on {{ticker}} - Price testing ICT's notepad level!")

// Tuesday PRIME + Strong Setup (best combination)
tuesdayPrimeSetup = isTuesday and nyHour >= 8 and nyHour < 11 and (hasSuspensionBlock or hasModel2022)
alertcondition(tuesdayPrimeSetup, title="ğŸ† Tuesday PRIME Setup", message="ğŸ† TUESDAY PRIME SETUP on {{ticker}} - Best day + best setup = Maximum conviction!")

// London Close alerts
alertcondition(lcReversal and dolDirection == DIR_BULL, title="ğŸ‡¬ğŸ‡§ LC Reversal Long", message="ğŸ‡¬ğŸ‡§ LONDON CLOSE REVERSAL LONG on {{ticker}} - Post-manipulation bullish setup!")
alertcondition(lcReversal and dolDirection == DIR_BEAR, title="ğŸ‡¬ğŸ‡§ LC Reversal Short", message="ğŸ‡¬ğŸ‡§ LONDON CLOSE REVERSAL SHORT on {{ticker}} - Post-manipulation bearish setup!")

// External data plots removed to reduce plot count - data available via alerts/webhooks

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸŒ™ TRUE DAY VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line trueDayOpenLine = na
var label trueDayOpenLabel = na

if i_showTrueDayOpen and barstate.islast and not na(trueDayOpen) and not i_cleanMode
    if not na(trueDayOpenLine)
        line.delete(trueDayOpenLine)
    if not na(trueDayOpenLabel)
        label.delete(trueDayOpenLabel)

    trueDayOpenLine := line.new(bar_index - 50, trueDayOpen, bar_index + 10, trueDayOpen,
         color=color.new(#9C27B0, 40), width=1, style=line.style_dashed)
    trueDayOpenLabel := label.new(bar_index + 10, trueDayOpen, "TD Open",
         style=label.style_none, textcolor=color.new(#9C27B0, 20), size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ‡¬ğŸ‡§ LONDON CLOSE VISUALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bgcolor(i_showLondonClose and inLondonClose and not i_cleanMode ? color.new(#FF6F00, 95) : na, title="London Close")

plotshape(i_showLondonClose and lcReversal and not i_cleanMode, title="LC Reversal",
     style=shape.diamond, location=location.abovebar, color=color.new(#FF6F00, 0),
     text="LC", textcolor=color.white, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¡ WEBHOOK ALERTS (JSON Format)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

webhookPayload = '{"ticker":"' + syminfo.ticker + '",' +
                 '"tier":' + str.tostring(compositeTier) + ',' +
                 '"pattern":"' + patternName + '",' +
                 '"direction":"' + (dolDirection == DIR_BULL ? "LONG" : dolDirection == DIR_BEAR ? "SHORT" : "NEUTRAL") + '",' +
                 '"confluence":' + str.tostring(confluenceCount) + ',' +
                 '"session":"' + (inSilverBullet ? "SILVER_BULLET" : nyAMKZ ? "NY_AM_KZ" : londonKZ ? "LONDON_KZ" : "NONE") + '"}'

// Webhook alert - use alert() for dynamic messages
if newSetupGenerated and i_enableWebhook
    alert(webhookPayload, alert.freq_once_per_bar)

// Static alertcondition for TradingView alerts
alertcondition(newSetupGenerated, title="ğŸ“¡ New Setup Generated", message="ATLAS ICT Pro: New trading setup detected")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END OF ATLAS ICT PRO v5.0 - GOD MODE [PAC-MAN EDITION]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Total ICT Concepts Integrated from The Cortex:
// 1. Market Structure (BOS/CHoCH) - 8,016 mentions
// 2. Liquidity (BSL/SSL/EQH/EQL) - 7,892 mentions
// 3. Premium/Discount Zones - 6,234 mentions
// 4. Order Blocks with Lifecycle - 5,891 mentions
// 5. Fair Value Gaps (FVG/IFVG) - 4,567 mentions
// 6. OTE Zone (62-79%) - 4,123 mentions
// 7. Killzones - 3,892 mentions
// 8. Silver Bullet Windows (FULL HOUR + Phase) - 3,456 mentions
// 9. Power of Three (AMD) - 3,234 mentions
// 10. 2022 Model - 2,891 mentions
// 11. Turtle Soup - 2,567 mentions
// 12. Judas Swing - 2,345 mentions
// 13. Displacement - 2,123 mentions
// 14. IPDA Data Ranges - 1,892 mentions
// 15. Midnight Open/True Day - 1,678 mentions
// 16. CBDR - 1,456 mentions
// 17. NWOG - 1,234 mentions
// 18. HTF Bias Alignment - Custom weight
// 19. Composite Scoring (Tier 1/2/3) - Custom system
//
// NEW PD ARRAYS (v5.0):
// 20. Suspension Block - ICT's MOST POWERFUL PD Array (VI at BOTH ends)
// 21. Volume Imbalance (VI) - Gap between consecutive candle bodies
// 22. Liquidity Void - Large displacement gap with no overlapping wicks
// 23. NDOG (New Day Opening Gap) - Gap from midnight
// 24. ORG (Opening Range Gap) - First session gap
// 25. Rejection Block - Long wick rejection zones (different from OB!)
//
// HIDDEN GEMS (v5.1 - From ICT Cortex Deep Dive):
// 26. High/Low Resistance Liquidity Run Detection - Market condition classifier
// 27. Wick Gradient Levels - ICT's notepad system (0/25/50/75/100% on wicks)
// 28. 3-Day ORG Confluence - ICT's lookback system for opening gaps
// 29. Time-Based Risk Adjustment - ICT's weekly rhythm (Tuesday PRIME, Wed 11am avoid)
// 30. Discount Sensitivity - 3+ confluences honoring gradient levels
//
// HIDDEN GEM COMBOS (21-27):
// 21. Rejection Block + OTE: +5 points
// 22. Rejection Block + FVG: +4 points
// 23. 3-Day ORG Confluence: +6 points
// 24. Discount Sensitivity: +7 points
// 25. Low Resistance Run: +5 points
// 26. Wick Gradient CE Test: +4 points
// 27. High Prob Time + Strong Setup: +6 points
//
// HIDDEN GEM COMBOS (28-35) - From Cortex Deep Dive:
// 28. Immediate Rebalance Pattern: +8 points (ICT: "very strong reaction")
// 29. Market Maker Model Alignment: +5 points (9/18 EMA model alignment)
// 30. Young Swing + Strong Setup: +4 points (1-3 day swings = more room)
// 31. Mature Swing Warning: -3 points PENALTY (5+ day swings = reversal risk)
// 32. Longest Wick CE Test: +5 points (ICT's special level)
// 33. Longest Wick CE + Direction: +3 points (CE direction alignment)
// 34. IOF Drill Entry: +6 points (partial FVG fill entry)
// 35. IOF Drill + OTE + Killzone: +4 points (maximum precision)
//
// HIDDEN GEM FEATURES (v5.2):
// - Immediate Rebalance Pattern - Gap â†’ Sweep â†’ Reverse pattern
// - Market Maker Buy/Sell Model - 9/18 EMA state for bias
// - Power of Three Maturity - Young vs Mature swing classification
// - Longest Wick CE - Find THE longest wick, use ONLY its CE
// - IOF Drill Entry - Partial (50%) FVG fill entry
//
// DOL PATH PULLBACK PRIORITIES:
// 0. Suspension Block (â˜…) - Bright Green
// 1. Fair Value Gap (â—ˆ) - Purple
// 2. Volume Imbalance (â—†) - Magenta
// 3. Order Block (â– ) - Blue
// 4. Liquidity Void (â–¼) - Red
// 5. Liquidity Sweep (â—‡) - Orange
// 6. Rejection Block (â—) - Amber (ICT Hidden Gem)
// 7. Longest Wick CE (âŠ•) - Teal (ICT Hidden Gem)
// 8. Wick Gradient CE (âŠ™) - Light Purple (ICT Notepad)
// 9. Equilibrium (â—¦) - Default
// 10. OTE Zone (â—‹) - Default
//
// PAC-MAN THEME ELEMENTS:
// ğŸŸ¡ PAC-MAN = Current price position
// ğŸ‘» GHOSTS = Institutional liquidity targets (BSL/SSL)
// âš« PELLETS = Equal Highs/Lows (small liquidity)
// ğŸŒ€ SPAWN ZONE = OTE retracement area
// ğŸ¯ MAZE PATH = DOL direction arrow
// ğŸ BONUS = NWOG zones
// ğŸ† TIER MEDALS = Composite confluence signals
// â˜… SUSPENSION BLOCK = Highest priority pullback target
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
