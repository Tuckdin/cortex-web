// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ATLAS Trading - God Mode v5.0
// CORTEX-POWERED: All ICT concepts derived from 20,833 knowledge chunks from 672 transcripts

//@version=5
indicator("ATLAS ICT Pro v5.0 - GOD MODE [PAC-MAN EDITION]", overlay=true, max_lines_count=500, max_boxes_count=500, max_labels_count=500)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ® PAC-MAN GOD MODE - THE CORTEX KNOWS ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This indicator uses ALL ICT concepts from The Cortex (672 transcripts) to
// determine the most probable Draw on Liquidity (DOL) path.
//
// PAC-MAN TERMINOLOGY:
// ğŸŸ¡ PAC-MAN = Price Action (you are the trader following the path)
// ğŸ‘» GHOSTS = Institutional Players / Smart Money hunting stops
// âš« PELLET = Small liquidity (BSL/SSL - equal highs/lows)
// ğŸ”´ POWER PELLET = Major liquidity (EQH/EQL clusters, swing points)
// ğŸ’ CHERRY = PWH/PWL (Previous Week High/Low)
// ğŸŒ€ SPAWN ZONE = OTE Retracement (62-79% fib zone)
// ğŸš‡ TUNNEL = FVG (Fair Value Gap - imbalance to fill)
// ğŸ BONUS = NWOG CE (New Week Opening Gap Consequent Encroachment)
// ğŸšª EXIT = CBDR Standard Deviation projections
// ğŸ¯ MAZE PATH = Draw on Liquidity direction
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                           USER INPUTS                                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GOD MODE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_god = "ğŸ® GOD MODE (DOL Engine)"
i_showDOL = input.bool(true, "Show DOL Path (Pac-Man Maze)", group=grp_god)
i_showDOLTable = input.bool(true, "Show DOL Probability Dashboard", group=grp_god)
i_showPacMan = input.bool(true, "Show Pac-Man Visuals", group=grp_god)
i_dolSensitivity = input.string("Medium", "DOL Sensitivity", options=["Low", "Medium", "High"], group=grp_god)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF BIAS SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_htf = "ğŸ“Š HTF BIAS"
i_htfBias = input.bool(true, "Enable HTF Bias Filter", group=grp_htf)
i_htfTimeframe = input.timeframe("240", "HTF Timeframe", group=grp_htf)
i_htfLookback = input.int(20, "HTF Swing Lookback", minval=5, maxval=50, group=grp_htf)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TURTLE SOUP SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ts = "ğŸ¢ TURTLE SOUP"
i_showTurtleSoup = input.bool(true, "Show Turtle Soup Setups", group=grp_ts)
i_tsLookback = input.int(20, "Turtle Soup Lookback", minval=5, maxval=100, group=grp_ts)
i_tsBuffer = input.float(0.0, "Turtle Soup Buffer (ticks)", minval=0, group=grp_ts)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JUDAS SWING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_judas = "ğŸ­ JUDAS SWING"
i_showJudas = input.bool(true, "Show Judas Swing", group=grp_judas)
i_judasSession = input.session("0200-0500", "Judas Session (NY Time)", group=grp_judas)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORDER BLOCK SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ob = "ğŸ“¦ ORDER BLOCKS"
i_showOB = input.bool(true, "Show Order Blocks", group=grp_ob)
i_obLookback = input.int(50, "OB Lookback", minval=10, maxval=200, group=grp_ob)
i_obMitigation = input.string("Wick", "OB Mitigation Type", options=["Wick", "Close", "Avg"], group=grp_ob)
i_obMaxAge = input.int(100, "Max OB Age (bars)", minval=10, maxval=500, group=grp_ob)
i_obShowLifecycle = input.bool(true, "Show OB Lifecycle Labels", group=grp_ob)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FVG/IFVG SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_fvg = "âš¡ FVG / IFVG"
i_showFVG = input.bool(true, "Show Fair Value Gaps", group=grp_fvg)
i_showIFVG = input.bool(true, "Show Inverse FVG (IFVG)", group=grp_fvg)
i_fvgMitigation = input.string("50%", "FVG Mitigation Level", options=["25%", "50%", "75%", "100%"], group=grp_fvg)
i_fvgMinSize = input.float(0.0, "Min FVG Size (ticks)", minval=0, group=grp_fvg)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BREAKER / MITIGATION / REJECTION BLOCKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_blocks = "ğŸ§± BREAKER / MIT / REJ BLOCKS"
i_showBreaker = input.bool(true, "Show Breaker Blocks", group=grp_blocks)
i_showMitBlock = input.bool(true, "Show Mitigation Blocks", group=grp_blocks)
i_showRejBlock = input.bool(true, "Show Rejection Blocks", group=grp_blocks)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_liq = "ğŸ’§ LIQUIDITY"
i_showBSL = input.bool(true, "Show Buy Side Liquidity (BSL)", group=grp_liq)
i_showSSL = input.bool(true, "Show Sell Side Liquidity (SSL)", group=grp_liq)
i_showEQH = input.bool(true, "Show Equal Highs", group=grp_liq)
i_showEQL = input.bool(true, "Show Equal Lows", group=grp_liq)
i_eqThreshold = input.float(0.1, "Equal H/L Threshold %", minval=0.01, maxval=1.0, group=grp_liq)
i_liqLookback = input.int(50, "Liquidity Lookback", minval=10, maxval=200, group=grp_liq)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IPDA LOOKBACK SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ipda = "ğŸ“ˆ IPDA DATA RANGES"
i_showIPDA = input.bool(true, "Show IPDA Levels", group=grp_ipda)
i_ipda20 = input.bool(true, "20-Day IPDA", group=grp_ipda)
i_ipda40 = input.bool(true, "40-Day IPDA", group=grp_ipda)
i_ipda60 = input.bool(true, "60-Day IPDA", group=grp_ipda)
i_showPWHL = input.bool(true, "Show Previous Week H/L", group=grp_ipda)
i_showPMHL = input.bool(true, "Show Previous Month H/L", group=grp_ipda)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CBDR SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_cbdr = "ğŸ¦ CBDR (Central Bank Dealers Range)"
i_showCBDR = input.bool(true, "Show CBDR", group=grp_cbdr)
i_cbdrSession = input.session("1400-2000", "CBDR Session (NY Time)", group=grp_cbdr)
i_cbdrSD = input.float(2.5, "CBDR SD Multiplier", minval=0.5, maxval=5.0, step=0.5, group=grp_cbdr)
i_showCBDRProjections = input.bool(true, "Show SD Projections", group=grp_cbdr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NWOG SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_nwog = "ğŸ“… NWOG (New Week Opening Gap)"
i_showNWOG = input.bool(true, "Show NWOG", group=grp_nwog)
i_showNWOGCE = input.bool(true, "Show NWOG Consequent Encroachment", group=grp_nwog)
i_nwogWeeks = input.int(5, "Number of Weeks to Show", minval=1, maxval=10, group=grp_nwog)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKET STRUCTURE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_ms = "ğŸ“ MARKET STRUCTURE"
i_showMS = input.bool(true, "Show Market Structure", group=grp_ms)
i_showBOS = input.bool(true, "Show BOS (Break of Structure)", group=grp_ms)
i_showCHoCH = input.bool(true, "Show CHoCH (Change of Character)", group=grp_ms)
i_msLookback = input.int(20, "MS Swing Lookback", minval=5, maxval=50, group=grp_ms)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM/DISCOUNT SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_pd = "âš–ï¸ PREMIUM / DISCOUNT"
i_showPDZones = input.bool(true, "Show Premium/Discount Zones", group=grp_pd)
i_showEQ = input.bool(true, "Show Equilibrium", group=grp_pd)
i_showOTE = input.bool(true, "Show OTE Zone (62-79%)", group=grp_pd)
i_pdLookback = input.int(50, "PD Range Lookback", minval=10, maxval=200, group=grp_pd)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// POWER OF THREE SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_po3 = "ğŸ”º POWER OF THREE (AMD)"
i_showPO3 = input.bool(true, "Show Power of Three", group=grp_po3)
i_showPO3Labels = input.bool(true, "Show AMD Phase Labels", group=grp_po3)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2022 MODEL SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_2022 = "ğŸ“š 2022 MODEL"
i_show2022 = input.bool(true, "Show 2022 Model Setups", group=grp_2022)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_sess = "â° SESSIONS & KILLZONES"
i_showSessions = input.bool(true, "Show Session Backgrounds", group=grp_sess)
i_showKillzones = input.bool(true, "Highlight Killzones", group=grp_sess)
i_showSilverBullet = input.bool(true, "Show Silver Bullet Windows", group=grp_sess)
i_showMacro = input.bool(true, "Show Macro Times (:50/:10)", group=grp_sess)
i_showMidnight = input.bool(true, "Show Midnight Open", group=grp_sess)
i_timezone = input.string("America/New_York", "Timezone", options=["America/New_York", "America/Chicago", "Europe/London", "Asia/Tokyo"], group=grp_sess)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE SCORING SETTINGS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_comp = "ğŸ† COMPOSITE SCORING (5-Tier System)"
i_showComposite = input.bool(true, "Show Composite Signals", group=grp_comp)
i_tier1Threshold = input.int(90, "Tier 1 ELITE (90%+)", minval=85, maxval=100, group=grp_comp)
i_tier2Threshold = input.int(80, "Tier 2 PREMIUM (80%+)", minval=70, maxval=90, group=grp_comp)
i_tier3Threshold = input.int(65, "Tier 3 STRONG (65%+)", minval=55, maxval=80, group=grp_comp)
i_tier4Threshold = input.int(50, "Tier 4 MODERATE (50%+)", minval=40, maxval=65, group=grp_comp)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COLORS (Refined Retro-Arcade Palette)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_colors = "ğŸ¨ COLORS"
i_bullColor = input.color(color.new(#00E676, 0), "Bullish Color", group=grp_colors)  // Neon green
i_bearColor = input.color(color.new(#FF1744, 0), "Bearish Color", group=grp_colors)  // Hot pink-red
i_neutralColor = input.color(color.new(#FFD740, 0), "Neutral Color", group=grp_colors)  // Warm yellow
i_obColor = input.color(color.new(#448AFF, 20), "Order Block Color", group=grp_colors)  // Electric blue
i_fvgColor = input.color(color.new(#7C4DFF, 30), "FVG Color", group=grp_colors)  // Purple
i_liqColor = input.color(color.new(#FF9100, 0), "Liquidity Color", group=grp_colors)  // Orange
i_pacmanColor = input.color(color.new(#FFEB3B, 0), "Pac-Man Color", group=grp_colors)  // Classic yellow

// Visual Style Settings
grp_style = "ğŸ¨ VISUAL STYLE"
i_tableStyle = input.string("Minimal", "Dashboard Style", options=["Minimal", "Classic", "Compact"], group=grp_style)
i_boxTransparency = input.int(88, "Zone Box Transparency", minval=70, maxval=95, group=grp_style)
i_labelStyle = input.string("Clean", "Label Style", options=["Clean", "Badge", "Minimal"], group=grp_style)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        CONSTANTS & ENUMS                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Order Block Lifecycle States
OB_FRESH = 0
OB_PROPULSION = 1
OB_TESTED = 2
OB_MITIGATED = 3
OB_VIOLATED = 4

// Direction
DIR_BULL = 1
DIR_BEAR = -1
DIR_NEUTRAL = 0

// Composite Tiers (5-Tier System)
TIER_1 = 1  // ELITE: 90%+ - Highest probability setups
TIER_2 = 2  // PREMIUM: 80-89% - Very strong setups
TIER_3 = 3  // STRONG: 65-79% - Good setups
TIER_4 = 4  // MODERATE: 50-64% - Developing setups
TIER_5 = 5  // WEAK: Below 50% - Low probability

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        TYPE DEFINITIONS                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Order Block Type
type OrderBlock
    float top
    float bottom
    int startBar
    int direction  // 1 = bullish, -1 = bearish
    int state      // OB_FRESH, OB_PROPULSION, etc.
    bool isBreaker
    box visual
    label stateLabel

// FVG Type
type FVG
    float top
    float bottom
    int startBar
    int direction
    bool mitigated
    float mitLevel
    box visual

// Liquidity Level Type
type LiqLevel
    float level
    int bar
    int touches
    bool swept
    string liqType  // "EQH", "EQL", "SH", "SL"
    line visual

// Swing Point Type
type SwingPoint
    float price
    int bar
    int direction

// Volume Imbalance Type (VI)
type VolumeImbalance
    float top
    float bottom
    int startBar
    int direction  // 1 = bullish (gap up), -1 = bearish (gap down)
    bool filled
    box visual

// Suspension Block Type (Single candle with VI at both ends)
type SuspensionBlock
    float top        // Volume Imbalance HIGH
    float bottom     // Volume Imbalance LOW
    float bodyHigh   // Candle body high
    float bodyLow    // Candle body low
    int startBar
    int direction    // 1 = bullish (up close), -1 = bearish (down close)
    bool mitigated
    bool inverted    // Becomes inversion when traded through
    box visual
    label nameLabel

// Liquidity Void Type (Large single candle with no overlapping wicks)
type LiquidityVoid
    float top
    float bottom
    int startBar
    int direction
    bool filled
    box visual

// Opening Gap Type (NDOG, ORG, etc.)
type OpeningGap
    float top
    float bottom
    int startBar
    string gapType   // "NDOG", "ORG", "NWOG"
    bool filled
    box visual

// Rejection Block Type (Different from Order Block - single candle close rejection)
type RejectionBlock
    float level      // The closing price that gets rejected
    float wickHigh   // Wick high for context
    float wickLow    // Wick low for context
    int startBar
    int direction    // 1 = bullish rejection (down close rejected), -1 = bearish
    bool mitigated
    box visual
    label nameLabel

// Wick Gradient Type (ICT's notepad system - 0/25/50/75/100% levels on wicks)
type WickGradient
    float wick100    // Full wick extent
    float wick75     // 75% level
    float wick50     // Consequent encroachment (midpoint)
    float wick25     // 25% level
    float wick0      // Wick base
    int startBar
    int direction    // 1 = premium wick (high), -1 = discount wick (low)
    bool active
    line line100
    line line75
    line line50
    line line25
    line line0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        GLOBAL VARIABLES                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Arrays for Order Blocks
var array<OrderBlock> bullOBs = array.new<OrderBlock>()
var array<OrderBlock> bearOBs = array.new<OrderBlock>()

// Arrays for FVGs
var array<FVG> bullFVGs = array.new<FVG>()
var array<FVG> bearFVGs = array.new<FVG>()

// Arrays for Liquidity
var array<LiqLevel> bslLevels = array.new<LiqLevel>()
var array<LiqLevel> sslLevels = array.new<LiqLevel>()

// Swing Points
var array<SwingPoint> swingHighs = array.new<SwingPoint>()
var array<SwingPoint> swingLows = array.new<SwingPoint>()

// Arrays for Volume Imbalances
var array<VolumeImbalance> bullVIs = array.new<VolumeImbalance>()
var array<VolumeImbalance> bearVIs = array.new<VolumeImbalance>()

// Arrays for Suspension Blocks
var array<SuspensionBlock> bullSuspBlocks = array.new<SuspensionBlock>()
var array<SuspensionBlock> bearSuspBlocks = array.new<SuspensionBlock>()

// Arrays for Liquidity Voids
var array<LiquidityVoid> bullLiqVoids = array.new<LiquidityVoid>()
var array<LiquidityVoid> bearLiqVoids = array.new<LiquidityVoid>()

// Arrays for Opening Gaps (NDOG, ORG)
var array<OpeningGap> openingGaps = array.new<OpeningGap>()

// NDOG (New Day Opening Gap)
var float ndogHigh = na
var float ndogLow = na
var float ndogCE = na
var bool ndogFilled = false

// ORG (Opening Range Gap) - First 5 min of session
var float orgHigh = na
var float orgLow = na
var float orgCE = na
var bool orgFilled = false
var bool orgTracking = false

// 3-Day ORG Confluence (ICT's lookback system)
var float org1DayAgo = na      // Yesterday's ORG CE
var float org2DaysAgo = na     // 2 days ago ORG CE
var float org3DaysAgo = na     // 3 days ago ORG CE
var int orgDayCount = 0

// Arrays for Rejection Blocks
var array<RejectionBlock> bullRejBlocks = array.new<RejectionBlock>()
var array<RejectionBlock> bearRejBlocks = array.new<RejectionBlock>()

// Arrays for Wick Gradients (ICT's notepad levels)
var array<WickGradient> premiumWicks = array.new<WickGradient>()
var array<WickGradient> discountWicks = array.new<WickGradient>()

// High/Low Resistance Liquidity Run Detection
var string liqRunType = "NEUTRAL"       // "HIGH_RESISTANCE", "LOW_RESISTANCE", "NEUTRAL"
var float liqRunScore = 0.0             // 0-100 score for resistance level
var int consolidationBars = 0           // Bars spent in consolidation
var int reversalCount = 0               // Number of reversals in lookback
var float avgMoveSize = 0.0             // Average move size for comparison
var bool isJaggedMarket = false         // High resistance = jagged price action
var bool isSmoothMarket = false         // Low resistance = smooth price action

// Time-Based Risk Adjustment (ICT's weekly rhythm)
var float timeRiskMultiplier = 1.0      // Adjusts based on day/time
var string timeRiskReason = ""          // Why risk is adjusted
var bool isHighProbTime = false         // Mon 9-11, Tue 8:30-11
var bool isLowProbTime = false          // Wed 11am+, Thu PM, Fri PM

// Discount Sensitivity Detection
var bool discountSensitivity = false    // When 3+ confluences honor gradient levels
var int sensitivityCount = 0            // Number of confluences present
var float sensitivityLevel = na         // The level being tested

// Immediate Rebalance Pattern Detection
// ICT: "Next day we open and trade back down... offering an immediate rebalance"
var bool immediateRebalanceBull = false
var bool immediateRebalanceBear = false
var float rebalanceLevel = na
var int rebalanceBar = 0

// Market Maker Buy/Sell Model (9/18 EMA)
// ICT: "Market makers will generally price markets lower to buy into that drop"
var string mmModel = "NEUTRAL"          // "BUY_MODEL", "SELL_MODEL", "NEUTRAL"
var bool mmModelBullish = false         // 9 < 18 = Buy Model active
var bool mmModelBearish = false         // 9 > 18 = Sell Model active

// Power of Three Maturity (Young vs Mature Swings)
// ICT: "Daily swings are maturing into key support resistance"
var int swingHighAge = 0                // Days since swing high formed
var int swingLowAge = 0                 // Days since swing low formed
var bool matureSwingHigh = false        // 5+ days = mature
var bool matureSwingLow = false
var bool youngSwingHigh = false         // 1-3 days = young
var bool youngSwingLow = false

// Longest Wick CE Detection
// ICT: "Consequent encroachment of the longest wick... that's the one that matters"
var float longestWickCE = na            // CE of the longest wick in lookback
var float longestWickHigh = na
var float longestWickLow = na
var int longestWickBar = 0
var int longestWickDirection = 0        // 1 = upper wick, -1 = lower wick

// Institutional Order Flow Drill Entry
// ICT: "Entry into a partial fair value gap"
var bool iofDrillLong = false
var bool iofDrillShort = false
var float iofEntryLevel = na

// Market Structure
var int msDirection = 0
var float lastSwingHigh = na
var float lastSwingLow = na
var int lastSwingHighBar = 0
var int lastSwingLowBar = 0
var bool bosDetected = false
var bool chochDetected = false

// HTF Bias
var int htfBias = 0
var bool htfBullValid = false
var bool htfBearValid = false

// CBDR
var float cbdrHigh = na
var float cbdrLow = na
var float cbdrRange = na
var bool inCBDR = false

// NWOG - Arrays for multiple weeks
var float[] nwogHighs = array.new_float(0)
var float[] nwogLows = array.new_float(0)
var float[] nwogCEs = array.new_float(0)
var bool newWeekStart = false
// Keep single variables for backward compatibility with confluence
var float nwogHigh = na
var float nwogLow = na
var float nwogCE = na

// Power of Three
var string po3Phase = "ACCUMULATION"
var float accumulationHigh = na
var float accumulationLow = na

// DOL Engine
var float dolTarget = na
var int dolDirection = 0
var float dolProbability = 0.0
var string dolReason = ""

// Turtle Soup with Stalking Stages
var float recentSwingHigh = na
var float recentSwingLow = na
var bool swingHighSwept = false
var bool swingLowSwept = false
var int tsStalking = 0  // 0 = none, 1 = stalking high, -1 = stalking low
var string tsStage = "NONE"  // STALK, TRAP, CONFIRM, INVALID
var int tsStageBar = 0
var float tsEntryPrice = na

// Session tracking
var float asianHigh = na
var float asianLow = na
var float londonHigh = na
var float londonLow = na
var float nyHigh = na
var float nyLow = na
var float midnightOpen = na

// AMD (Power of 3) Engine - TRUE price-based detection
var int amdPhase = 0           // 0=None, 1=Accumulation, 2=Manipulation, 3=Distribution
var string amdStatus = ""       // Detailed status message
var bool asianHighSwept = false // Has Asian high been swept?
var bool asianLowSwept = false  // Has Asian low been swept?
var bool manipulationComplete = false  // Has Judas/manipulation finished?
var int manipDirection = 0      // Direction of manipulation: 1=swept high (fake bull), -1=swept low (fake bear)
var int expectedDirection = 0   // Expected true direction after manipulation: 1=bull, -1=bear
var float manipulationSwingHigh = na  // High of the manipulation move
var float manipulationSwingLow = na   // Low of the manipulation move
var bool distributionStarted = false  // Has true move begun?
var float amdEntryZoneTop = na  // Optimal entry zone after manipulation
var float amdEntryZoneBottom = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SEQUENCING - Multi-target DOL tracking
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Previous Day High/Low
var float pdh = na
var float pdl = na
var bool pdhSwept = false
var bool pdlSwept = false
var int pdhSweptBar = na
var int pdlSweptBar = na

// Previous Week High/Low
var float pwh = na
var float pwl = na
var bool pwhSwept = false
var bool pwlSwept = false

// Session liquidity sweep tracking
var bool londonHighSwept = false
var bool londonLowSwept = false
var bool nyHighSwept = false
var bool nyLowSwept = false

// Day/Week tracking
var int currentDay = na
var int currentWeek = na
var float dayHigh = na
var float dayLow = na
var float weekHigh = na
var float weekLow = na

// Composite Score
var float compositeScore = 0.0
var int compositeTier = 0
var string patternName = ""

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        HELPER FUNCTIONS                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if in session
f_inSession(string sess) =>
    not na(time(timeframe.period, sess, i_timezone))

// Get current NY hour
f_nyHour() =>
    hour(time, i_timezone)

// Get current NY minute
f_nyMinute() =>
    minute(time, i_timezone)

// Calculate tick size
f_tickSize() =>
    syminfo.mintick

// Check if price is in range
f_inRange(float price, float top, float bottom) =>
    price >= bottom and price <= top

// Get mitigation percentage value
f_getMitPct() =>
    i_fvgMitigation == "25%" ? 0.25 : i_fvgMitigation == "50%" ? 0.50 : i_fvgMitigation == "75%" ? 0.75 : 1.0

// Clean old visuals from array
f_cleanOldOBs(array<OrderBlock> obs, int maxAge) =>
    if array.size(obs) > 0
        for i = array.size(obs) - 1 to 0
            ob = array.get(obs, i)
            if bar_index - ob.startBar > maxAge or ob.state == OB_VIOLATED
                if not na(ob.visual)
                    box.delete(ob.visual)
                if not na(ob.stateLabel)
                    label.delete(ob.stateLabel)
                array.remove(obs, i)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SESSION DETECTION                                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

nyHour = f_nyHour()
nyMinute = f_nyMinute()

// Session definitions (NY Time)
asianSession = nyHour >= 20 or nyHour < 0
londonSession = nyHour >= 2 and nyHour < 5
londonOpen = nyHour >= 3 and nyHour < 4
nyAMSession = nyHour >= 9 and nyHour < 12
nyPMSession = nyHour >= 13 and nyHour < 16
nyAMOpen = nyHour >= 9 and nyHour < 10

// Killzones
asianKZ = nyHour >= 20 or nyHour < 0
londonKZ = nyHour >= 2 and nyHour < 5
nyAMKZ = nyHour >= 9 and nyHour < 11
nyPMKZ = nyHour >= 13 and nyHour < 15

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SILVER BULLET WINDOWS - Full hour windows per ICT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// London Silver Bullet: 3:00-4:00 AM NY
sb1 = nyHour == 3
// NY AM Silver Bullet: 10:00-11:00 AM NY
sb2 = nyHour == 10
// NY PM Silver Bullet: 2:00-3:00 PM NY
sb3 = nyHour == 14
inSilverBullet = sb1 or sb2 or sb3

// Silver Bullet Phase (for timing entries)
sbPhase = inSilverBullet ? (nyMinute < 20 ? "EARLY" : nyMinute < 40 ? "PRIME" : "LATE") : ""
sbPrime = inSilverBullet and nyMinute >= 10 and nyMinute <= 40  // Best window within SB

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MACRO TIMES - ICT's time-based edge
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// :00 Top of Hour - Major liquidity events
macroTopOfHour = nyMinute >= 58 or nyMinute <= 2
// :30 Mid Hour - Secondary liquidity
macroMidHour = nyMinute >= 28 and nyMinute <= 32
// :50 Pre-Hour - Reversal window (last 10 min before hour)
macroPreHour = nyMinute >= 50 and nyMinute <= 57

isMacroTime = macroTopOfHour or macroMidHour or macroPreHour
macroType = macroTopOfHour ? ":00" : macroMidHour ? ":30" : macroPreHour ? ":50" : ""

// Power Hour windows (high volatility)
isPowerHour = (nyHour == 9 and nyMinute >= 30) or (nyHour == 10 and nyMinute < 30) or  // NY Open
              (nyHour == 15 and nyMinute >= 0 and nyMinute < 30)  // Last 30 min

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEEK & DESTROY DAYS - Wed/Thu often reverse
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
dayOfWeek = dayofweek(time, i_timezone)
isSeekDestroyDay = dayOfWeek == dayofweek.wednesday or dayOfWeek == dayofweek.thursday
isAccumulationDay = dayOfWeek == dayofweek.monday or dayOfWeek == dayofweek.tuesday
isExpansionDay = dayOfWeek == dayofweek.friday

// Midnight detection
isMidnight = nyHour == 0 and nyMinute == 0

// CBDR Session
inCBDRSession = f_inSession(i_cbdrSession)

// Judas Session
inJudasSession = f_inSession(i_judasSession)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   LIQUIDITY LEVELS - PDH/PDL/PWH/PWL                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect new day (using NY timezone)
newDay = dayofweek(time, i_timezone) != dayofweek(time[1], i_timezone)
newWeek = weekofyear(time, i_timezone) != weekofyear(time[1], i_timezone)

// Track daily high/low and update PDH/PDL on new day
if newDay
    // Store yesterday's range as PDH/PDL
    pdh := dayHigh
    pdl := dayLow
    // Reset sweep flags for new day
    pdhSwept := false
    pdlSwept := false
    pdhSweptBar := na
    pdlSweptBar := na
    londonHighSwept := false
    londonLowSwept := false
    nyHighSwept := false
    nyLowSwept := false
    // Reset today's tracking
    dayHigh := high
    dayLow := low
else
    // Update today's high/low
    dayHigh := math.max(nz(dayHigh, high), high)
    dayLow := math.min(nz(dayLow, low), low)

// Track weekly high/low and update PWH/PWL on new week
if newWeek
    // Store last week's range as PWH/PWL
    pwh := weekHigh
    pwl := weekLow
    // Reset sweep flags for new week
    pwhSwept := false
    pwlSwept := false
    // Reset this week's tracking
    weekHigh := high
    weekLow := low
else
    // Update this week's high/low
    weekHigh := math.max(nz(weekHigh, high), high)
    weekLow := math.min(nz(weekLow, low), low)

// Track London session high/low
if londonSession
    if not londonSession[1]
        // Start of London session
        londonHigh := high
        londonLow := low
    else
        londonHigh := math.max(londonHigh, high)
        londonLow := math.min(londonLow, low)

// Track NY session high/low
if nyAMSession or nyPMSession
    if not (nyAMSession[1] or nyPMSession[1])
        // Start of NY session
        nyHigh := high
        nyLow := low
    else
        nyHigh := math.max(nyHigh, high)
        nyLow := math.min(nyLow, low)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SWEEP DETECTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// PDH/PDL sweep detection
if not pdhSwept and not na(pdh) and high > pdh
    pdhSwept := true
    pdhSweptBar := bar_index

if not pdlSwept and not na(pdl) and low < pdl
    pdlSwept := true
    pdlSweptBar := bar_index

// PWH/PWL sweep detection
if not pwhSwept and not na(pwh) and high > pwh
    pwhSwept := true

if not pwlSwept and not na(pwl) and low < pwl
    pwlSwept := true

// London session sweep detection
if not londonHighSwept and not na(londonHigh) and high > londonHigh and not londonSession
    londonHighSwept := true

if not londonLowSwept and not na(londonLow) and low < londonLow and not londonSession
    londonLowSwept := true

// NY session sweep detection
if not nyHighSwept and not na(nyHigh) and high > nyHigh and not (nyAMSession or nyPMSession)
    nyHighSwept := true

if not nyLowSwept and not na(nyLow) and low < nyLow and not (nyAMSession or nyPMSession)
    nyLowSwept := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SWING POINT DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect swing highs and lows using pivot
pivotHigh = ta.pivothigh(high, i_msLookback, i_msLookback)
pivotLow = ta.pivotlow(low, i_msLookback, i_msLookback)

isSwingHigh = not na(pivotHigh)
isSwingLow = not na(pivotLow)

// Update swing tracking
if isSwingHigh
    lastSwingHigh := pivotHigh
    lastSwingHighBar := bar_index - i_msLookback
    swingHighSwept := false
    newSH = SwingPoint.new(pivotHigh, bar_index - i_msLookback, DIR_BULL)
    if array.size(swingHighs) >= 20
        array.shift(swingHighs)
    array.push(swingHighs, newSH)

if isSwingLow
    lastSwingLow := pivotLow
    lastSwingLowBar := bar_index - i_msLookback
    swingLowSwept := false
    newSL = SwingPoint.new(pivotLow, bar_index - i_msLookback, DIR_BEAR)
    if array.size(swingLows) >= 20
        array.shift(swingLows)
    array.push(swingLows, newSL)

// Turtle Soup swing tracking
high20 = ta.highest(high, i_tsLookback)
low20 = ta.lowest(low, i_tsLookback)

recentSwingHigh := high20
recentSwingLow := low20

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        HTF BIAS DETECTION                                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Request HTF data
[htfHigh, htfLow, htfClose] = request.security(syminfo.tickerid, i_htfTimeframe, [high, low, close])

// HTF Swing detection (simplified)
htfPivotHigh = ta.pivothigh(htfHigh, i_htfLookback, i_htfLookback)
htfPivotLow = ta.pivotlow(htfLow, i_htfLookback, i_htfLookback)

var float htfLastSwingHigh = na
var float htfLastSwingLow = na

if not na(htfPivotHigh)
    htfLastSwingHigh := htfPivotHigh

if not na(htfPivotLow)
    htfLastSwingLow := htfPivotLow

// Determine HTF Bias
htfBullValid := not na(htfLastSwingLow) and htfClose > htfLastSwingLow
htfBearValid := not na(htfLastSwingHigh) and htfClose < htfLastSwingHigh

if i_htfBias
    htfBias := htfBullValid and not htfBearValid ? DIR_BULL : htfBearValid and not htfBullValid ? DIR_BEAR : htfBias

// Check if current setup aligns with HTF
htfAllowsBull = not i_htfBias or htfBias >= 0
htfAllowsBear = not i_htfBias or htfBias <= 0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MULTI-TIMEFRAME BIAS (ICT Method)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// MTF Bias: Determine bias on each timeframe using swing structure
// Per ICT: Bias is based on swing high/low breaks (BOS) and price position

// Function to calculate bias from swing levels
f_calcBias(float swingHigh, float swingLow, float closePrice) =>
    if na(swingHigh) or na(swingLow)
        0  // Neutral if no swings
    else if closePrice > swingHigh
        1  // Bullish - above swing high
    else if closePrice < swingLow
        -1  // Bearish - below swing low
    else
        0  // Neutral - between swings

// Request data from each timeframe
[wHigh, wLow, wClose, wPivotH, wPivotL] = request.security(syminfo.tickerid, "W", [high, low, close, ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)])
[dHigh, dLow, dClose, dPivotH, dPivotL] = request.security(syminfo.tickerid, "D", [high, low, close, ta.pivothigh(high, 3, 3), ta.pivotlow(low, 3, 3)])
[h1High, h1Low, h1Close, h1PivotH, h1PivotL] = request.security(syminfo.tickerid, "60", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])
[m15High, m15Low, m15Close, m15PivotH, m15PivotL] = request.security(syminfo.tickerid, "15", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])
[m5High, m5Low, m5Close, m5PivotH, m5PivotL] = request.security(syminfo.tickerid, "5", [high, low, close, ta.pivothigh(high, 5, 5), ta.pivotlow(low, 5, 5)])

// Track swing levels for each timeframe
var float wSwingHigh = na, var float wSwingLow = na
var float dSwingHigh = na, var float dSwingLow = na
var float h1SwingHigh = na, var float h1SwingLow = na
var float m15SwingHigh = na, var float m15SwingLow = na
var float m5SwingHigh = na, var float m5SwingLow = na

// Update swing levels when new pivots form
if not na(wPivotH)
    wSwingHigh := wPivotH
if not na(wPivotL)
    wSwingLow := wPivotL
if not na(dPivotH)
    dSwingHigh := dPivotH
if not na(dPivotL)
    dSwingLow := dPivotL
if not na(h1PivotH)
    h1SwingHigh := h1PivotH
if not na(h1PivotL)
    h1SwingLow := h1PivotL
if not na(m15PivotH)
    m15SwingHigh := m15PivotH
if not na(m15PivotL)
    m15SwingLow := m15PivotL
if not na(m5PivotH)
    m5SwingHigh := m5PivotH
if not na(m5PivotL)
    m5SwingLow := m5PivotL

// Calculate bias for each timeframe
mtfBiasW = f_calcBias(wSwingHigh, wSwingLow, wClose)
mtfBiasD = f_calcBias(dSwingHigh, dSwingLow, dClose)
mtfBias1H = f_calcBias(h1SwingHigh, h1SwingLow, h1Close)
mtfBias15m = f_calcBias(m15SwingHigh, m15SwingLow, m15Close)
mtfBias5m = f_calcBias(m5SwingHigh, m5SwingLow, m5Close)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MARKET STRUCTURE (BOS/CHoCH)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bootstrap: Initialize msDirection on first valid swing comparison
// This fixes the "cold start" problem where CHoCH can't detect on chart start
var bool msInitialized = false

if not msInitialized and not na(lastSwingHigh) and not na(lastSwingLow)
    // Initialize based on current price relative to recent swings
    if close > lastSwingHigh
        msDirection := DIR_BULL
        msInitialized := true
    else if close < lastSwingLow
        msDirection := DIR_BEAR
        msInitialized := true
    else
        // Price between swings - use HTF bias if available, else use swing relationship
        if htfBias != 0
            msDirection := htfBias
            msInitialized := true
        else if lastSwingHighBar > lastSwingLowBar
            // More recent high = bullish structure forming
            msDirection := DIR_BULL
            msInitialized := true
        else if lastSwingLowBar > lastSwingHighBar
            // More recent low = bearish structure forming
            msDirection := DIR_BEAR
            msInitialized := true

// Break of Structure (continuation in current direction)
bullishBOS = close > lastSwingHigh and msDirection == DIR_BULL and not na(lastSwingHigh) and msInitialized
bearishBOS = close < lastSwingLow and msDirection == DIR_BEAR and not na(lastSwingLow) and msInitialized

// Change of Character (reversal against current direction)
bullishCHoCH = close > lastSwingHigh and msDirection == DIR_BEAR and not na(lastSwingHigh) and msInitialized
bearishCHoCH = close < lastSwingLow and msDirection == DIR_BULL and not na(lastSwingLow) and msInitialized

// First structure break when not initialized (treat as BOS to establish direction)
firstBullBreak = close > lastSwingHigh and msDirection == DIR_NEUTRAL and not na(lastSwingHigh)
firstBearBreak = close < lastSwingLow and msDirection == DIR_NEUTRAL and not na(lastSwingLow)

// Update market structure
if bullishBOS or bullishCHoCH or firstBullBreak
    msDirection := DIR_BULL
    bosDetected := bullishBOS or firstBullBreak
    chochDetected := bullishCHoCH
    msInitialized := true

if bearishBOS or bearishCHoCH or firstBearBreak
    msDirection := DIR_BEAR
    bosDetected := bearishBOS or firstBearBreak
    chochDetected := bearishCHoCH
    msInitialized := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        TURTLE SOUP DETECTION (Enhanced with Stalking)          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ATR for stalk distance calculation
atrVal = ta.atr(14)

// Turtle Soup: Failed breakout with reversal
tsBuffer = i_tsBuffer * f_tickSize()
stalkDist = atrVal * 0.5  // Distance to start stalking

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STALKING STAGES: ğŸ‘€ STALK â†’ ğŸ¯ TRAP â†’ TS CONFIRM â†’ ğŸš« INVALID
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if near swing high (stalking)
nearSwingHigh = not na(recentSwingHigh) and not swingHighSwept and high >= recentSwingHigh - stalkDist and high < recentSwingHigh

// Check if near swing low (stalking)
nearSwingLow = not na(recentSwingLow) and not swingLowSwept and low <= recentSwingLow + stalkDist and low > recentSwingLow

// STALK stage - approaching the high/low
if nearSwingHigh and tsStage != "TRAP" and tsStage != "CONFIRM"
    tsStage := "STALK_HIGH"
    tsStalking := 1
    tsStageBar := bar_index

if nearSwingLow and tsStage != "TRAP" and tsStage != "CONFIRM"
    tsStage := "STALK_LOW"
    tsStalking := -1
    tsStageBar := bar_index

// TRAP stage - price sweeps the level
if tsStalking == 1 and high > recentSwingHigh + tsBuffer
    if tsStage == "STALK_HIGH"
        tsStage := "TRAP"
        tsStageBar := bar_index

if tsStalking == -1 and low < recentSwingLow - tsBuffer
    if tsStage == "STALK_LOW"
        tsStage := "TRAP"
        tsStageBar := bar_index

// Bearish Turtle Soup CONFIRM: Sweep high, close back inside
bearishTS = i_showTurtleSoup and htfAllowsBear and not na(recentSwingHigh) and not swingHighSwept and high > recentSwingHigh + tsBuffer and close < recentSwingHigh and close < open

// Bullish Turtle Soup CONFIRM: Sweep low, close back inside
bullishTS = i_showTurtleSoup and htfAllowsBull and not na(recentSwingLow) and not swingLowSwept and low < recentSwingLow - tsBuffer and close > recentSwingLow and close > open

// CONFIRM stage
if bearishTS
    tsStage := "CONFIRM_BEAR"
    tsEntryPrice := close
    tsStalking := 1
    tsStageBar := bar_index

if bullishTS
    tsStage := "CONFIRM_BULL"
    tsEntryPrice := close
    tsStalking := -1
    tsStageBar := bar_index

// INVALID stage - if price continues in sweep direction
if tsStage == "TRAP" and tsStalking == 1
    if close > recentSwingHigh and close > open
        tsStage := "INVALID"
        tsStageBar := bar_index

if tsStage == "TRAP" and tsStalking == -1
    if close < recentSwingLow and close < open
        tsStage := "INVALID"
        tsStageBar := bar_index

// Reset after confirmation is old
if bar_index - tsStageBar > 10 and (tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" or tsStage == "INVALID")
    tsStage := "NONE"
    tsStalking := 0

// Update sweep tracking
if high > recentSwingHigh + tsBuffer
    swingHighSwept := true

if low < recentSwingLow - tsBuffer
    swingLowSwept := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        JUDAS SWING DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track Asian range for Judas reference
if asianSession
    if na(asianHigh) or nyHour == 20
        asianHigh := high
        asianLow := low
    else
        asianHigh := math.max(asianHigh, high)
        asianLow := math.min(asianLow, low)

// Judas Swing: False move during London opposite to true NY direction
bearishJudas = i_showJudas and inJudasSession and not na(asianHigh) and high > asianHigh and close < open and htfAllowsBear

bullishJudas = i_showJudas and inJudasSession and not na(asianLow) and low < asianLow and close > open and htfAllowsBull

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ORDER BLOCK DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Displacement detection (atrVal defined earlier in Turtle Soup section)
displacementUp = (close - open) > atrVal * 1.5 and close > open
displacementDown = (open - close) > atrVal * 1.5 and close < open

// Bullish OB: Last down candle before displacement up
bullishOB = close[1] < open[1] and displacementUp and close > high[1]

// Bearish OB: Last up candle before displacement down
bearishOB = close[1] > open[1] and displacementDown and close < low[1]

// ICT-style Order Block colors (blue for bullish, orange for bearish - per ICT videos)
obBullColor = #90CAF9  // Pastel blue
obBearColor = #FFAB91  // Pastel coral/orange

// Create and manage Order Blocks - ICT style with labels
if bullishOB and i_showOB
    newOB = OrderBlock.new(
         high[1], low[1], bar_index - 1, DIR_BULL, OB_FRESH, false,
         box.new(bar_index - 1, high[1], bar_index + 20, low[1],
                 border_color=obBullColor, bgcolor=color.new(obBullColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="OB", text_color=obBullColor, text_size=size.tiny, text_halign=text.align_right),
         i_obShowLifecycle ? label.new(bar_index - 1, high[1], "â—",
                                       style=label.style_none, textcolor=color.new(obBullColor, 30), size=size.tiny) : na)
    if array.size(bullOBs) >= 10
        oldOB = array.shift(bullOBs)
        if not na(oldOB.visual)
            box.delete(oldOB.visual)
        if not na(oldOB.stateLabel)
            label.delete(oldOB.stateLabel)
    array.push(bullOBs, newOB)

if bearishOB and i_showOB
    newOB = OrderBlock.new(
         high[1], low[1], bar_index - 1, DIR_BEAR, OB_FRESH, false,
         box.new(bar_index - 1, high[1], bar_index + 20, low[1],
                 border_color=obBearColor, bgcolor=color.new(obBearColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="OB", text_color=obBearColor, text_size=size.tiny, text_halign=text.align_right),
         i_obShowLifecycle ? label.new(bar_index - 1, high[1], "â—",
                                       style=label.style_none, textcolor=color.new(obBearColor, 30), size=size.tiny) : na)
    if array.size(bearOBs) >= 10
        oldOB = array.shift(bearOBs)
        if not na(oldOB.visual)
            box.delete(oldOB.visual)
        if not na(oldOB.stateLabel)
            label.delete(oldOB.stateLabel)
    array.push(bearOBs, newOB)

// ICT-style Breaker colors (orange tones - violated OBs become support/resistance)
brkBullColor = #FF9100  // Bright orange for breakers
brkBearColor = #FF6D00  // Amber orange for bearish breaker

// Update OB Lifecycle States
f_updateOBState(array<OrderBlock> obs, bool isBull) =>
    if array.size(obs) > 0
        for i = 0 to array.size(obs) - 1
            ob = array.get(obs, i)
            mitPrice = i_obMitigation == "Wick" ? (isBull ? low : high) : i_obMitigation == "Close" ? close : (high + low) / 2

            // State transitions
            if ob.state == OB_FRESH
                // Move to propulsion after price moves away
                if isBull and close > ob.top * 1.001
                    ob.state := OB_PROPULSION
                else if not isBull and close < ob.bottom * 0.999
                    ob.state := OB_PROPULSION

            else if ob.state == OB_PROPULSION
                // Test when price returns
                if isBull and mitPrice <= ob.top and mitPrice >= ob.bottom
                    ob.state := OB_TESTED
                else if not isBull and mitPrice >= ob.bottom and mitPrice <= ob.top
                    ob.state := OB_TESTED

            else if ob.state == OB_TESTED
                // Mitigated if price pushes through 50%
                midPoint = (ob.top + ob.bottom) / 2
                if isBull and mitPrice < midPoint
                    ob.state := OB_MITIGATED
                else if not isBull and mitPrice > midPoint
                    ob.state := OB_MITIGATED

            else if ob.state == OB_MITIGATED
                // Violated if price closes beyond OB - becomes Breaker
                if isBull and close < ob.bottom
                    ob.state := OB_VIOLATED
                    ob.isBreaker := true
                    // Update box to Breaker style
                    if not na(ob.visual)
                        box.set_border_color(ob.visual, brkBearColor)
                        box.set_bgcolor(ob.visual, color.new(brkBearColor, 75))
                        box.set_text(ob.visual, "BRK")
                        box.set_text_color(ob.visual, brkBearColor)
                else if not isBull and close > ob.top
                    ob.state := OB_VIOLATED
                    ob.isBreaker := true
                    // Update box to Breaker style
                    if not na(ob.visual)
                        box.set_border_color(ob.visual, brkBullColor)
                        box.set_bgcolor(ob.visual, color.new(brkBullColor, 75))
                        box.set_text(ob.visual, "BRK")
                        box.set_text_color(ob.visual, brkBullColor)

            // Update label - Clean minimal indicators
            if not na(ob.stateLabel) and i_obShowLifecycle
                stateText = ob.state == OB_FRESH ? "â—" : ob.state == OB_PROPULSION ? "â—‰" : ob.state == OB_TESTED ? "â—" : ob.state == OB_MITIGATED ? "â—‹" : ob.isBreaker ? "âŠ˜" : "âœ•"
                label.set_text(ob.stateLabel, stateText)
                label.set_x(ob.stateLabel, bar_index)

f_updateOBState(bullOBs, true)
f_updateOBState(bearOBs, false)

// Clean old OBs
f_cleanOldOBs(bullOBs, i_obMaxAge)
f_cleanOldOBs(bearOBs, i_obMaxAge)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        REJECTION BLOCK DETECTION                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Rejection Block: Long wick that rejects from a level and closes outside
// Different from OB - shows where price aggressively rejected

// Calculate wick sizes
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low
bodySize = math.abs(close - open)
totalRange = high - low

// Rejection Block thresholds
minWickRatio = 0.6  // Wick must be 60%+ of total range
minWickATR = atrVal * 0.5  // Minimum wick size

// Bullish Rejection Block: Long lower wick rejecting from discount
bullishRejBlock = lowerWick > totalRange * minWickRatio and
                  lowerWick > minWickATR and
                  close > open and
                  inDiscount

// Bearish Rejection Block: Long upper wick rejecting from premium
bearishRejBlock = upperWick > totalRange * minWickRatio and
                  upperWick > minWickATR and
                  close < open and
                  inPremium

// Store rejection block levels for reference
var float lastBullRejLevel = na
var float lastBearRejLevel = na
var int lastBullRejBar = na
var int lastBearRejBar = na

if bullishRejBlock
    lastBullRejLevel := low
    lastBullRejBar := bar_index

if bearishRejBlock
    lastBearRejLevel := high
    lastBearRejBar := bar_index

// Check if rejection block is recent and valid
hasRecentBullRej = not na(lastBullRejBar) and bar_index - lastBullRejBar <= 20
hasRecentBearRej = not na(lastBearRejBar) and bar_index - lastBearRejBar <= 20

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        FVG / IFVG DETECTION                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bullish FVG: Gap up (low > high[2])
bullishFVG = low > high[2] and close[1] > open[1]
bullishFVGTop = low
bullishFVGBottom = high[2]

// Bearish FVG: Gap down (high < low[2])
bearishFVG = high < low[2] and close[1] < open[1]
bearishFVGTop = low[2]
bearishFVGBottom = high

// Check minimum size
minFVGSize = i_fvgMinSize * f_tickSize()

// ICT-style FVG colors (gold/amber for visibility)
// ICT-style FVG colors (pink - per ICT videos)
fvgBullColor = #FFE082  // Pastel gold/amber for bullish FVG
fvgBearColor = #F48FB1  // Pastel magenta for bearish FVG

// Create FVGs - ICT style with labels
if bullishFVG and i_showFVG and (bullishFVGTop - bullishFVGBottom) >= minFVGSize
    mitPct = f_getMitPct()
    mitLevel = bullishFVGBottom + (bullishFVGTop - bullishFVGBottom) * mitPct
    newFVG = FVG.new(
         bullishFVGTop, bullishFVGBottom, bar_index, DIR_BULL, false, mitLevel,
         box.new(bar_index - 2, bullishFVGTop, bar_index + 15, bullishFVGBottom,
                 border_color=fvgBullColor, bgcolor=color.new(fvgBullColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="FVG", text_color=fvgBullColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bullFVGs) >= 15
        oldFVG = array.shift(bullFVGs)
        if not na(oldFVG.visual)
            box.delete(oldFVG.visual)
    array.push(bullFVGs, newFVG)

if bearishFVG and i_showFVG and (bearishFVGTop - bearishFVGBottom) >= minFVGSize
    mitPct = f_getMitPct()
    mitLevel = bearishFVGTop - (bearishFVGTop - bearishFVGBottom) * mitPct
    newFVG = FVG.new(
         bearishFVGTop, bearishFVGBottom, bar_index, DIR_BEAR, false, mitLevel,
         box.new(bar_index - 2, bearishFVGTop, bar_index + 15, bearishFVGBottom,
                 border_color=fvgBearColor, bgcolor=color.new(fvgBearColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="FVG", text_color=fvgBearColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bearFVGs) >= 15
        oldFVG = array.shift(bearFVGs)
        if not na(oldFVG.visual)
            box.delete(oldFVG.visual)
    array.push(bearFVGs, newFVG)

// Update FVG mitigation
f_updateFVGMitigation(array<FVG> fvgs, bool isBull) =>
    if array.size(fvgs) > 0
        for i = array.size(fvgs) - 1 to 0
            fvg = array.get(fvgs, i)
            if not fvg.mitigated
                if isBull and low <= fvg.mitLevel
                    fvg.mitigated := true
                    if not na(fvg.visual)
                        box.set_bgcolor(fvg.visual, color.new(color.gray, 90))
                else if not isBull and high >= fvg.mitLevel
                    fvg.mitigated := true
                    if not na(fvg.visual)
                        box.set_bgcolor(fvg.visual, color.new(color.gray, 90))

f_updateFVGMitigation(bullFVGs, true)
f_updateFVGMitigation(bearFVGs, false)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        IFVG (Inverse FVG) DETECTION                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IFVG: When price fills a FVG then reverses, the filled FVG becomes inverse zone
// Track recently mitigated FVGs and check for reversal

var array<FVG> bullIFVGs = array.new<FVG>()
var array<FVG> bearIFVGs = array.new<FVG>()

// Pastel IFVG colors (teal/cyan - distinct from FVG)
ifvgBearClr = #80DEEA  // Pastel cyan for bearish IFVG
ifvgBullClr = #A5D6A7  // Pastel green for bullish IFVG

// Check for IFVG creation from mitigated FVGs
f_checkIFVG(array<FVG> fvgs, array<FVG> ifvgs, bool wasBull) =>
    if array.size(fvgs) > 0
        for i = array.size(fvgs) - 1 to 0
            fvg = array.get(fvgs, i)
            // If FVG was just mitigated and we see reversal candle
            if fvg.mitigated and bar_index - fvg.startBar <= 20
                // Check for reversal after mitigation
                reversalCandle = wasBull ? (close < open and close < fvg.bottom) : (close > open and close > fvg.top)
                if reversalCandle and i_showIFVG
                    // Delete the original FVG box (transforms into IFVG)
                    if not na(fvg.visual)
                        box.delete(fvg.visual)

                    // Create IFVG (opposite direction)
                    newDir = wasBull ? DIR_BEAR : DIR_BULL
                    ifvgClr = wasBull ? ifvgBearClr : ifvgBullClr
                    newIFVG = FVG.new(
                         fvg.top, fvg.bottom, bar_index, newDir, false, (fvg.top + fvg.bottom) / 2,
                         box.new(bar_index - 1, fvg.top, bar_index + 10, fvg.bottom,
                                 border_color=ifvgClr, bgcolor=color.new(ifvgClr, 70),
                                 border_width=2, border_style=line.style_solid,
                                 text="IFVG", text_color=ifvgClr, text_size=size.tiny, text_halign=text.align_right))
                    if array.size(ifvgs) >= 5
                        oldIFVG = array.shift(ifvgs)
                        if not na(oldIFVG.visual)
                            box.delete(oldIFVG.visual)
                    array.push(ifvgs, newIFVG)
                    // Mark original as processed by moving far back
                    fvg.startBar := bar_index - 1000

f_checkIFVG(bullFVGs, bearIFVGs, true)
f_checkIFVG(bearFVGs, bullIFVGs, false)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        REJECTION BLOCK DETECTION                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Rejection Block: Long wick into a zone that rejects and closes outside
// Bullish RB: Long lower wick, closes in upper half (buying rejection at lows)
// Bearish RB: Long upper wick, closes in lower half (selling rejection at highs)

// Rejection Block Type
type RejBlock
    float top
    float bottom
    int startBar
    int direction
    box visual

var array<RejBlock> rejBlocks = array.new<RejBlock>()

// Calculate candle metrics
bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
totalRange = high - low

// Rejection criteria: wick > 60% of range, body < 40% of range
wickThreshold = 0.6
bodyThreshold = 0.4

// NOTE: Rejection Block detection moved after Premium/Discount zone calculation

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        LIQUIDITY DETECTION                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Equal Highs Detection
f_detectEqualHighs() =>
    found = false
    level = 0.0
    threshold = high * (i_eqThreshold / 100)
    for i = 5 to math.min(i_liqLookback, bar_index - 1)
        if math.abs(high - high[i]) <= threshold
            found := true
            level := math.max(high, high[i])
            break
    [found, level]

// Equal Lows Detection
f_detectEqualLows() =>
    found = false
    level = 0.0
    threshold = low * (i_eqThreshold / 100)
    for i = 5 to math.min(i_liqLookback, bar_index - 1)
        if math.abs(low - low[i]) <= threshold
            found := true
            level := math.min(low, low[i])
            break
    [found, level]

[hasEQH, eqhLevel] = f_detectEqualHighs()
[hasEQL, eqlLevel] = f_detectEqualLows()

// Track BSL/SSL
if hasEQH and i_showEQH
    newLiq = LiqLevel.new(eqhLevel, bar_index, 1, false, "EQH", na)
    if array.size(bslLevels) >= 10
        oldLiq = array.shift(bslLevels)
        if not na(oldLiq.visual)
            line.delete(oldLiq.visual)
    array.push(bslLevels, newLiq)

if hasEQL and i_showEQL
    newLiq = LiqLevel.new(eqlLevel, bar_index, 1, false, "EQL", na)
    if array.size(sslLevels) >= 10
        oldLiq = array.shift(sslLevels)
        if not na(oldLiq.visual)
            line.delete(oldLiq.visual)
    array.push(sslLevels, newLiq)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        VOLUME IMBALANCE (VI) DETECTION                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Volume Imbalance: Gap between consecutive candle bodies (not wicks)
// Bullish VI: Current candle body low > previous candle body high
// Bearish VI: Current candle body high < previous candle body low

viColor = #B388FF  // Pastel purple for VI

// Body calculations
currBodyHigh = math.max(close, open)
currBodyLow = math.min(close, open)
prevBodyHigh = math.max(close[1], open[1])
prevBodyLow = math.min(close[1], open[1])

// Minimum VI size (to filter noise)
minVISize = atrVal * 0.3

// Bullish VI: Gap up between bodies
bullishVI = currBodyLow > prevBodyHigh and (currBodyLow - prevBodyHigh) >= minVISize
viTopBull = currBodyLow
viBottomBull = prevBodyHigh

// Bearish VI: Gap down between bodies
bearishVI = currBodyHigh < prevBodyLow and (prevBodyLow - currBodyHigh) >= minVISize
viTopBear = prevBodyLow
viBottomBear = currBodyHigh

// Create VI boxes
if bullishVI and i_showFVG
    newVI = VolumeImbalance.new(viTopBull, viBottomBull, bar_index, DIR_BULL, false,
         box.new(bar_index - 1, viTopBull, bar_index + 10, viBottomBull,
                 border_color=viColor, bgcolor=color.new(viColor, 85),
                 border_width=1, border_style=line.style_dotted,
                 text="VI", text_color=viColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bullVIs) >= 10
        oldVI = array.shift(bullVIs)
        if not na(oldVI.visual)
            box.delete(oldVI.visual)
    array.push(bullVIs, newVI)

if bearishVI and i_showFVG
    newVI = VolumeImbalance.new(viTopBear, viBottomBear, bar_index, DIR_BEAR, false,
         box.new(bar_index - 1, viTopBear, bar_index + 10, viBottomBear,
                 border_color=viColor, bgcolor=color.new(viColor, 85),
                 border_width=1, border_style=line.style_dotted,
                 text="VI", text_color=viColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bearVIs) >= 10
        oldVI = array.shift(bearVIs)
        if not na(oldVI.visual)
            box.delete(oldVI.visual)
    array.push(bearVIs, newVI)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SUSPENSION BLOCK DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Suspension Block: Single candle with Volume Imbalance at BOTH ends
// "Being suspended between two volume imbalances" - ICT
// Extremely powerful PD Array - acts like FVG but single candle

suspBlockBullColor = #81D4FA  // Light blue for bullish
suspBlockBearColor = #FFAB91  // Light coral for bearish

// Check for VI at both ends of a single candle
// VI HIGH: Gap between this candle's body high and next candle's body low
// VI LOW: Gap between previous candle's body high and this candle's body low

// For detection, we look back one bar to confirm the candle[1] has VI at both ends
prevCandleBodyHigh = math.max(close[1], open[1])
prevCandleBodyLow = math.min(close[1], open[1])
prevPrevBodyHigh = math.max(close[2], open[2])
currBodyLowForSusp = math.min(close, open)
currBodyHighForSusp = math.max(close, open)

// VI at LOW end of candle[1]: prevPrev body high < candle[1] body low
viAtLow = prevPrevBodyHigh < prevCandleBodyLow and (prevCandleBodyLow - prevPrevBodyHigh) > minVISize * 0.5

// VI at HIGH end of candle[1]: candle[1] body high < current body low (for bullish)
// OR current body high < candle[1] body low (for bearish confirmation after)
viAtHighBull = prevCandleBodyHigh < currBodyLowForSusp and (currBodyLowForSusp - prevCandleBodyHigh) > minVISize * 0.5
viAtHighBear = currBodyHighForSusp < prevCandleBodyLow and (prevCandleBodyLow - currBodyHighForSusp) > minVISize * 0.5

// Bullish Suspension Block: Up close candle with VI at both ends
bullishSuspBlock = viAtLow and viAtHighBull and close[1] > open[1]
suspBlockTopBull = currBodyLowForSusp  // VI HIGH level
suspBlockBottomBull = prevPrevBodyHigh  // VI LOW level

// Bearish Suspension Block: Down close candle with VI at both ends
bearishSuspBlock = viAtLow and viAtHighBear and close[1] < open[1]
suspBlockTopBear = prevCandleBodyLow  // Higher VI level
suspBlockBottomBear = currBodyHighForSusp  // Lower VI level

// Create Suspension Block boxes
if bullishSuspBlock and i_showFVG
    newSB = SuspensionBlock.new(suspBlockTopBull, suspBlockBottomBull, prevCandleBodyHigh, prevCandleBodyLow,
         bar_index - 1, DIR_BULL, false, false,
         box.new(bar_index - 2, suspBlockTopBull, bar_index + 15, suspBlockBottomBull,
                 border_color=suspBlockBullColor, bgcolor=color.new(suspBlockBullColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="SUSP", text_color=suspBlockBullColor, text_size=size.tiny, text_halign=text.align_right),
         label.new(bar_index - 1, suspBlockTopBull, "â¬¡",
                   style=label.style_none, textcolor=suspBlockBullColor, size=size.small))
    if array.size(bullSuspBlocks) >= 5
        oldSB = array.shift(bullSuspBlocks)
        if not na(oldSB.visual)
            box.delete(oldSB.visual)
        if not na(oldSB.nameLabel)
            label.delete(oldSB.nameLabel)
    array.push(bullSuspBlocks, newSB)

if bearishSuspBlock and i_showFVG
    newSB = SuspensionBlock.new(suspBlockTopBear, suspBlockBottomBear, prevCandleBodyHigh, prevCandleBodyLow,
         bar_index - 1, DIR_BEAR, false, false,
         box.new(bar_index - 2, suspBlockTopBear, bar_index + 15, suspBlockBottomBear,
                 border_color=suspBlockBearColor, bgcolor=color.new(suspBlockBearColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="SUSP", text_color=suspBlockBearColor, text_size=size.tiny, text_halign=text.align_right),
         label.new(bar_index - 1, suspBlockTopBear, "â¬¡",
                   style=label.style_none, textcolor=suspBlockBearColor, size=size.small))
    if array.size(bearSuspBlocks) >= 5
        oldSB = array.shift(bearSuspBlocks)
        if not na(oldSB.visual)
            box.delete(oldSB.visual)
        if not na(oldSB.nameLabel)
            label.delete(oldSB.nameLabel)
    array.push(bearSuspBlocks, newSB)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        LIQUIDITY VOID DETECTION                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Liquidity Void: Large displacement candle where price moved too fast
// Creates an area price will likely return to fill

liqVoidColor = #CE93D8  // Pastel purple

// Large candle detection (> 2x ATR)
largeCandle = totalRange > atrVal * 2

// Check if the large candle has no overlapping wicks from surrounding candles
// This creates a "void" in price delivery
noOverlapHigh = high[1] < low and high[2] < low  // Gap up void
noOverlapLow = low[1] > high and low[2] > high   // Gap down void

// Bullish Liquidity Void: Large up candle with gap
bullishLiqVoid = largeCandle and close > open and noOverlapHigh
liqVoidTopBull = low
liqVoidBottomBull = math.max(high[1], high[2])

// Bearish Liquidity Void: Large down candle with gap
bearishLiqVoid = largeCandle and close < open and noOverlapLow
liqVoidTopBear = math.min(low[1], low[2])
liqVoidBottomBear = high

// Create Liquidity Void boxes
if bullishLiqVoid and i_showFVG
    newLV = LiquidityVoid.new(liqVoidTopBull, liqVoidBottomBull, bar_index, DIR_BULL, false,
         box.new(bar_index - 2, liqVoidTopBull, bar_index + 12, liqVoidBottomBull,
                 border_color=liqVoidColor, bgcolor=color.new(liqVoidColor, 80),
                 border_width=1, border_style=line.style_dashed,
                 text="VOID", text_color=liqVoidColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bullLiqVoids) >= 5
        oldLV = array.shift(bullLiqVoids)
        if not na(oldLV.visual)
            box.delete(oldLV.visual)
    array.push(bullLiqVoids, newLV)

if bearishLiqVoid and i_showFVG
    newLV = LiquidityVoid.new(liqVoidTopBear, liqVoidBottomBear, bar_index, DIR_BEAR, false,
         box.new(bar_index - 2, liqVoidTopBear, bar_index + 12, liqVoidBottomBear,
                 border_color=liqVoidColor, bgcolor=color.new(liqVoidColor, 80),
                 border_width=1, border_style=line.style_dashed,
                 text="VOID", text_color=liqVoidColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(bearLiqVoids) >= 5
        oldLV = array.shift(bearLiqVoids)
        if not na(oldLV.visual)
            box.delete(oldLV.visual)
    array.push(bearLiqVoids, newLV)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        NDOG (NEW DAY OPENING GAP) DETECTION                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NDOG: Gap between previous day's close and current day's open

ndogColor = #FFF59D  // Pastel yellow

// Detect new day
isNewTradingDay = ta.change(time("D")) != 0

if isNewTradingDay
    prevDayClose = close[1]
    todayOpen = open

    // Check for gap
    gapUp = todayOpen > prevDayClose
    gapDown = todayOpen < prevDayClose
    gapSize = math.abs(todayOpen - prevDayClose)

    // Only track significant gaps (> 0.1% of price)
    if gapSize > close * 0.001
        ndogHigh := gapUp ? todayOpen : prevDayClose
        ndogLow := gapUp ? prevDayClose : todayOpen
        ndogCE := (ndogHigh + ndogLow) / 2
        ndogFilled := false

// Check if NDOG is filled
if not na(ndogHigh) and not ndogFilled
    if low <= ndogCE and high >= ndogCE
        ndogFilled := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ORG (OPENING RANGE GAP) DETECTION                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ORG: First 5 minutes of NY session range - often acts as magnet

orgColor = #A5D6A7  // Pastel green

// Track opening range during first 5 minutes of NY session
nySessionStart = nyHour == 9 and nyMinute >= 30 and nyMinute < 35

if nySessionStart
    if not orgTracking
        orgHigh := high
        orgLow := low
        orgTracking := true
        orgFilled := false
    else
        orgHigh := math.max(orgHigh, high)
        orgLow := math.min(orgLow, low)
else if orgTracking and nyHour == 9 and nyMinute >= 35
    // Opening range complete
    orgCE := (orgHigh + orgLow) / 2
    orgTracking := false

// Reset at end of day
if nyHour == 16
    orgTracking := false

// Check if ORG CE is touched
if not na(orgCE) and not orgFilled and not orgTracking
    if low <= orgCE and high >= orgCE
        orgFilled := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              3-DAY ORG CONFLUENCE (ICT's Lookback System)                      â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "I'm looking at previous opening range gaps in the last three days"

// Track 3-day ORG history on new day
if isNewTradingDay
    // Shift ORG history
    org3DaysAgo := org2DaysAgo
    org2DaysAgo := org1DayAgo
    org1DayAgo := orgCE
    orgDayCount := math.min(orgDayCount + 1, 3)

// Check 3-Day ORG Confluence - when price trades through all 3 levels
org3DayConfluence = orgDayCount >= 3 and not na(org1DayAgo) and not na(org2DaysAgo) and not na(org3DaysAgo)
orgConfluenceZone = org3DayConfluence and
     ((close >= math.min(org1DayAgo, org2DaysAgo, org3DaysAgo) and close <= math.max(org1DayAgo, org2DaysAgo, org3DaysAgo)) or
      (close >= math.min(org1DayAgo, org2DaysAgo) * 0.999 and close <= math.max(org1DayAgo, org2DaysAgo) * 1.001))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    REJECTION BLOCK DETECTION                                   â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Look for price to trade under down close candles closing prices.
// These are rejection blocks and they tend to promote new runs higher"
// Different from Order Block - this is the CLOSE price of a single candle

rejBlockColor = #CE93D8  // Light purple for rejection blocks

// Rejection Block criteria:
// 1. Long wick (60%+ of candle range)
// 2. Close against the wick direction (rejection)
// 3. In premium or discount zone

candleRange = high - low
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low
bodySize = math.abs(close - open)

// Bullish Rejection Block: Down close candle with long lower wick (rejected low)
bullishRejBlock = close < open and                           // Down close
                  lowerWick > candleRange * 0.6 and          // Long lower wick (60%+)
                  candleRange > ta.atr(14) * 0.5 and        // Significant candle
                  close < (high + low) / 2                   // Close in lower half

// Bearish Rejection Block: Up close candle with long upper wick (rejected high)
bearishRejBlock = close > open and                           // Up close
                  upperWick > candleRange * 0.6 and          // Long upper wick (60%+)
                  candleRange > ta.atr(14) * 0.5 and        // Significant candle
                  close > (high + low) / 2                   // Close in upper half

// Create Rejection Blocks
if bullishRejBlock and i_showRejBlock
    newRB = RejectionBlock.new(close, high, low, bar_index, DIR_BULL, false,
         box.new(bar_index - 1, close, bar_index + 15, low,
                 border_color=rejBlockColor, bgcolor=color.new(rejBlockColor, 85),
                 border_width=1, border_style=line.style_dotted),
         label.new(bar_index, low, "RB", style=label.style_none,
                   textcolor=rejBlockColor, size=size.tiny))
    if array.size(bullRejBlocks) >= 8
        oldRB = array.shift(bullRejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
        if not na(oldRB.nameLabel)
            label.delete(oldRB.nameLabel)
    array.push(bullRejBlocks, newRB)

if bearishRejBlock and i_showRejBlock
    newRB = RejectionBlock.new(close, high, low, bar_index, DIR_BEAR, false,
         box.new(bar_index - 1, high, bar_index + 15, close,
                 border_color=rejBlockColor, bgcolor=color.new(rejBlockColor, 85),
                 border_width=1, border_style=line.style_dotted),
         label.new(bar_index, high, "RB", style=label.style_none,
                   textcolor=rejBlockColor, size=size.tiny))
    if array.size(bearRejBlocks) >= 8
        oldRB = array.shift(bearRejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
        if not na(oldRB.nameLabel)
            label.delete(oldRB.nameLabel)
    array.push(bearRejBlocks, newRB)

// Mitigate Rejection Blocks
if array.size(bullRejBlocks) > 0
    for i = array.size(bullRejBlocks) - 1 to 0
        rb = array.get(bullRejBlocks, i)
        if not rb.mitigated and low <= rb.level
            rb.mitigated := true

if array.size(bearRejBlocks) > 0
    for i = array.size(bearRejBlocks) - 1 to 0
        rb = array.get(bearRejBlocks, i)
        if not rb.mitigated and high >= rb.level
            rb.mitigated := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              WICK GRADIENT LEVELS (ICT's Notepad System)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Grade all premium candle wicks and anticipate the gradient levels...
// These are the things I have on my piece of paper"

wickGradientColor = #90CAF9  // Light blue for gradient levels

// Detect significant wicks for gradient tracking
minWickSize = ta.atr(14) * 1.5  // Significant wick = 1.5x ATR

// Premium Wick (long upper wick at relative highs)
isPremiumWick = upperWick > minWickSize and high >= ta.highest(high, 10)

// Discount Wick (long lower wick at relative lows)
isDiscountWick = lowerWick > minWickSize and low <= ta.lowest(low, 10)

// Create Premium Wick Gradient (on significant upper wicks)
if isPremiumWick
    // Calculate gradient levels on the wick
    wickBase = math.max(open, close)  // Where the wick starts
    wickTop = high                     // Where the wick ends
    wickSize = wickTop - wickBase

    newWG = WickGradient.new(
         wickTop,                      // 100% - Full wick extent
         wickBase + wickSize * 0.75,   // 75% level
         wickBase + wickSize * 0.50,   // 50% - CE
         wickBase + wickSize * 0.25,   // 25% level
         wickBase,                     // 0% - Wick base
         bar_index,
         DIR_BULL,
         true,
         line.new(bar_index, wickTop, bar_index + 20, wickTop, color=color.new(wickGradientColor, 60), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.75, bar_index + 20, wickBase + wickSize * 0.75, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.50, bar_index + 20, wickBase + wickSize * 0.50, color=color.new(#FFD700, 50), style=line.style_solid),  // CE highlighted
         line.new(bar_index, wickBase + wickSize * 0.25, bar_index + 20, wickBase + wickSize * 0.25, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase, bar_index + 20, wickBase, color=color.new(wickGradientColor, 60), style=line.style_dotted))

    // Limit array size
    if array.size(premiumWicks) >= 3
        oldWG = array.shift(premiumWicks)
        if not na(oldWG.line100)
            line.delete(oldWG.line100)
        if not na(oldWG.line75)
            line.delete(oldWG.line75)
        if not na(oldWG.line50)
            line.delete(oldWG.line50)
        if not na(oldWG.line25)
            line.delete(oldWG.line25)
        if not na(oldWG.line0)
            line.delete(oldWG.line0)
    array.push(premiumWicks, newWG)

// Create Discount Wick Gradient (on significant lower wicks)
if isDiscountWick
    // Calculate gradient levels on the wick
    wickTop = math.min(open, close)    // Where the wick starts
    wickBase = low                      // Where the wick ends
    wickSize = wickTop - wickBase

    newWG = WickGradient.new(
         wickBase,                     // 100% - Full wick extent (lowest)
         wickBase + wickSize * 0.25,   // 75% level
         wickBase + wickSize * 0.50,   // 50% - CE
         wickBase + wickSize * 0.75,   // 25% level
         wickTop,                      // 0% - Wick base
         bar_index,
         DIR_BEAR,
         true,
         line.new(bar_index, wickBase, bar_index + 20, wickBase, color=color.new(wickGradientColor, 60), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.25, bar_index + 20, wickBase + wickSize * 0.25, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickBase + wickSize * 0.50, bar_index + 20, wickBase + wickSize * 0.50, color=color.new(#FFD700, 50), style=line.style_solid),  // CE highlighted
         line.new(bar_index, wickBase + wickSize * 0.75, bar_index + 20, wickBase + wickSize * 0.75, color=color.new(wickGradientColor, 70), style=line.style_dotted),
         line.new(bar_index, wickTop, bar_index + 20, wickTop, color=color.new(wickGradientColor, 60), style=line.style_dotted))

    // Limit array size
    if array.size(discountWicks) >= 3
        oldWG = array.shift(discountWicks)
        if not na(oldWG.line100)
            line.delete(oldWG.line100)
        if not na(oldWG.line75)
            line.delete(oldWG.line75)
        if not na(oldWG.line50)
            line.delete(oldWG.line50)
        if not na(oldWG.line25)
            line.delete(oldWG.line25)
        if not na(oldWG.line0)
            line.delete(oldWG.line0)
    array.push(discountWicks, newWG)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘          HIGH/LOW RESISTANCE LIQUIDITY RUN DETECTION                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "There's two types of trading conditions - High Resistance liquidity runs
// where the Market's having difficulties trying to run to the obvious liquidity...
// it teases you a lot."

// Calculate market condition metrics
lookbackBars = 20

// Count reversals (changes in direction)
priceUp = close > close[1]
priceDown = close < close[1]
dirChange = (priceUp and priceDown[1]) or (priceDown and priceUp[1])
reversalCount := 0
for i = 0 to lookbackBars - 1
    if (close[i] > close[i+1] and close[i+1] < close[i+2]) or (close[i] < close[i+1] and close[i+1] > close[i+2])
        reversalCount += 1

// Calculate average move size vs current move
currentMove = math.abs(close - close[lookbackBars])
expectedMove = ta.atr(lookbackBars) * lookbackBars * 0.3  // Expected directional move

// Calculate time in consolidation (bars where range < ATR)
consolidationBars := 0
for i = 0 to lookbackBars - 1
    if (high[i] - low[i]) < ta.atr(14) * 0.7
        consolidationBars += 1

// Liquidity Run Score (0-100, higher = more resistance)
resistanceScore = 0.0
resistanceScore += math.min(reversalCount * 5, 40)              // Reversals contribute up to 40
resistanceScore += math.min(consolidationBars * 2, 30)          // Consolidation up to 30
resistanceScore += currentMove < expectedMove ? 30 : 0          // Below expected move = 30

liqRunScore := resistanceScore

// Classify market type
if resistanceScore >= 65
    liqRunType := "HIGH_RESISTANCE"
    isJaggedMarket := true
    isSmoothMarket := false
else if resistanceScore <= 35
    liqRunType := "LOW_RESISTANCE"
    isJaggedMarket := false
    isSmoothMarket := true
else
    liqRunType := "NEUTRAL"
    isJaggedMarket := false
    isSmoothMarket := false

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              TIME-BASED RISK ADJUSTMENT (ICT's Weekly Rhythm)                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Monday/non-farm payroll weeks have out-of-the-gate excitement at 9-9:30.
// If Monday doesn't deliver, Tuesday will be wild."

// Reset time risk values
timeRiskMultiplier := 1.0
timeRiskReason := ""
isHighProbTime := false
isLowProbTime := false

// Day of week assessment
if isMonday
    if nyHour >= 9 and nyHour < 11
        timeRiskMultiplier := 1.2           // Monday 9-11am = 80% success = higher risk OK
        timeRiskReason := "MON PRIME"
        isHighProbTime := true
    else if nyHour >= 11
        timeRiskMultiplier := 0.8           // Monday afternoon = lower conviction
        timeRiskReason := "MON PM"

else if isTuesday
    if nyHour >= 8 and nyHour < 11
        timeRiskMultiplier := 1.3           // Tuesday 8:30-11am = 90% success = best day
        timeRiskReason := "TUE PRIME"
        isHighProbTime := true
    else if nyHour >= 11 and nyHour < 14
        timeRiskMultiplier := 1.0
        timeRiskReason := "TUE MID"
    else
        timeRiskMultiplier := 0.7
        timeRiskReason := "TUE PM"

else if isWednesday
    if nyHour >= 8 and nyHour < 11
        timeRiskMultiplier := 0.9           // Wednesday AM = 60% success = more cautious
        timeRiskReason := "WED AM"
    else if nyHour >= 11
        timeRiskMultiplier := 0.5           // Wednesday 11am+ = 20% success = avoid!
        timeRiskReason := "WED CHOP"
        isLowProbTime := true

else if isThursday
    if nyHour >= 8 and nyHour < 11
        timeRiskMultiplier := 0.8           // Thursday AM = reversal day
        timeRiskReason := "THU REV"
    else
        timeRiskMultiplier := 0.6
        timeRiskReason := "THU PM"
        isLowProbTime := true

else if isFriday
    if nyHour >= 8 and nyHour < 12
        timeRiskMultiplier := 0.7           // Friday AM = expansion possible
        timeRiskReason := "FRI AM"
    else
        timeRiskMultiplier := 0.4           // Friday PM = avoid (weekend positioning)
        timeRiskReason := "FRI EXIT"
        isLowProbTime := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    DISCOUNT SENSITIVITY DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Discount sensitivity - when price honors these gradient levels with precision...
// when multiple PD arrays are present... that's discount sensitivity"

// Count confluences present at current price
sensitivityCount := 0
sensitivityLevel := na
discountSensitivity := false

// Check gradient level proximity
if array.size(discountWicks) > 0
    for i = 0 to math.min(array.size(discountWicks) - 1, 2)
        wg = array.get(discountWicks, i)
        if wg.active
            // Check if price is at any gradient level (within 0.1%)
            tolerance = close * 0.001
            if math.abs(close - wg.wick50) < tolerance
                sensitivityCount += 1
                sensitivityLevel := wg.wick50
            else if math.abs(close - wg.wick25) < tolerance or math.abs(close - wg.wick75) < tolerance
                sensitivityCount += 1

// Check FVG proximity
if hasFVGPresent
    sensitivityCount += 1

// Check Order Block proximity
if hasFreshOB
    sensitivityCount += 1

// Check OTE zone
if inOTE
    sensitivityCount += 1

// Check Suspension Block
if hasSuspensionBlock
    sensitivityCount += 2  // Double weight for suspension block

// Discount Sensitivity = 3+ confluences honoring a level
discountSensitivity := sensitivityCount >= 3 and inDiscount

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              IMMEDIATE REBALANCE PATTERN DETECTION                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Next day we open and trade back down to the previous day's close...
// offering an immediate rebalance... very strong reaction"

// Pattern: Gap down â†’ Sweep below prev close â†’ Immediate reversal
prevDayCloseForRebal = close[1]

// Bullish Immediate Rebalance: Gapped down, swept below, now reversing up
bullRebalancePattern = open < prevDayCloseForRebal and              // Gap down from prev close
                       low < prevDayCloseForRebal * 0.998 and       // Swept below prev close
                       close > prevDayCloseForRebal and              // Closed back above
                       close > open                                   // Bullish candle

// Bearish Immediate Rebalance: Gapped up, swept above, now reversing down
bearRebalancePattern = open > prevDayCloseForRebal and              // Gap up from prev close
                       high > prevDayCloseForRebal * 1.002 and      // Swept above prev close
                       close < prevDayCloseForRebal and              // Closed back below
                       close < open                                   // Bearish candle

if bullRebalancePattern
    immediateRebalanceBull := true
    immediateRebalanceBear := false
    rebalanceLevel := prevDayCloseForRebal
    rebalanceBar := bar_index
else if bearRebalancePattern
    immediateRebalanceBull := false
    immediateRebalanceBear := true
    rebalanceLevel := prevDayCloseForRebal
    rebalanceBar := bar_index
else if bar_index - rebalanceBar > 10  // Reset after 10 bars
    immediateRebalanceBull := false
    immediateRebalanceBear := false

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              MARKET MAKER BUY/SELL MODEL (9/18 EMA)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Market makers will generally price markets lower to buy into that drop [BUY MODEL]
// versus the market maker sell model where they price markets higher to sell [SELL MODEL]"

ema9 = ta.ema(close, 9)
ema18 = ta.ema(close, 18)

// Buy Model: 9 EMA below 18 EMA (expect buying into dips)
// Sell Model: 9 EMA above 18 EMA (expect selling into rallies)
if ema9 < ema18
    mmModel := "BUY_MODEL"
    mmModelBullish := true
    mmModelBearish := false
else if ema9 > ema18
    mmModel := "SELL_MODEL"
    mmModelBullish := false
    mmModelBearish := true
else
    mmModel := "NEUTRAL"
    mmModelBullish := false
    mmModelBearish := false

// EMA crossover detection for model changes
mmModelCrossBull = ta.crossover(ema9, ema18)   // Transitioning to Sell Model
mmModelCrossBear = ta.crossunder(ema9, ema18)  // Transitioning to Buy Model

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              POWER OF THREE MATURITY (Young vs Mature Swings)                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Daily swings are maturing into key support resistance...
// avoid the New York open setups if daily swings are maturing"

// Calculate swing ages in bars (convert to approximate days)
barsPerDay = timeframe.isintraday ? (1440 / timeframe.multiplier) : 1

// Update swing high age
if not na(lastSwingHighBar)
    swingHighAge := int((bar_index - lastSwingHighBar) / barsPerDay)
else
    swingHighAge := 0

// Update swing low age
if not na(lastSwingLowBar)
    swingLowAge := int((bar_index - lastSwingLowBar) / barsPerDay)
else
    swingLowAge := 0

// Classify swing maturity
// Young: 1-3 days - can absorb more displacement
// Mature: 5+ days - likely to reverse at next touch
matureSwingHigh := swingHighAge >= 5
matureSwingLow := swingLowAge >= 5
youngSwingHigh := swingHighAge >= 1 and swingHighAge <= 3
youngSwingLow := swingLowAge >= 1 and swingLowAge <= 3

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              LONGEST WICK CE DETECTION                                         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Consequent encroachment of the longest wick... this is the longest one
// so consequent encroachment is right there"

// Find the longest wick in the lookback period
wickLookback = 20
longestUpperWick = 0.0
longestLowerWick = 0.0
longestUpperBar = 0
longestLowerBar = 0

for i = 0 to wickLookback - 1
    upperWickI = high[i] - math.max(open[i], close[i])
    lowerWickI = math.min(open[i], close[i]) - low[i]

    if upperWickI > longestUpperWick
        longestUpperWick := upperWickI
        longestUpperBar := i

    if lowerWickI > longestLowerWick
        longestLowerWick := lowerWickI
        longestLowerBar := i

// Determine which wick is THE longest (upper or lower)
if longestUpperWick > longestLowerWick
    // Upper wick is longest - premium wick
    longestWickDirection := 1
    longestWickBar := bar_index - longestUpperBar
    wickBase = math.max(open[longestUpperBar], close[longestUpperBar])
    longestWickHigh := high[longestUpperBar]
    longestWickLow := wickBase
    longestWickCE := wickBase + longestUpperWick / 2  // CE = midpoint
else
    // Lower wick is longest - discount wick
    longestWickDirection := -1
    longestWickBar := bar_index - longestLowerBar
    wickTop = math.min(open[longestLowerBar], close[longestLowerBar])
    longestWickHigh := wickTop
    longestWickLow := low[longestLowerBar]
    longestWickCE := low[longestLowerBar] + longestLowerWick / 2  // CE = midpoint

// Check if price is at the longest wick CE
atLongestWickCE = not na(longestWickCE) and math.abs(close - longestWickCE) < close * 0.001

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              INSTITUTIONAL ORDER FLOW DRILL ENTRY                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT: "Institutional order flow drill - which is an entry into a PARTIAL fair value gap"

// IOF Drill: Enter at 50% of FVG (not full mitigation)
iofDrillLong := false
iofDrillShort := false
iofEntryLevel := na

// Check for bullish IOF Drill - enter at 50% into bearish FVG (SIBI)
if array.size(bearFVGs) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bearFVGs) - 1, 3)
        fvg = array.get(bearFVGs, i)
        if not fvg.mitigated
            fvgMid = (fvg.top + fvg.bottom) / 2
            // Price is at the 50% level of FVG (partial fill)
            if close <= fvg.top and close >= fvgMid and close > fvg.bottom
                iofDrillLong := true
                iofEntryLevel := fvgMid
                break

// Check for bearish IOF Drill - enter at 50% into bullish FVG (BISI)
if array.size(bullFVGs) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bullFVGs) - 1, 3)
        fvg = array.get(bullFVGs, i)
        if not fvg.mitigated
            fvgMid = (fvg.top + fvg.bottom) / 2
            // Price is at the 50% level of FVG (partial fill)
            if close >= fvg.bottom and close <= fvgMid and close < fvg.top
                iofDrillShort := true
                iofEntryLevel := fvgMid
                break

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        IPDA DATA RANGES                                        â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IPDA lookbacks
high20IPDA = ta.highest(high, 20)
low20IPDA = ta.lowest(low, 20)
high40IPDA = ta.highest(high, 40)
low40IPDA = ta.lowest(low, 40)
high60IPDA = ta.highest(high, 60)
low60IPDA = ta.lowest(low, 60)

// Previous Week High/Low (approximation)
barsPerWeek = 5 * 24 * (60 / timeframe.multiplier)
weeklyBars = math.min(barsPerWeek, 500)
pwHigh = ta.highest(high, int(weeklyBars))
pwLow = ta.lowest(low, int(weeklyBars))

// Previous Month High/Low
barsPerMonth = weeklyBars * 4
monthlyBars = math.min(barsPerMonth, 2000)
pmHigh = ta.highest(high, int(math.min(monthlyBars, bar_index)))
pmLow = ta.lowest(low, int(math.min(monthlyBars, bar_index)))

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        WEEKLY & QUARTERLY PROFILES                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Weekly Profile Detection
// ICT teaches specific weekly patterns based on day of week
currentDOW = dayofweek
isMonday = currentDOW == dayofweek.monday
isTuesday = currentDOW == dayofweek.tuesday
isWednesday = currentDOW == dayofweek.wednesday
isThursday = currentDOW == dayofweek.thursday
isFriday = currentDOW == dayofweek.friday

// Weekly Profile Types based on ICT teachings:
// - Classic: Mon/Tue consolidation, Wed reversal, Thu/Fri expansion
// - Seek & Destroy: Wed/Thu reversals trap traders
var string weeklyProfile = "DEVELOPING"
var float mondayHigh = na
var float mondayLow = na

// Track weekly range
if isMonday and (not isMonday[1] or na(weekHigh))
    weekHigh := high
    weekLow := low
    mondayHigh := high
    mondayLow := low
    weeklyProfile := "ACCUMULATION"
else if not isMonday and isMonday[1]
    mondayHigh := high[1]
    mondayLow := low[1]

if not na(weekHigh)
    weekHigh := math.max(weekHigh, high)
    weekLow := math.min(weekLow, low)

// Detect weekly profile pattern
if isTuesday
    weeklyProfile := "ACCUMULATION"
else if isWednesday
    // Wednesday is often manipulation/reversal day
    weeklyProfile := "MANIPULATION"
else if isThursday
    weeklyProfile := "DISTRIBUTION"
else if isFriday
    weeklyProfile := "DISTRIBUTION"

// Quarterly Shift Detection
// Q1: Jan-Mar, Q2: Apr-Jun, Q3: Jul-Sep, Q4: Oct-Dec
currentMonth = month
isQ1 = currentMonth >= 1 and currentMonth <= 3
isQ2 = currentMonth >= 4 and currentMonth <= 6
isQ3 = currentMonth >= 7 and currentMonth <= 9
isQ4 = currentMonth >= 10 and currentMonth <= 12

// Quarterly shift months (first month of quarter often sees direction change)
isQuarterStart = currentMonth == 1 or currentMonth == 4 or currentMonth == 7 or currentMonth == 10
quarterName = isQ1 ? "Q1" : isQ2 ? "Q2" : isQ3 ? "Q3" : "Q4"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        OPENING RANGE GAP (ORG)                                 â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Opening Range Gap: Gap between previous session close and current session open
// This is a key ICT concept for gap trading

var float prevDayClose = na
var float currentDayOpen = na
var float orgHigh = na
var float orgLow = na
var float orgCE = na
var bool hasORG = false
var bool gapIsAbove = false  // true = gap above price, false = gap below price
var float gapFillPct = 0.0   // 0-100% fill progress

// Detect new day (for intraday timeframes)
isNewDay = ta.change(time("D")) != 0

if isNewDay
    prevDayClose := close[1]
    currentDayOpen := open
    // ORG exists if there's a gap
    if not na(prevDayClose) and math.abs(currentDayOpen - prevDayClose) > atrVal * 0.25
        orgHigh := math.max(prevDayClose, currentDayOpen)
        orgLow := math.min(prevDayClose, currentDayOpen)
        orgCE := (orgHigh + orgLow) / 2
        hasORG := true
        // Determine if gap is above or below (at creation)
        gapIsAbove := currentDayOpen > prevDayClose  // Gap up = gap is above
    else
        hasORG := false
        gapFillPct := 0.0

// Calculate gap fill percentage dynamically
if hasORG and not na(orgHigh) and not na(orgLow)
    float gapSize = orgHigh - orgLow
    if gapSize > 0
        // Determine current gap position relative to price
        gapIsAbove := close < orgLow  // Gap is above if price is below gap low

        // Calculate fill based on how much price has penetrated the gap
        if close >= orgHigh
            gapFillPct := 100.0  // Fully filled from below
        else if close <= orgLow
            gapFillPct := 0.0    // Not filled yet (price below gap)
        else
            // Price is inside the gap - calculate percentage
            gapFillPct := ((close - orgLow) / gapSize) * 100.0

        // For gap downs (gap below price), invert the calculation
        if not gapIsAbove and close <= orgLow
            gapFillPct := 100.0
        else if not gapIsAbove and close >= orgHigh
            gapFillPct := 0.0
        else if not gapIsAbove and close > orgLow and close < orgHigh
            gapFillPct := ((orgHigh - close) / gapSize) * 100.0

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        SEEK & DESTROY DETECTION                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Seek & Destroy: ICT concept where Wed/Thu are reversal days that trap traders
// Market sweeps one side of Monday's range then reverses

// S&D Profile Detection
var bool seekDestroyDay = false
var string sdPhase = "NONE"  // SEEK, DESTROY, COMPLETE

// Wed/Thu are primary S&D days
seekDestroyDay := isWednesday or isThursday

// Detect S&D pattern
sdSeekingHigh = seekDestroyDay and not na(mondayHigh) and high > mondayHigh
sdSeekingLow = seekDestroyDay and not na(mondayLow) and low < mondayLow

// Phase detection
if seekDestroyDay
    if sdSeekingHigh and close < mondayHigh and close < open
        sdPhase := "DESTROY_BEARS"  // Swept high, reversing down
    else if sdSeekingLow and close > mondayLow and close > open
        sdPhase := "DESTROY_BULLS"  // Swept low, reversing up
    else if sdSeekingHigh or sdSeekingLow
        sdPhase := "SEEK"  // Currently seeking liquidity
    else
        sdPhase := "WATCH"  // S&D day but no sweep yet
else
    sdPhase := "NONE"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        CBDR (Central Bank Dealers Range)                       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Track CBDR session
if inCBDRSession and i_showCBDR
    if not inCBDR[1] or na(cbdrHigh)
        cbdrHigh := high
        cbdrLow := low
        inCBDR := true
    else
        cbdrHigh := math.max(cbdrHigh, high)
        cbdrLow := math.min(cbdrLow, low)
else if inCBDR[1] and not inCBDRSession
    cbdrRange := cbdrHigh - cbdrLow
    inCBDR := false

// CBDR SD Projections
cbdrSD1High = not na(cbdrHigh) ? cbdrHigh + cbdrRange * i_cbdrSD : na
cbdrSD1Low = not na(cbdrLow) ? cbdrLow - cbdrRange * i_cbdrSD : na

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        NWOG (New Week Opening Gap)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Detect new week
isNewWeek = dayofweek == dayofweek.monday and dayofweek[1] != dayofweek.monday

if isNewWeek and i_showNWOG
    // NWOG = Gap between Friday close and Sunday/Monday open
    float newNwogHigh = math.max(close[1], open)
    float newNwogLow = math.min(close[1], open)
    float newNwogCE = (newNwogHigh + newNwogLow) / 2

    // Add new NWOG to beginning of arrays (index 0 = most recent)
    array.unshift(nwogHighs, newNwogHigh)
    array.unshift(nwogLows, newNwogLow)
    array.unshift(nwogCEs, newNwogCE)

    // Trim arrays to max weeks
    while array.size(nwogHighs) > i_nwogWeeks
        array.pop(nwogHighs)
        array.pop(nwogLows)
        array.pop(nwogCEs)

    // Update single variables for backward compatibility
    nwogHigh := newNwogHigh
    nwogLow := newNwogLow
    nwogCE := newNwogCE
    newWeekStart := true

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        PREMIUM / DISCOUNT ZONES                                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculate range
rangeHigh = ta.highest(high, i_pdLookback)
rangeLow = ta.lowest(low, i_pdLookback)
rangeSize = rangeHigh - rangeLow
equilibrium = rangeLow + rangeSize * 0.5

// Zones
premiumZone = rangeLow + rangeSize * 0.7
discountZone = rangeLow + rangeSize * 0.3

inPremium = close > premiumZone
inDiscount = close < discountZone
atEquilibrium = close >= discountZone and close <= premiumZone

// OTE Zone (62-79%)
oteTop = msDirection == DIR_BULL ? rangeLow + rangeSize * 0.79 : rangeHigh - rangeSize * 0.62
oteBottom = msDirection == DIR_BULL ? rangeLow + rangeSize * 0.62 : rangeHigh - rangeSize * 0.79
inOTE = f_inRange(close, math.max(oteTop, oteBottom), math.min(oteTop, oteBottom))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REJECTION BLOCK DETECTION (uses inPremium/inDiscount defined above)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Bullish Rejection Block: Long lower wick at discount
bullishRejection = i_showRejBlock and totalRange > 0 and lowerWick / totalRange >= wickThreshold and bodySize / totalRange <= bodyThreshold and close > open and inDiscount

// Bearish Rejection Block: Long upper wick at premium
bearishRejection = i_showRejBlock and totalRange > 0 and upperWick / totalRange >= wickThreshold and bodySize / totalRange <= bodyThreshold and close < open and inPremium

// ICT-style Rejection Block colors (green/red - per ICT discount/premium)
rbBullColor = #C5E1A5  // Pastel lime for bullish rejection (discount)
rbBearColor = #EF9A9A  // Pastel red for bearish rejection (premium)
rbDotsColor = #FFEB3B  // Pac-Man yellow for strength dots

// RB Strength scoring function
f_rbStrength(float wickPct, float bodyPct, bool inKZ) =>
    score = 1  // Base score
    if wickPct >= 0.70
        score += 1  // Extra long wick
    if inKZ or bodyPct <= 0.30
        score += 1  // In killzone or extra small body
    score

// Create Rejection Blocks - ICT style with strength dots
if bullishRejection
    wickPct = lowerWick / totalRange
    bodyPct = bodySize / totalRange
    kzActive = londonKZ or nyAMKZ or nyPMKZ or inSilverBullet
    rbScore = f_rbStrength(wickPct, bodyPct, kzActive)
    rbDots = rbScore >= 3 ? "â—â—â—" : rbScore >= 2 ? "â—â—â—‹" : "â—â—‹â—‹"
    newRB = RejBlock.new(
         math.max(close, open), low, bar_index, DIR_BULL,
         box.new(bar_index, math.max(close, open), bar_index + 15, low,
                 border_color=rbBullColor, bgcolor=color.new(rbBullColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="RB " + rbDots, text_color=rbDotsColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(rejBlocks) >= 8
        oldRB = array.shift(rejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
    array.push(rejBlocks, newRB)

if bearishRejection
    wickPct = upperWick / totalRange
    bodyPct = bodySize / totalRange
    kzActive = londonKZ or nyAMKZ or nyPMKZ or inSilverBullet
    rbScore = f_rbStrength(wickPct, bodyPct, kzActive)
    rbDots = rbScore >= 3 ? "â—â—â—" : rbScore >= 2 ? "â—â—â—‹" : "â—â—‹â—‹"
    newRB = RejBlock.new(
         high, math.min(close, open), bar_index, DIR_BEAR,
         box.new(bar_index, high, bar_index + 15, math.min(close, open),
                 border_color=rbBearColor, bgcolor=color.new(rbBearColor, 75),
                 border_width=2, border_style=line.style_solid,
                 text="RB " + rbDots, text_color=rbDotsColor, text_size=size.tiny, text_halign=text.align_right))
    if array.size(rejBlocks) >= 8
        oldRB = array.shift(rejBlocks)
        if not na(oldRB.visual)
            box.delete(oldRB.visual)
    array.push(rejBlocks, newRB)

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                   POWER OF THREE (AMD) - PRICE-BASED ENGINE                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ICT's Power of 3: ACCUMULATION â†’ MANIPULATION â†’ DISTRIBUTION
// This is NOT just time-based - it's based on PRICE ACTION within those times

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 1: ACCUMULATION (Asian Session) - Build the range
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if asianSession
    po3Phase := "ACCUMULATION"
    amdPhase := 1

    // Reset at start of Asian session (new day cycle)
    if nyHour == 20 or na(accumulationHigh)
        accumulationHigh := high
        accumulationLow := low
        // Reset manipulation tracking for new day
        asianHighSwept := false
        asianLowSwept := false
        manipulationComplete := false
        manipDirection := 0
        expectedDirection := 0
        distributionStarted := false
        manipulationSwingHigh := na
        manipulationSwingLow := na
    else
        accumulationHigh := math.max(accumulationHigh, high)
        accumulationLow := math.min(accumulationLow, low)

    amdStatus := "ACCUMULATION - Range building [" + str.tostring(accumulationHigh, format.mintick) + " / " + str.tostring(accumulationLow, format.mintick) + "]"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 2: MANIPULATION (London/Early NY) - Judas sweep detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
else if (londonSession or nyAMSession) and not manipulationComplete
    po3Phase := "MANIPULATION"
    amdPhase := 2

    // Check for Asian High sweep (fake bullish move â†’ expect bearish)
    if not asianHighSwept and not na(accumulationHigh) and high > accumulationHigh
        asianHighSwept := true
        manipDirection := 1  // Swept high = fake bull
        expectedDirection := -1  // Expect bear after
        manipulationSwingHigh := high
        amdStatus := "MANIPULATION - Asian HIGH SWEPT! Expect reversal DOWN"

    // Check for Asian Low sweep (fake bearish move â†’ expect bullish)
    if not asianLowSwept and not na(accumulationLow) and low < accumulationLow
        asianLowSwept := true
        manipDirection := -1  // Swept low = fake bear
        expectedDirection := 1  // Expect bull after
        manipulationSwingLow := low
        amdStatus := "MANIPULATION - Asian LOW SWEPT! Expect reversal UP"

    // Track manipulation swing extremes
    if manipDirection == 1 and not na(manipulationSwingHigh)
        manipulationSwingHigh := math.max(manipulationSwingHigh, high)
    if manipDirection == -1 and not na(manipulationSwingLow)
        manipulationSwingLow := math.min(manipulationSwingLow, low)

    // Detect manipulation completion (reversal confirmation)
    // After sweeping high, look for bearish CHoCH/displacement
    if manipDirection == 1 and asianHighSwept
        if bearishCHoCH or (displacementDown and close < accumulationHigh)
            manipulationComplete := true
            amdEntryZoneTop := manipulationSwingHigh
            amdEntryZoneBottom := accumulationHigh
            amdStatus := "JUDAS COMPLETE - Reversal DOWN confirmed, seeking SSL"

    // After sweeping low, look for bullish CHoCH/displacement
    if manipDirection == -1 and asianLowSwept
        if bullishCHoCH or (displacementUp and close > accumulationLow)
            manipulationComplete := true
            amdEntryZoneTop := accumulationLow
            amdEntryZoneBottom := manipulationSwingLow
            amdStatus := "JUDAS COMPLETE - Reversal UP confirmed, seeking BSL"

    // No sweep yet
    if not asianHighSwept and not asianLowSwept
        amdStatus := "MANIPULATION - Watching for Asian range sweep..."

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PHASE 3: DISTRIBUTION (Post-Manipulation) - True move to DOL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
else if manipulationComplete or nyPMSession
    po3Phase := "DISTRIBUTION"
    amdPhase := 3

    if manipulationComplete
        distributionStarted := true
        if expectedDirection == 1
            amdStatus := "DISTRIBUTION - True move UP to BSL"
        else if expectedDirection == -1
            amdStatus := "DISTRIBUTION - True move DOWN to SSL"
        else
            amdStatus := "DISTRIBUTION - True move in progress"
    else
        amdStatus := "DISTRIBUTION - NY PM session (late distribution)"

// Default: No clear phase
else
    po3Phase := "NONE"
    amdPhase := 0
    amdStatus := "No active AMD phase"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMD CONFLUENCE - Boost score when aligned with manipulation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
amdAligned = (manipulationComplete and expectedDirection == 1 and msDirection == DIR_BULL) or
             (manipulationComplete and expectedDirection == -1 and msDirection == DIR_BEAR)

// AMD provides strong directional bias after Judas completes
amdBiasBull = manipulationComplete and expectedDirection == 1
amdBiasBear = manipulationComplete and expectedDirection == -1

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        2022 MODEL DETECTION                                    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// 2022 Model: Sweep + Displacement + FVG
sweepLows = low < low20IPDA[1] and close > open
sweepHighs = high > high20IPDA[1] and close < open

model2022Bull = i_show2022 and sweepLows[1] and displacementUp and bullishFVG
model2022Bear = i_show2022 and sweepHighs[1] and displacementDown and bearishFVG

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ¦„ UNICORN MODEL DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Unicorn Model: Breaker Block that contains/overlaps an FVG
// This creates an institutional "unicorn" entry zone with multiple confluences

// Check if any breaker block overlaps with an FVG
var bool unicornBull = false
var bool unicornBear = false
unicornBull := false
unicornBear := false

// Scan for breaker + FVG overlap (Unicorn conditions)
// Check bullish breakers
if array.size(bullOBs) > 0
    for i = 0 to math.min(array.size(bullOBs) - 1, 5)
        ob = array.get(bullOBs, i)
        if ob.isBreaker
            // Check if this breaker overlaps with any bullish FVG
            if array.size(bullFVGs) > 0
                for j = 0 to math.min(array.size(bullFVGs) - 1, 3)
                    fvg = array.get(bullFVGs, j)
                    if fvg.top >= ob.bottom and fvg.bottom <= ob.top
                        unicornBull := true
                        break

// Check bearish breakers
if array.size(bearOBs) > 0
    for i = 0 to math.min(array.size(bearOBs) - 1, 5)
        ob = array.get(bearOBs, i)
        if ob.isBreaker
            // Check if this breaker overlaps with any bearish FVG
            if array.size(bearFVGs) > 0
                for j = 0 to math.min(array.size(bearFVGs) - 1, 3)
                    fvg = array.get(bearFVGs, j)
                    if fvg.top >= ob.bottom and fvg.bottom <= ob.top
                        unicornBear := true
                        break

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ”„ AMD FRACTAL (Nested AMD)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// AMD within AMD: Track if we're seeing nested accumulation-manipulation-distribution
// HTF AMD phase combined with LTF AMD phase alignment

var string htfAMDPhase = "NONE"
var string ltfAMDPhase = "NONE"
var bool amdFractalBull = false
var bool amdFractalBear = false

// HTF AMD based on session structure
htfAMDPhase := asianSession ? "ACCUMULATION" : londonSession ? "MANIPULATION" : nyAMSession ? "DISTRIBUTION" : "NONE"

// Pre-calculate ATR values (must be called on every bar)
atr5 = ta.atr(5)
atr20 = ta.atr(20)

// LTF AMD based on intraday price action (within NY session)
if nyAMSession or nyPMSession
    // Check for mini accumulation (consolidation after manipulation)
    isLTFAccumulation = atr5 < atr20 * 0.7  // Low volatility = accumulation
    isLTFManipulation = displacementUp or displacementDown  // Displacement = manipulation
    isLTFDistribution = bullishCHoCH or bearishCHoCH  // CHoCH = distribution starting

    ltfAMDPhase := isLTFAccumulation ? "ACC" : isLTFManipulation ? "MAN" : isLTFDistribution ? "DIST" : "NONE"

// AMD Fractal alignment: HTF Distribution + LTF showing same direction
amdFractalBull := htfAMDPhase == "DISTRIBUTION" and ltfAMDPhase == "DIST" and bullishCHoCH
amdFractalBear := htfAMDPhase == "DISTRIBUTION" and ltfAMDPhase == "DIST" and bearishCHoCH

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“Š MMXM (Market Maker Model)                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Market Maker Buy/Sell Model: Complete sequence detection
// Buy Model: Sweep SSL â†’ Displacement Up â†’ FVG â†’ OTE Entry
// Sell Model: Sweep BSL â†’ Displacement Down â†’ FVG â†’ OTE Entry

var bool mmxmBullSetup = false
var bool mmxmBearSetup = false
var int mmxmBullBar = 0
var int mmxmBearBar = 0

// Detect MMXM Buy Model (Smart Money Accumulation)
if sweepLows[1] and displacementUp and bullishFVG and inDiscount
    mmxmBullSetup := true
    mmxmBullBar := bar_index
else if bar_index - mmxmBullBar > 20  // Reset after 20 bars
    mmxmBullSetup := false

// Detect MMXM Sell Model (Smart Money Distribution)
if sweepHighs[1] and displacementDown and bearishFVG and inPremium
    mmxmBearSetup := true
    mmxmBearBar := bar_index
else if bar_index - mmxmBearBar > 20  // Reset after 20 bars
    mmxmBearSetup := false

// MMXM confirmation when price enters OTE zone after setup
mmxmBullConfirm = mmxmBullSetup and inOTE and msDirection == DIR_BULL
mmxmBearConfirm = mmxmBearSetup and inOTE and msDirection == DIR_BEAR

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“… SEASONAL TENDENCIES                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ICT Seasonal Tendencies based on typical market behavior
// Q1 (Jan-Mar): Dollar strength, indices weakness
// Q2 (Apr-Jun): Dollar weakness, commodities rally
// Q3 (Jul-Sep): Summer doldrums, low volatility
// Q4 (Oct-Dec): Year-end rally, risk-on

// Use currentMonth already defined earlier (line ~1105)
currentQuarter = currentMonth <= 3 ? 1 : currentMonth <= 6 ? 2 : currentMonth <= 9 ? 3 : 4

// Seasonal bias for US indices/risk assets
seasonalBullish = currentQuarter == 4 or currentMonth == 4 or currentMonth == 7  // Oct-Dec, April, July
seasonalBearish = currentMonth == 9 or currentMonth == 2  // September, February (historically weak)
seasonalNeutral = not seasonalBullish and not seasonalBearish

// Seasonal strength indicator
var string seasonalTendency = "NEUTRAL"
seasonalTendency := seasonalBullish ? "BULLISH SEASON" : seasonalBearish ? "BEARISH SEASON" : "NEUTRAL SEASON"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ“ˆ COT DATA (Placeholder)                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// NOTE: COT (Commitment of Traders) data requires external data feed
// Pine Script doesn't have native access to COT reports
// This is a placeholder for when external data integration is available
// Users can manually set COT bias based on weekly COT report

var string cotBias = "NEUTRAL"  // User can override via input
// Future enhancement: Connect to external COT data source

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        MIDNIGHT OPEN TRACKING                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if isMidnight
    midnightOpen := open

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              ğŸ¯ COMPREHENSIVE ICT SCORING ENGINE (Cortex-Derived)              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 1: FOUNDATION SCORE (0-30 points) - MUST HAVE for valid setup
// Based on ICT's core hierarchy: Market Structure â†’ Liquidity â†’ HTF Alignment
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

foundationScore = 0.0
var bool hasFoundationComplete = false

// 1A. MARKET STRUCTURE (0-10 points) - 8,016 Cortex mentions
hasMSClear = msDirection == DIR_BULL or msDirection == DIR_BEAR
hasCHoCH = bullishCHoCH or bearishCHoCH
hasBOS = bullishBOS or bearishBOS

if hasMSClear
    foundationScore += 5
    if hasCHoCH
        foundationScore += 3  // CHoCH is stronger signal
    else if hasBOS
        foundationScore += 2  // BOS confirms structure

// 1B. LIQUIDITY TARGET IDENTIFIED (0-10 points) - 7,892 Cortex mentions
nearestBSL = array.size(bslLevels) > 0 ? array.get(bslLevels, array.size(bslLevels) - 1).level : na
nearestSSL = array.size(sslLevels) > 0 ? array.get(sslLevels, array.size(sslLevels) - 1).level : na
hasLiquidityTarget = (msDirection == DIR_BULL and not na(nearestBSL)) or (msDirection == DIR_BEAR and not na(nearestSSL))

distToBSL = not na(nearestBSL) ? math.abs(close - nearestBSL) : 9999
distToSSL = not na(nearestSSL) ? math.abs(close - nearestSSL) : 9999
isNearLiquidity = (msDirection == DIR_BULL and distToBSL < distToSSL * 0.7) or (msDirection == DIR_BEAR and distToSSL < distToBSL * 0.7)

if hasLiquidityTarget
    foundationScore += 6
    if isNearLiquidity
        foundationScore += 4  // Bonus for being close to target

// 1C. HTF ALIGNMENT (0-10 points) - Critical for confluence
hasHTFAlignment = (htfBias == DIR_BULL and msDirection == DIR_BULL) or (htfBias == DIR_BEAR and msDirection == DIR_BEAR)
hasMTFAlignment = (mtfBiasW == 1 and mtfBiasD == 1 and mtfBias1H == 1) or (mtfBiasW == -1 and mtfBiasD == -1 and mtfBias1H == -1)

if hasHTFAlignment
    foundationScore += 6
    if hasMTFAlignment
        foundationScore += 4  // Full MTF alignment bonus

hasFoundationComplete := foundationScore >= 20  // Need 20/30 for valid foundation

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 2: ENTRY ZONE SCORE (0-25 points) - WHERE to enter
// Based on ICT's entry zones: Premium/Discount â†’ OTE â†’ Order Block
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

zoneScore = 0.0
var bool hasZoneAlignment = false

// 2A. PREMIUM/DISCOUNT ALIGNMENT (0-10 points) - 6,234 Cortex mentions
isCorrectZone = (inDiscount and msDirection == DIR_BULL) or (inPremium and msDirection == DIR_BEAR)
isWrongZone = (inPremium and msDirection == DIR_BULL) or (inDiscount and msDirection == DIR_BEAR)

if isCorrectZone
    zoneScore += 10
else if isWrongZone
    zoneScore -= 5  // Penalty for wrong zone

// 2B. OTE ZONE (0-10 points) - 4,216 Cortex mentions - Primary entry zone
if inOTE
    zoneScore += 10

// 2C. ORDER BLOCK ENTRY (0-5 points) - 5,891 Cortex mentions
atBullOB = false
atBearOB = false

if array.size(bullOBs) > 0
    for i = 0 to math.min(array.size(bullOBs) - 1, 5)
        ob = array.get(bullOBs, i)
        if ob.state == OB_TESTED and f_inRange(close, ob.top, ob.bottom)
            atBullOB := true
            break

if array.size(bearOBs) > 0
    for i = 0 to math.min(array.size(bearOBs) - 1, 5)
        ob = array.get(bearOBs, i)
        if ob.state == OB_TESTED and f_inRange(close, ob.top, ob.bottom)
            atBearOB := true
            break

hasFreshOB = (atBullOB and msDirection == DIR_BULL) or (atBearOB and msDirection == DIR_BEAR)
if hasFreshOB
    zoneScore += 5

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 2D: PD ARRAY PROXIMITY SCORING (0-15 points) - NEW COMPREHENSIVE SYSTEM
// Each PD array adds value when price is near it and direction aligned
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

pdArrayScore = 0.0
var bool hasSuspensionBlock = false
var bool hasVolumeImbalance = false
var bool hasLiquidityVoid = false
hasSuspensionBlock := false
hasVolumeImbalance := false
hasLiquidityVoid := false

// Check Suspension Blocks (MOST POWERFUL - 5 points)
// ICT: "Extremely powerful PD Array - one of the most powerful"
if array.size(bullSuspBlocks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullSuspBlocks) - 1, 3)
        sb = array.get(bullSuspBlocks, i)
        if not sb.mitigated and close <= sb.top and close >= sb.bottom * 0.995
            hasSuspensionBlock := true
            pdArrayScore += 5
            break
        else if not sb.mitigated and close > sb.top and close < sb.top * 1.01
            hasSuspensionBlock := true
            pdArrayScore += 3  // Nearby but not in
            break

if array.size(bearSuspBlocks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearSuspBlocks) - 1, 3)
        sb = array.get(bearSuspBlocks, i)
        if not sb.mitigated and close >= sb.bottom and close <= sb.top * 1.005
            hasSuspensionBlock := true
            pdArrayScore += 5
            break
        else if not sb.mitigated and close < sb.bottom and close > sb.bottom * 0.99
            hasSuspensionBlock := true
            pdArrayScore += 3
            break

// Check Volume Imbalances (3 points)
if array.size(bullVIs) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullVIs) - 1, 5)
        vi = array.get(bullVIs, i)
        if not vi.filled and close >= vi.bottom and close <= vi.top
            hasVolumeImbalance := true
            pdArrayScore += 3
            break

if array.size(bearVIs) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearVIs) - 1, 5)
        vi = array.get(bearVIs, i)
        if not vi.filled and close >= vi.bottom and close <= vi.top
            hasVolumeImbalance := true
            pdArrayScore += 3
            break

// Check Liquidity Voids (3 points - price drawn to fill)
if array.size(bullLiqVoids) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullLiqVoids) - 1, 3)
        lv = array.get(bullLiqVoids, i)
        if not lv.filled and close >= lv.bottom and close <= lv.top
            hasLiquidityVoid := true
            pdArrayScore += 3
            break

if array.size(bearLiqVoids) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearLiqVoids) - 1, 3)
        lv = array.get(bearLiqVoids, i)
        if not lv.filled and close >= lv.bottom and close <= lv.top
            hasLiquidityVoid := true
            pdArrayScore += 3
            break

// Check NDOG (2 points - New Day Opening Gap)
hasNDOGAlignment = false
if not na(ndogCE) and not ndogFilled
    if msDirection == DIR_BULL and close < ndogCE and close > ndogLow
        hasNDOGAlignment := true
        pdArrayScore += 2
    else if msDirection == DIR_BEAR and close > ndogCE and close < ndogHigh
        hasNDOGAlignment := true
        pdArrayScore += 2

// Check ORG (2 points - Opening Range Gap)
hasORGAlignment = false
if not na(orgCE) and not orgFilled and not orgTracking
    if msDirection == DIR_BULL and close < orgCE and close > orgLow
        hasORGAlignment := true
        pdArrayScore += 2
    else if msDirection == DIR_BEAR and close > orgCE and close < orgHigh
        hasORGAlignment := true
        pdArrayScore += 2

// Add PD Array score to zone score (capped contribution)
zoneScore += math.min(pdArrayScore, 15)

hasZoneAlignment := zoneScore >= 15  // Need 15/40 for good zone (expanded)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 3: CONFIRMATION SCORE (0-20 points) - Validates entry
// Based on ICT confirmations: FVG â†’ Displacement â†’ Killzone â†’ Silver Bullet
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

confirmationScore = 0.0

// 3A. FVG PRESENT (0-5 points) - 4,567 Cortex mentions
bullFVGAbove = false
bearFVGBelow = false

if array.size(bullFVGs) > 0
    for i = 0 to math.min(array.size(bullFVGs) - 1, 5)
        fvg = array.get(bullFVGs, i)
        if not fvg.mitigated and fvg.bottom > close
            bullFVGAbove := true
            break

if array.size(bearFVGs) > 0
    for i = 0 to math.min(array.size(bearFVGs) - 1, 5)
        fvg = array.get(bearFVGs, i)
        if not fvg.mitigated and fvg.top < close
            bearFVGBelow := true
            break

hasFVGTarget = (bullFVGAbove and msDirection == DIR_BULL) or (bearFVGBelow and msDirection == DIR_BEAR)
hasFVGPresent = array.size(bullFVGs) > 0 or array.size(bearFVGs) > 0

if hasFVGTarget
    confirmationScore += 5
else if hasFVGPresent
    confirmationScore += 2

// 3B. DISPLACEMENT (0-5 points) - 2,123 Cortex mentions
hasDisplacement = (displacementUp and msDirection == DIR_BULL) or (displacementDown and msDirection == DIR_BEAR)
if hasDisplacement
    confirmationScore += 5

// 3C. KILLZONE TIMING (0-5 points) - 3,892 Cortex mentions
hasKillzone = londonKZ or nyAMKZ or nyPMKZ
if hasKillzone
    confirmationScore += 5

// 3D. SILVER BULLET WINDOW (0-5 points) - 3,456 Cortex mentions
hasSilverBullet = inSilverBullet
if hasSilverBullet
    confirmationScore += 5

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 4: COMBINATION BONUSES (0-25 points) - ICT's preferred confluences
// Based on Cortex co-mention analysis of high-probability combinations
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

comboScore = 0.0

// Combo 1: Liquidity + OTE (179 co-mentions) - ICT's #1 entry setup
if hasLiquidityTarget and inOTE
    comboScore += 8

// Combo 2: FVG + Zone Alignment (104 co-mentions)
if hasFVGPresent and isCorrectZone
    comboScore += 5

// Combo 3: OTE + Order Block (93 co-mentions)
if inOTE and hasFreshOB
    comboScore += 5

// Combo 4: Displacement + FVG (creates IFVG potential)
if hasDisplacement and hasFVGPresent
    comboScore += 4

// Combo 5: Full MTF + Killzone (time + direction alignment)
if hasMTFAlignment and hasKillzone
    comboScore += 3

// Combo 6: AMD ALIGNMENT - Judas completed + direction confirmed (HUGE edge)
if amdAligned
    comboScore += 10  // Major bonus - this is ICT's bread and butter

// Combo 7: Post-Judas + OTE (optimal entry after manipulation)
if manipulationComplete and inOTE
    comboScore += 5

// Combo 8: Silver Bullet Prime Window + FVG (ICT's favorite)
if sbPrime and hasFVGPresent
    comboScore += 6

// Combo 9: Macro Time + Displacement (time-based reversal)
if isMacroTime and hasDisplacement
    comboScore += 4

// Combo 10: Seek & Destroy Day + Counter-trend setup
if isSeekDestroyDay and hasCHoCH
    comboScore += 3

// Combo 11: Rejection Block + Zone (strong rejection in correct zone)
hasRejBlock = (hasRecentBullRej and msDirection == DIR_BULL) or (hasRecentBearRej and msDirection == DIR_BEAR)
if hasRejBlock and isCorrectZone
    comboScore += 5

// Combo 12: Power Hour + High Confluence (institutional activity)
if isPowerHour and confluenceCount >= 5
    comboScore += 3

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 4B: PD ARRAY COMBO BONUSES - NEW ICT CONCEPTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Combo 13: Suspension Block + OTE (ICT's most powerful entry)
if hasSuspensionBlock and inOTE
    comboScore += 8  // Major bonus - ICT says this is extremely powerful

// Combo 14: Suspension Block + FVG stacked (double PD array)
if hasSuspensionBlock and hasFVGPresent
    comboScore += 5

// Combo 15: Volume Imbalance + Order Block (VI confirms OB)
if hasVolumeImbalance and hasFreshOB
    comboScore += 4

// Combo 16: Liquidity Void + Displacement (strong move into void)
if hasLiquidityVoid and hasDisplacement
    comboScore += 4

// Combo 17: NDOG + Silver Bullet (gap fill during SB window)
if hasNDOGAlignment and sbPrime
    comboScore += 5

// Combo 18: ORG + Macro Time (opening range play at macro)
if hasORGAlignment and isMacroTime
    comboScore += 4

// Combo 19: Multiple PD Arrays stacked (confluence of PD arrays)
pdArrayCount = (hasSuspensionBlock ? 1 : 0) + (hasVolumeImbalance ? 1 : 0) + (hasLiquidityVoid ? 1 : 0) + (hasFVGPresent ? 1 : 0) + (hasFreshOB ? 1 : 0)
if pdArrayCount >= 3
    comboScore += 6  // Stacked PD arrays = high probability
else if pdArrayCount >= 2
    comboScore += 3

// Combo 20: Suspension Block + Killzone (time + price confluence)
if hasSuspensionBlock and hasKillzone
    comboScore += 4

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW HIDDEN GEM COMBOS (Combos 21-27)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check for Rejection Block proximity
hasRejectionBlock = false
if array.size(bullRejBlocks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(bullRejBlocks) - 1, 3)
        rb = array.get(bullRejBlocks, i)
        if not rb.mitigated and close >= rb.level * 0.998 and close <= rb.level * 1.002
            hasRejectionBlock := true
            break
if array.size(bearRejBlocks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(bearRejBlocks) - 1, 3)
        rb = array.get(bearRejBlocks, i)
        if not rb.mitigated and close >= rb.level * 0.998 and close <= rb.level * 1.002
            hasRejectionBlock := true
            break

// Combo 21: Rejection Block + OTE (ICT's bounce signal)
if hasRejectionBlock and inOTE
    comboScore += 5

// Combo 22: Rejection Block + FVG stacked
if hasRejectionBlock and hasFVGPresent
    comboScore += 4

// Combo 23: 3-Day ORG Confluence (ICT's lookback system)
if orgConfluenceZone
    comboScore += 6  // Major bonus - price respecting 3 days of ORGs

// Combo 24: Discount Sensitivity (3+ confluences honoring gradient)
if discountSensitivity
    comboScore += 7  // ICT: "the market immediately launches"

// Combo 25: Low Resistance Liquidity Run + Direction alignment
if isSmoothMarket and (msDirection == DIR_BULL or msDirection == DIR_BEAR)
    comboScore += 5  // Smooth market = easier targets

// Combo 26: Wick Gradient CE test (price at consequent encroachment)
hasWickGradientCE = false
if array.size(discountWicks) > 0 and msDirection == DIR_BULL
    for i = 0 to math.min(array.size(discountWicks) - 1, 2)
        wg = array.get(discountWicks, i)
        if wg.active and math.abs(close - wg.wick50) < close * 0.001
            hasWickGradientCE := true
            break
if array.size(premiumWicks) > 0 and msDirection == DIR_BEAR
    for i = 0 to math.min(array.size(premiumWicks) - 1, 2)
        wg = array.get(premiumWicks, i)
        if wg.active and math.abs(close - wg.wick50) < close * 0.001
            hasWickGradientCE := true
            break

if hasWickGradientCE
    comboScore += 4  // ICT's notepad level being tested

// Combo 27: High Probability Time + Strong Setup (Tuesday PRIME)
if isHighProbTime and (hasSuspensionBlock or hasModel2022 or hasUnicorn)
    comboScore += 6  // Best day + best setup = maximum conviction

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW HIDDEN GEM COMBOS (28-35) - From Cortex Deep Dive
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Combo 28: Immediate Rebalance Pattern (high probability bounce)
if immediateRebalanceBull and msDirection == DIR_BULL
    comboScore += 8  // ICT: "very strong reaction"
if immediateRebalanceBear and msDirection == DIR_BEAR
    comboScore += 8

// Combo 29: Market Maker Model Alignment
// Buy Model + Bullish bias = institutions buying dips
// Sell Model + Bearish bias = institutions selling rallies
if mmModelBullish and msDirection == DIR_BULL and inDiscount
    comboScore += 5  // Aligned with MM buying
if mmModelBearish and msDirection == DIR_BEAR and inPremium
    comboScore += 5  // Aligned with MM selling

// Combo 30: Young Swing + Strong Setup (can take more displacement)
if youngSwingHigh and msDirection == DIR_BEAR and (hasSuspensionBlock or hasFVGPresent)
    comboScore += 4  // Young swing = more room to move
if youngSwingLow and msDirection == DIR_BULL and (hasSuspensionBlock or hasFVGPresent)
    comboScore += 4

// Combo 31: Mature Swing Warning (penalty - likely to reverse)
// ICT: "avoid the New York open setups if daily swings are maturing"
if matureSwingHigh and msDirection == DIR_BEAR and nyHour >= 9 and nyHour <= 11
    comboScore -= 3  // Penalty - mature swing may reverse
if matureSwingLow and msDirection == DIR_BULL and nyHour >= 9 and nyHour <= 11
    comboScore -= 3

// Combo 32: Longest Wick CE Test (ICT's special level)
if atLongestWickCE
    comboScore += 5  // Price at THE longest wick's CE

// Combo 33: Longest Wick CE + Direction alignment
if atLongestWickCE and longestWickDirection == -1 and msDirection == DIR_BULL
    comboScore += 3  // Discount wick CE + bullish = bounce point
if atLongestWickCE and longestWickDirection == 1 and msDirection == DIR_BEAR
    comboScore += 3  // Premium wick CE + bearish = rejection point

// Combo 34: IOF Drill Entry (institutional order flow)
if iofDrillLong
    comboScore += 6  // ICT: "entry into a partial fair value gap"
if iofDrillShort
    comboScore += 6

// Combo 35: IOF Drill + OTE + Killzone (maximum precision entry)
if (iofDrillLong or iofDrillShort) and inOTE and hasKillzone
    comboScore += 4  // Additional bonus for perfect timing

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER 5: TRIGGER DETECTION - What fires the signal
// High-conviction setups that represent complete ICT models
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var string activeTrigger = "NONE"
var float triggerMultiplier = 1.0
activeTrigger := "NONE"
triggerMultiplier := 0.7  // Default: no trigger = 70% of score (capped at MODERATE)

// Detect which trigger is active (priority order)
hasModel2022 = model2022Bull or model2022Bear
hasTurtleSoup = bullishTS or bearishTS
hasJudas = bullishJudas or bearishJudas
hasUnicorn = unicornBull or unicornBear
hasMMXM = mmxmBullConfirm or mmxmBearConfirm
hasAMDFractal = amdFractalBull or amdFractalBear

// High-conviction triggers (1.2x multiplier)
if hasUnicorn
    activeTrigger := "UNICORN"
    triggerMultiplier := 1.25
else if hasMMXM
    activeTrigger := "MMXM"
    triggerMultiplier := 1.2
else if hasModel2022
    activeTrigger := "2022 MODEL"
    triggerMultiplier := 1.2
else if hasTurtleSoup
    activeTrigger := "TURTLE SOUP"
    triggerMultiplier := 1.15
else if hasAMDFractal
    activeTrigger := "AMD FRACTAL"
    triggerMultiplier := 1.1
else if hasJudas
    activeTrigger := "JUDAS SWING"
    triggerMultiplier := 1.1
// Standard triggers (1.0x multiplier)
else if hasCHoCH
    activeTrigger := "CHoCH"
    triggerMultiplier := 1.0
else if hasBOS
    activeTrigger := "BOS"
    triggerMultiplier := 0.9
else if hasSilverBullet and hasKillzone
    activeTrigger := "SILVER BULLET"
    triggerMultiplier := 1.0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CALCULATE FINAL COMPOSITE SCORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Raw score out of 100
rawScore = foundationScore + zoneScore + confirmationScore + comboScore

// Apply trigger multiplier
adjustedScore = rawScore * triggerMultiplier

// Apply TIME-BASED RISK adjustment (ICT's weekly rhythm)
// Tuesday PRIME boosts, Wednesday 11am+ penalizes
adjustedScore := adjustedScore * timeRiskMultiplier

// Apply HIGH/LOW RESISTANCE LIQUIDITY RUN adjustment
// High resistance = harder to reach targets = lower effective score
// Low resistance = easier targets = slight boost
if isJaggedMarket
    adjustedScore := adjustedScore * 0.85  // 15% penalty for high resistance (choppy)
else if isSmoothMarket
    adjustedScore := adjustedScore * 1.05  // 5% boost for low resistance (smooth)

// Cap at 100
compositeScore := math.min(adjustedScore, 100)

// Store individual layer scores for display
var float displayFoundation = 0.0
var float displayZone = 0.0
var float displayConfirmation = 0.0
var float displayCombo = 0.0
displayFoundation := foundationScore
displayZone := zoneScore
displayConfirmation := confirmationScore
displayCombo := comboScore

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETERMINE DIRECTION (separate from quality score)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Direction based on market structure (not score comparison)
if msDirection == DIR_BULL
    dolDirection := DIR_BULL
    dolTarget := not na(nearestBSL) ? nearestBSL : high20IPDA
else if msDirection == DIR_BEAR
    dolDirection := DIR_BEAR
    dolTarget := not na(nearestSSL) ? nearestSSL : low20IPDA
else
    dolDirection := DIR_NEUTRAL
    dolTarget := equilibrium

// Legacy probability for compatibility (now based on composite score)
dolProbability := compositeScore

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BUILD REASON STRING WITH LAYER BREAKDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if dolDirection == DIR_BULL
    dolReason := "BULLISH"
    dolReason += hasHTFAlignment ? " â€¢ HTF" : ""
    dolReason += isCorrectZone ? " â€¢ DISCOUNT" : ""
    dolReason += inOTE ? " â€¢ OTE" : ""
    dolReason += hasFreshOB ? " â€¢ OB" : ""
    dolReason += hasDisplacement ? " â€¢ DISP" : ""
    dolReason += hasKillzone ? " â€¢ KZ" : ""
    dolReason += activeTrigger != "NONE" ? " â€¢ " + activeTrigger : ""
else if dolDirection == DIR_BEAR
    dolReason := "BEARISH"
    dolReason += hasHTFAlignment ? " â€¢ HTF" : ""
    dolReason += isCorrectZone ? " â€¢ PREMIUM" : ""
    dolReason += inOTE ? " â€¢ OTE" : ""
    dolReason += hasFreshOB ? " â€¢ OB" : ""
    dolReason += hasDisplacement ? " â€¢ DISP" : ""
    dolReason += hasKillzone ? " â€¢ KZ" : ""
    dolReason += activeTrigger != "NONE" ? " â€¢ " + activeTrigger : ""
else
    dolReason := "NEUTRAL - AWAITING STRUCTURE"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        COMPOSITE TIER ASSIGNMENT                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tier requirements (absolute, not relative)
// ELITE: 85+ with high-conviction trigger and complete foundation
// PREMIUM: 70-84 with any trigger and good foundation
// STRONG: 55-69 with foundation
// MODERATE: 40-54
// WEAK: <40

isHighConvictionTrigger = hasUnicorn or hasMMXM or hasModel2022 or hasTurtleSoup
isAnyTrigger = activeTrigger != "NONE"

// Count total confluences for display
confluenceCount = 0
if hasMSClear
    confluenceCount += 1
if hasHTFAlignment
    confluenceCount += 1
if hasMTFAlignment
    confluenceCount += 1
if hasLiquidityTarget
    confluenceCount += 1
if isCorrectZone
    confluenceCount += 1
if inOTE
    confluenceCount += 1
if hasFreshOB
    confluenceCount += 1
if hasFVGPresent
    confluenceCount += 1
if hasDisplacement
    confluenceCount += 1
if hasKillzone
    confluenceCount += 1
if hasSilverBullet
    confluenceCount += 1
if isHighConvictionTrigger
    confluenceCount += 2  // High-conviction triggers count as 2

// Assign tier with requirements
if compositeScore >= 85 and isHighConvictionTrigger and hasFoundationComplete
    compositeTier := TIER_1  // ELITE
else if compositeScore >= 70 and isAnyTrigger and hasFoundationComplete
    compositeTier := TIER_2  // PREMIUM
else if compositeScore >= 55 and hasFoundationComplete
    compositeTier := TIER_3  // STRONG
else if compositeScore >= 40
    compositeTier := TIER_4  // MODERATE
else
    compositeTier := TIER_5  // WEAK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PATTERN NAMES (Based on active trigger and tier)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
patternName := ""

// TIER 1 ELITE - Highest probability setups
if compositeTier == TIER_1
    if activeTrigger == "UNICORN"
        patternName := "ğŸ¦„ UNICORN SETUP"
    else if activeTrigger == "MMXM"
        patternName := "ğŸ“Š MMXM CONFIRMED"
    else if activeTrigger == "2022 MODEL" and hasMTFAlignment
        patternName := "ğŸ’ DIAMOND SETUP"
    else if activeTrigger == "2022 MODEL"
        patternName := "ğŸ† THE APEX"
    else if activeTrigger == "TURTLE SOUP" and hasSilverBullet
        patternName := "ğŸ† PERFECT STORM"
    else if confluenceCount >= 10
        patternName := "ğŸ† MEGA CONFLUENCE"
    else
        patternName := "ğŸ† ELITE SETUP"

// TIER 2 PREMIUM - Very strong setups
else if compositeTier == TIER_2
    if activeTrigger == "UNICORN"
        patternName := "ğŸ¦„ UNICORN ZONE"
    else if activeTrigger == "MMXM"
        patternName := "ğŸ“Š MMXM SETUP"
    else if activeTrigger == "AMD FRACTAL"
        patternName := "ğŸ”„ AMD FRACTAL"
    else if activeTrigger == "TURTLE SOUP"
        patternName := "â­ SWEET SPOT"
    else if activeTrigger == "JUDAS SWING"
        patternName := "â­ JUDAS TRAP"
    else if activeTrigger == "2022 MODEL"
        patternName := "â­ 2022 ENTRY"
    else if activeTrigger == "SILVER BULLET"
        patternName := "â­ BULLET TIME"
    else if confluenceCount >= 7
        patternName := "â­ PREMIUM SETUP"
    else
        patternName := "â­ STRONG BIAS"

// TIER 3 STRONG - Good setups
else if compositeTier == TIER_3
    if inOTE and isCorrectZone
        patternName := "ğŸ¥ˆ OTE ZONE"
    else if activeTrigger == "TURTLE SOUP"
        patternName := "ğŸ¥ˆ SOUP ALIGNED"
    else if hasDisplacement and hasFreshOB
        patternName := "ğŸ¥ˆ OB PLAY"
    else if activeTrigger == "CHoCH"
        patternName := "ğŸ¥ˆ CHoCH ENTRY"
    else if activeTrigger == "BOS"
        patternName := "ğŸ¥ˆ BOS PLAY"
    else if hasSilverBullet
        patternName := "ğŸ¥ˆ BULLET WINDOW"
    else
        patternName := "ğŸ¥ˆ GOOD SETUP"

// TIER 4 MODERATE - Developing setups
else if compositeTier == TIER_4
    if isCorrectZone
        patternName := "ğŸ¥‰ ZONE PLAY"
    else if hasDisplacement
        patternName := "ğŸ¥‰ MOMENTUM"
    else if hasFreshOB
        patternName := "ğŸ¥‰ OB WATCH"
    else if hasKillzone
        patternName := "ğŸ¥‰ KILLZONE"
    else
        patternName := "ğŸ¥‰ DEVELOPING"

// TIER 5 WEAK - Low probability
else
    if hasFVGPresent
        patternName := "âš ï¸ FVG ONLY"
    else if hasKillzone
        patternName := "âš ï¸ WAITING"
    else
        patternName := "âš ï¸ NO SETUP"

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                        ğŸ¨ VISUAL RENDERING                                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SESSION BACKGROUNDS - Very subtle, non-distracting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

sessionColor = asianSession ? color.new(#9C27B0, 97) : londonSession ? color.new(#2196F3, 97) : nyAMSession ? color.new(#4CAF50, 97) : nyPMSession ? color.new(#FF9800, 97) : na

bgcolor(i_showSessions ? sessionColor : na, title="Session Background")

// Killzone highlight - subtle accent
kzColor = (asianKZ or londonKZ or nyAMKZ or nyPMKZ) and i_showKillzones ? color.new(#FFC107, 95) : na
bgcolor(kzColor, title="Killzone Highlight")

// Silver Bullet highlight - slightly more visible for key windows
bgcolor(i_showSilverBullet and inSilverBullet ? color.new(#00E5FF, 93) : na, title="Silver Bullet")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKET STRUCTURE LABELS (Clean minimal style)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// BOS - subtle small markers
plotshape(i_showBOS and bullishBOS, title="BOS Bull", style=shape.triangleup,
     location=location.abovebar, color=color.new(i_bullColor, 30), text="", size=size.tiny)
plotshape(i_showBOS and bearishBOS, title="BOS Bear", style=shape.triangledown,
     location=location.belowbar, color=color.new(i_bearColor, 30), text="", size=size.tiny)

// CHoCH - more prominent as it's a reversal signal
plotshape(i_showCHoCH and bullishCHoCH, title="CHoCH Bull", style=shape.diamond,
     location=location.abovebar, color=i_neutralColor, text="âŸ²", textcolor=i_neutralColor, size=size.tiny)
plotshape(i_showCHoCH and bearishCHoCH, title="CHoCH Bear", style=shape.diamond,
     location=location.belowbar, color=i_neutralColor, text="âŸ²", textcolor=i_neutralColor, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TURTLE SOUP LABELS (Clean style)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Turtle Soup - clean minimal badge
plotshape(i_showTurtleSoup and bullishTS, title="Turtle Soup Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(i_bullColor, 20), text="TS", textcolor=color.white, size=size.small)
plotshape(i_showTurtleSoup and bearishTS, title="Turtle Soup Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(i_bearColor, 20), text="TS", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JUDAS SWING LABELS (Subtle accent)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(i_showJudas and bullishJudas, title="Judas Bull", style=shape.circle,
     location=location.belowbar, color=color.new(#9C27B0, 20), text="J", textcolor=color.white, size=size.tiny)
plotshape(i_showJudas and bearishJudas, title="Judas Bear", style=shape.circle,
     location=location.abovebar, color=color.new(#9C27B0, 20), text="J", textcolor=color.white, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 2022 MODEL LABELS (Important signal - keep visible)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(model2022Bull, title="2022 Model Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#00BCD4, 10), text="2022", textcolor=color.white, size=size.small)
plotshape(model2022Bear, title="2022 Model Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#00BCD4, 10), text="2022", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNICORN MODEL LABELS (Breaker + FVG confluence)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(unicornBull and barstate.isconfirmed, title="Unicorn Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#AA00FF, 10), text="ğŸ¦„ UNICORN", textcolor=color.white, size=size.small)
plotshape(unicornBear and barstate.isconfirmed, title="Unicorn Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#AA00FF, 10), text="ğŸ¦„ UNICORN", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MMXM (Market Maker Model) LABELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(mmxmBullConfirm and barstate.isconfirmed, title="MMXM Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#FF6D00, 10), text="MMXM â–²", textcolor=color.white, size=size.small)
plotshape(mmxmBearConfirm and barstate.isconfirmed, title="MMXM Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#FF6D00, 10), text="MMXM â–¼", textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AMD FRACTAL LABELS (Nested AMD alignment)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plotshape(amdFractalBull and barstate.isconfirmed, title="AMD Fractal Bull", style=shape.diamond,
     location=location.belowbar, color=color.new(#4CAF50, 10), text="AMD", textcolor=color.white, size=size.tiny)
plotshape(amdFractalBear and barstate.isconfirmed, title="AMD Fractal Bear", style=shape.diamond,
     location=location.abovebar, color=color.new(#F44336, 10), text="AMD", textcolor=color.white, size=size.tiny)

// Swing points and EQH/EQL removed to reduce plot count - tracked via info table

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OTE SPAWN ZONE - Dashed lines with levels
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line oteLine62 = na
var line oteLine705 = na
var line oteLine79 = na
var label oteLabel62 = na
var label oteLabel705 = na
var label oteLabel79 = na

// OTE color - ICT cyan
oteLineColor = #00BCD4

if i_showOTE and barstate.islast
    // Clean up old lines
    if not na(oteLine62)
        line.delete(oteLine62)
    if not na(oteLine705)
        line.delete(oteLine705)
    if not na(oteLine79)
        line.delete(oteLine79)
    if not na(oteLabel62)
        label.delete(oteLabel62)
    if not na(oteLabel705)
        label.delete(oteLabel705)
    if not na(oteLabel79)
        label.delete(oteLabel79)

    // Calculate OTE levels (62%, 70.5%, 79% of the range)
    float ote62 = rangeLow + rangeSize * 0.62
    float ote705 = rangeLow + rangeSize * 0.705
    float ote79 = rangeLow + rangeSize * 0.79

    // Draw dashed lines for each OTE level - subtle reference lines (dimmer)
    oteLine62 := line.new(bar_index - 50, ote62, bar_index + 10, ote62,
         color=color.new(oteLineColor, 75), width=1, style=line.style_dotted)
    oteLine705 := line.new(bar_index - 50, ote705, bar_index + 10, ote705,
         color=color.new(oteLineColor, 60), width=1, style=line.style_dotted)
    oteLine79 := line.new(bar_index - 50, ote79, bar_index + 10, ote79,
         color=color.new(oteLineColor, 75), width=1, style=line.style_dotted)

    // Labels UNDER line, right-aligned (dimmer to match lines)
    float labelOffset = rangeSize * 0.015
    oteLabel62 := label.new(bar_index + 10, ote62 - labelOffset, "62%",
         style=label.style_none, textcolor=color.new(oteLineColor, 60), size=size.tiny, textalign=text.align_right)
    oteLabel705 := label.new(bar_index + 10, ote705 - labelOffset, "OTE",
         style=label.style_none, textcolor=color.new(oteLineColor, 50), size=size.tiny, textalign=text.align_right)
    oteLabel79 := label.new(bar_index + 10, ote79 - labelOffset, "79%",
         style=label.style_none, textcolor=color.new(oteLineColor, 60), size=size.tiny, textalign=text.align_right)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LONGEST WICK CE - ICT's Special Level (Hidden Gem)
// "Consequent encroachment of the longest wick... that's the one that matters"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line longestWickCELine = na
var label longestWickCELabel = na

// Color based on wick direction
lwceColor = longestWickDirection == 1 ? #FF5252 : longestWickDirection == -1 ? #00E676 : #78909C

if barstate.islast and not na(longestWickCE)
    // Clean up old
    if not na(longestWickCELine)
        line.delete(longestWickCELine)
    if not na(longestWickCELabel)
        label.delete(longestWickCELabel)

    // Draw the Longest Wick CE line - distinctive teal with circle markers
    longestWickCELine := line.new(bar_index - 30, longestWickCE, bar_index + 15, longestWickCE,
         color=color.new(#00BFA5, 40), width=2, style=line.style_dotted)

    // Label with direction indicator
    lwceText = longestWickDirection == 1 ? "âŠ• LW-CE â–¼" : longestWickDirection == -1 ? "âŠ• LW-CE â–²" : "âŠ• LW-CE"
    longestWickCELabel := label.new(bar_index + 15, longestWickCE, lwceText,
         style=label.style_none, textcolor=color.new(#00BFA5, 20), size=size.tiny, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKET MAKER MODEL STATE - 9/18 EMA Visual (Hidden Gem)
// "Market makers will generally price markets lower to buy [BUY MODEL]"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var label mmModelLabel = na

if barstate.islast
    // Clean up old
    if not na(mmModelLabel)
        label.delete(mmModelLabel)

    // Position in top-left area of chart (below price)
    mmLabelY = low - (high - low) * 0.15
    mmLabelColor = mmModelBullish ? #00E676 : mmModelBearish ? #FF5252 : #78909C
    mmLabelText = mmModelBullish ? "ğŸŸ¢ MM BUY MODEL" : mmModelBearish ? "ğŸ”´ MM SELL MODEL" : "âšª MM NEUTRAL"

    mmModelLabel := label.new(bar_index + 2, mmLabelY, mmLabelText,
         style=label.style_none, textcolor=mmLabelColor, size=size.small, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PREMIUM/DISCOUNT ZONES - Subtle reference lines
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(i_showPDZones ? premiumZone : na, "Premium Zone", color=color.new(i_bearColor, 80), linewidth=1, style=plot.style_linebr)
plot(i_showPDZones ? discountZone : na, "Discount Zone", color=color.new(i_bullColor, 80), linewidth=1, style=plot.style_linebr)
plot(i_showEQ ? equilibrium : na, "Equilibrium", color=color.new(#78909C, 60), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CBDR GRID - Subtle background grid lines (toggle-able)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line cbdrGridHigh = na
var line cbdrGridLow = na
var line cbdrGridSD1High = na
var line cbdrGridSD1Low = na
var label cbdrLabelHigh = na
var label cbdrLabelLow = na
var label cbdrLabelSD1High = na
var label cbdrLabelSD1Low = na

// Draw CBDR as subtle grid on last bar only
if barstate.islast and i_showCBDR
    // Clean up previous grid lines and labels
    if not na(cbdrGridHigh)
        line.delete(cbdrGridHigh)
    if not na(cbdrGridLow)
        line.delete(cbdrGridLow)
    if not na(cbdrGridSD1High)
        line.delete(cbdrGridSD1High)
    if not na(cbdrGridSD1Low)
        line.delete(cbdrGridSD1Low)
    if not na(cbdrLabelHigh)
        label.delete(cbdrLabelHigh)
    if not na(cbdrLabelLow)
        label.delete(cbdrLabelLow)
    if not na(cbdrLabelSD1High)
        label.delete(cbdrLabelSD1High)
    if not na(cbdrLabelSD1Low)
        label.delete(cbdrLabelSD1Low)

    // Subtle grid color
    cbdrGridColor = color.new(color.teal, 85)
    cbdrSDColor = color.new(color.teal, 90)

    // CBDR High/Low - subtle dotted lines extending full width
    if not na(cbdrHigh)
        cbdrGridHigh := line.new(bar_index - 200, cbdrHigh, bar_index + 30, cbdrHigh,
             color=cbdrGridColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelHigh := label.new(bar_index + 30, cbdrHigh, "CBDR Hi",
             style=label.style_none, textcolor=color.new(color.teal, 50), size=size.tiny, textalign=text.align_left)

    if not na(cbdrLow)
        cbdrGridLow := line.new(bar_index - 200, cbdrLow, bar_index + 30, cbdrLow,
             color=cbdrGridColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelLow := label.new(bar_index + 30, cbdrLow, "CBDR Lo",
             style=label.style_none, textcolor=color.new(color.teal, 50), size=size.tiny, textalign=text.align_left)

    // SD Projections - even more subtle, with labels
    if i_showCBDRProjections and not na(cbdrSD1High)
        cbdrGridSD1High := line.new(bar_index - 200, cbdrSD1High, bar_index + 30, cbdrSD1High,
             color=cbdrSDColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelSD1High := label.new(bar_index + 30, cbdrSD1High, "SD+",
             style=label.style_none, textcolor=color.new(color.teal, 70), size=size.tiny, textalign=text.align_left)

    if i_showCBDRProjections and not na(cbdrSD1Low)
        cbdrGridSD1Low := line.new(bar_index - 200, cbdrSD1Low, bar_index + 30, cbdrSD1Low,
             color=cbdrSDColor, width=1, style=line.style_dotted, extend=extend.left)
        cbdrLabelSD1Low := label.new(bar_index + 30, cbdrSD1Low, "SD-",
             style=label.style_none, textcolor=color.new(color.teal, 70), size=size.tiny, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NWOG ZONE - Multi-week display with progressive fading
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box[] nwogBoxes = array.new_box(0)
var line[] nwogCELines = array.new_line(0)

// Clean up old boxes and lines on last bar
if barstate.islast
    // Delete existing boxes using while loop (safer for empty arrays)
    while array.size(nwogBoxes) > 0
        box.delete(array.pop(nwogBoxes))

    // Delete existing CE lines
    while array.size(nwogCELines) > 0
        line.delete(array.pop(nwogCELines))

    // Draw new boxes for each stored NWOG
    int nwogCount = array.size(nwogHighs)
    if i_showNWOG and nwogCount > 0
        for i = 0 to nwogCount - 1
            float h = array.get(nwogHighs, i)
            float l = array.get(nwogLows, i)
            float ce = array.get(nwogCEs, i)

            // Pastel periwinkle for NWOG - progressive fading for older weeks
            nwogColor = #B39DDB  // Pastel purple/periwinkle
            int fadeLevel = 0 + (i * 15)  // 0, 15, 30, 45, 60 for 5 weeks
            int bgFade = 70 + (i * 5)     // 70, 75, 80, 85, 90 for 5 weeks
            fadeLevel := math.min(fadeLevel, 70)
            bgFade := math.min(bgFade, 90)

            // Label: NWOG-1 (current) through NWOG-5 (oldest)
            string nwogLabel = "NWOG-" + str.tostring(i + 1)

            // Draw box relative to current bar (safe approach)
            int boxLeft = bar_index - 50
            box newBox = box.new(boxLeft, h, bar_index + 10, l,
                 border_color=color.new(nwogColor, fadeLevel), bgcolor=color.new(nwogColor, bgFade),
                 border_width=2, border_style=line.style_solid,
                 text=nwogLabel, text_color=color.new(nwogColor, fadeLevel), text_size=size.tiny, text_halign=text.align_right)
            array.push(nwogBoxes, newBox)

            // Draw CE line for each NWOG
            if i_showNWOGCE
                int ceFade = 20 + (i * 15)  // 20, 35, 50, 65, 80 for 5 weeks
                ceFade := math.min(ceFade, 80)
                line ceLine = line.new(boxLeft, ce, bar_index + 10, ce,
                     color=color.new(nwogColor, ceFade), width=i == 0 ? 2 : 1, style=line.style_dashed)
                array.push(nwogCELines, ceLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OPENING RANGE GAP (ORG) VISUAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box orgBox = na
gapColor = #FFCC80  // Pastel orange for Opening Range Gap

if hasORG and not na(orgHigh) and not na(orgLow) and barstate.islast
    if not na(orgBox)
        box.delete(orgBox)
    orgBox := box.new(bar_index - 20, orgHigh, bar_index + 5, orgLow,
         border_color=gapColor, bgcolor=color.new(gapColor, 75),
         border_width=2, border_style=line.style_solid,
         text="GAP", text_color=gapColor, text_size=size.tiny, text_halign=text.align_right)

// GAP CE line
plot(hasORG and not na(orgCE) ? orgCE : na, "GAP CE", color=color.new(gapColor, 30), linewidth=2, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MIDNIGHT OPEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(i_showMidnight and not na(midnightOpen) ? midnightOpen : na, "Midnight Open", color=color.new(color.white, 50), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// IPDA LEVELS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// IPDA plots reduced to stay under 64 plot limit
plot(i_ipda60 and i_showIPDA ? high60IPDA : na, "IPDA 60 High", color=color.new(color.blue, 60), linewidth=1, style=plot.style_linebr)
plot(i_ipda60 and i_showIPDA ? low60IPDA : na, "IPDA 60 Low", color=color.new(color.blue, 60), linewidth=1, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAC-MAN DOL PATH VISUALIZATION - Sleek arcade style
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAC-MAN DOL PATH - Dynamic Multi-Waypoint "Most Likely Path"
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line[] dolPathLines = array.new_line(0)
var label[] dolPathLabels = array.new_label(0)

// Pac-Man themed colors
pacmanYellow = #FFEB3B  // Classic Pac-Man yellow
pacmanGold = #FFC107    // Golden pellets
pacmanCyan = #00BCD4    // Path color

if i_showDOL and i_showPacMan and barstate.islast
    // Clean up old visuals
    while array.size(dolPathLines) > 0
        line.delete(array.pop(dolPathLines))
    while array.size(dolPathLabels) > 0
        label.delete(array.pop(dolPathLabels))

    // Determine visual style based on setup quality
    tradeReady = (compositeTier == TIER_1 or compositeTier == TIER_2) and
                 (manipulationComplete or amdPhase == 3) and
                 dolDirection != DIR_NEUTRAL
    highConf = compositeTier <= TIER_3 and dolDirection != DIR_NEUTRAL

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BUILD WAYPOINT ARRAY - Collect all liquidity targets sorted by distance
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Arrays to hold waypoint data (parallel arrays for level, name, strength)
    var float[] wpLevels = array.new_float(0)
    var string[] wpNames = array.new_string(0)
    var int[] wpStrength = array.new_int(0)  // Higher = stronger draw

    // Clear previous waypoints
    array.clear(wpLevels)
    array.clear(wpNames)
    array.clear(wpStrength)

    if dolDirection == DIR_BULL
        // Collect all UNSWEPT targets ABOVE current price
        // BSL (60 IPDA) - Strongest draw
        if not na(high60IPDA) and high60IPDA > close
            array.push(wpLevels, high60IPDA)
            array.push(wpNames, "BSL")
            array.push(wpStrength, 100)

        // PWH - Strong weekly level
        if not pwhSwept and not na(pwh) and pwh > close
            array.push(wpLevels, pwh)
            array.push(wpNames, "PWH")
            array.push(wpStrength, 80)

        // PDH - Daily level
        if not pdhSwept and not na(pdh) and pdh > close
            array.push(wpLevels, pdh)
            array.push(wpNames, "PDH")
            array.push(wpStrength, 60)

        // London High - Session level
        if not londonHighSwept and not na(londonHigh) and londonHigh > close and not londonSession
            array.push(wpLevels, londonHigh)
            array.push(wpNames, "LDN")
            array.push(wpStrength, 40)

        // NY High - Session level
        if not nyHighSwept and not na(nyHigh) and nyHigh > close and not (nyAMSession or nyPMSession)
            array.push(wpLevels, nyHigh)
            array.push(wpNames, "NY")
            array.push(wpStrength, 30)

    else if dolDirection == DIR_BEAR
        // Collect all UNSWEPT targets BELOW current price
        // SSL (60 IPDA) - Strongest draw
        if not na(low60IPDA) and low60IPDA < close
            array.push(wpLevels, low60IPDA)
            array.push(wpNames, "SSL")
            array.push(wpStrength, 100)

        // PWL - Strong weekly level
        if not pwlSwept and not na(pwl) and pwl < close
            array.push(wpLevels, pwl)
            array.push(wpNames, "PWL")
            array.push(wpStrength, 80)

        // PDL - Daily level
        if not pdlSwept and not na(pdl) and pdl < close
            array.push(wpLevels, pdl)
            array.push(wpNames, "PDL")
            array.push(wpStrength, 60)

        // London Low - Session level
        if not londonLowSwept and not na(londonLow) and londonLow < close and not londonSession
            array.push(wpLevels, londonLow)
            array.push(wpNames, "LDN")
            array.push(wpStrength, 40)

        // NY Low - Session level
        if not nyLowSwept and not na(nyLow) and nyLow < close and not (nyAMSession or nyPMSession)
            array.push(wpLevels, nyLow)
            array.push(wpNames, "NY")
            array.push(wpStrength, 30)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SORT WAYPOINTS BY DISTANCE (nearest first for the path)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    numWaypoints = array.size(wpLevels)

    // Simple bubble sort by distance from close
    if numWaypoints > 1
        for i = 0 to numWaypoints - 2
            for j = 0 to numWaypoints - i - 2
                dist1 = math.abs(array.get(wpLevels, j) - close)
                dist2 = math.abs(array.get(wpLevels, j + 1) - close)
                if dist1 > dist2
                    // Swap all parallel arrays
                    tempLevel = array.get(wpLevels, j)
                    tempName = array.get(wpNames, j)
                    tempStr = array.get(wpStrength, j)
                    array.set(wpLevels, j, array.get(wpLevels, j + 1))
                    array.set(wpNames, j, array.get(wpNames, j + 1))
                    array.set(wpStrength, j, array.get(wpStrength, j + 1))
                    array.set(wpLevels, j + 1, tempLevel)
                    array.set(wpNames, j + 1, tempName)
                    array.set(wpStrength, j + 1, tempStr)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SMART PULLBACK SYSTEM - Multi-factor retracement analysis
    // Priority: 1) FVG  2) Order Block  3) Liquidity  4) Equilibrium  5) OTE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Limit to max 5 waypoints for clean visualization
    maxWaypoints = math.min(numWaypoints, 5)

    if maxWaypoints > 0
        // Starting point
        prevX = bar_index + 2
        prevY = close
        xSpacingToTarget = 8   // bars to reach target
        xSpacingPullback = 4   // bars for pullback

        // Choose colors based on setup quality
        pathColor = tradeReady ? pacmanYellow : highConf ? pacmanGold : color.new(pacmanCyan, 40)
        pullbackColor = tradeReady ? color.new(pacmanYellow, 40) : highConf ? color.new(pacmanGold, 50) : color.new(pacmanCyan, 60)
        fvgPbColor = color.new(#7C4DFF, 40)   // Purple for FVG pullback
        obPbColor = color.new(#2196F3, 40)    // Blue for OB pullback
        liqPbColor = color.new(#FF9800, 40)   // Orange for liquidity sweep
        suspPbColor = color.new(#00E676, 30)  // Bright green for Suspension Block (highest priority)
        viPbColor = color.new(#E040FB, 40)    // Magenta for Volume Imbalance
        lvPbColor = color.new(#FF1744, 40)    // Red for Liquidity Void
        rejPbColor = color.new(#FFAB00, 35)   // Amber for Rejection Block (ICT hidden gem)
        lwCEPbColor = color.new(#00BFA5, 35)  // Teal for Longest Wick CE (ICT hidden gem)
        wgCEPbColor = color.new(#B388FF, 35)  // Light purple for Wick Gradient CE (ICT notepad)
        pathWidth = tradeReady ? 2 : highConf ? 2 : 1
        pathStyle = tradeReady ? line.style_solid : line.style_dashed

        // Draw Pac-Man at start if trade ready
        if tradeReady
            pacmanIcon = dolDirection == DIR_BULL ? "á—§" : "á—¤"
            pacmanLabel = label.new(bar_index + 1, close, pacmanIcon,
                 style=label.style_none, textcolor=pacmanYellow, size=size.large)
            array.push(dolPathLabels, pacmanLabel)

        // Draw realistic zigzag path through each waypoint
        for i = 0 to maxWaypoints - 1
            wpLevel = array.get(wpLevels, i)
            wpName = array.get(wpNames, i)
            wpStr = array.get(wpStrength, i)

            // Calculate the move from previous point to this target
            moveSize = wpLevel - prevY
            moveHigh = math.max(prevY, wpLevel)
            moveLow = math.min(prevY, wpLevel)

            // â•â•â• STEP 1: Draw line from previous point TO the target â•â•â•
            targetX = prevX + xSpacingToTarget
            targetY = wpLevel

            targetLine = line.new(prevX, prevY, targetX, targetY,
                 color=pathColor, width=pathWidth, style=pathStyle)
            array.push(dolPathLines, targetLine)

            // Draw waypoint marker at target
            if tradeReady
                dotSize = wpStr >= 80 ? size.large : wpStr >= 50 ? size.normal : size.small
                dotLabel = label.new(targetX, targetY, "â—",
                     style=label.style_none, textcolor=pacmanYellow, size=dotSize)
                array.push(dolPathLabels, dotLabel)
            else
                dotLabel = label.new(targetX, targetY, "â€¢",
                     style=label.style_none, textcolor=pathColor, size=size.small)
                array.push(dolPathLabels, dotLabel)

            // Add waypoint name label
            labelY = dolDirection == DIR_BULL ? targetY * 0.9998 : targetY * 1.0002
            nameLabel = label.new(targetX, labelY, wpName,
                 style=label.style_none, textcolor=color.new(pathColor, 20), size=size.tiny, textalign=text.align_center)
            array.push(dolPathLabels, nameLabel)

            // â•â•â• STEP 2: SMART PULLBACK - Find best retracement level â•â•â•
            if i < maxWaypoints - 1
                float pullbackY = na
                string pbReason = ""
                color pbColor = pullbackColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 0: SUSPENSION BLOCK (ICT's MOST POWERFUL PD Array)
                // Single candle with Volume Imbalance at BOTH ends
                // "Being suspended between two volume imbalances" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if dolDirection == DIR_BULL
                    if array.size(bullSuspBlocks) > 0
                        for j = 0 to math.min(array.size(bullSuspBlocks) - 1, 3)
                            sb = array.get(bullSuspBlocks, j)
                            // Unmitigated Suspension Block in our pullback zone
                            if not sb.mitigated and sb.top < targetY and sb.bottom > moveLow
                                pullbackY := sb.top  // Retrace to top of Suspension Block
                                pbReason := "SUSP"
                                pbColor := suspPbColor
                                break
                else if dolDirection == DIR_BEAR
                    if array.size(bearSuspBlocks) > 0
                        for j = 0 to math.min(array.size(bearSuspBlocks) - 1, 3)
                            sb = array.get(bearSuspBlocks, j)
                            if not sb.mitigated and sb.bottom > targetY and sb.top < moveHigh
                                pullbackY := sb.bottom  // Retrace to bottom of Suspension Block
                                pbReason := "SUSP"
                                pbColor := suspPbColor
                                break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 1: Check for unfilled FVG in the pullback zone
                // Price loves to retrace to fill imbalances
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Bullish move - look for bearish FVG (SIBI) below target to fill
                        if array.size(bearFVGs) > 0
                            for j = 0 to math.min(array.size(bearFVGs) - 1, 8)
                                fvg = array.get(bearFVGs, j)
                                // FVG is in our pullback zone (between prevY and targetY)
                                if not fvg.mitigated and fvg.top < targetY and fvg.bottom > moveLow
                                    pullbackY := fvg.top  // Retrace to top of bearish FVG
                                    pbReason := "FVG"
                                    pbColor := fvgPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        // Bearish move - look for bullish FVG (BISI) above target to fill
                        if array.size(bullFVGs) > 0
                            for j = 0 to math.min(array.size(bullFVGs) - 1, 8)
                                fvg = array.get(bullFVGs, j)
                                if not fvg.mitigated and fvg.bottom > targetY and fvg.top < moveHigh
                                    pullbackY := fvg.bottom  // Retrace to bottom of bullish FVG
                                    pbReason := "FVG"
                                    pbColor := fvgPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 2: Volume Imbalance (Gap between consecutive bodies)
                // Strong institutional price action - gap must be filled
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bearVIs) > 0
                            for j = 0 to math.min(array.size(bearVIs) - 1, 5)
                                vi = array.get(bearVIs, j)
                                if not vi.filled and vi.top < targetY and vi.bottom > moveLow
                                    pullbackY := vi.top  // Retrace to top of Volume Imbalance
                                    pbReason := "VI"
                                    pbColor := viPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bullVIs) > 0
                            for j = 0 to math.min(array.size(bullVIs) - 1, 5)
                                vi = array.get(bullVIs, j)
                                if not vi.filled and vi.bottom > targetY and vi.top < moveHigh
                                    pullbackY := vi.bottom  // Retrace to bottom of Volume Imbalance
                                    pbReason := "VI"
                                    pbColor := viPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 3: Check for Order Block to retest
                // Institutions defend their entry points
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Look for bullish OB (support) below target
                        if array.size(bullOBs) > 0
                            for j = 0 to math.min(array.size(bullOBs) - 1, 5)
                                ob = array.get(bullOBs, j)
                                // Fresh or Tested OB in our range
                                if (ob.state == OB_FRESH or ob.state == OB_TESTED) and ob.top < targetY and ob.top > moveLow
                                    pullbackY := ob.top  // Retrace to top of OB
                                    pbReason := "OB"
                                    pbColor := obPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        // Look for bearish OB (resistance) above target
                        if array.size(bearOBs) > 0
                            for j = 0 to math.min(array.size(bearOBs) - 1, 5)
                                ob = array.get(bearOBs, j)
                                if (ob.state == OB_FRESH or ob.state == OB_TESTED) and ob.bottom > targetY and ob.bottom < moveHigh
                                    pullbackY := ob.bottom  // Retrace to bottom of OB
                                    pbReason := "OB"
                                    pbColor := obPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 4: Liquidity Void (Large displacement gap)
                // Price must fill this inefficiency before continuing
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bearLiqVoids) > 0
                            for j = 0 to math.min(array.size(bearLiqVoids) - 1, 3)
                                lv = array.get(bearLiqVoids, j)
                                if not lv.filled and lv.top < targetY and lv.bottom > moveLow
                                    pullbackY := lv.top  // Retrace to top of Liquidity Void
                                    pbReason := "LV"
                                    pbColor := lvPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bullLiqVoids) > 0
                            for j = 0 to math.min(array.size(bullLiqVoids) - 1, 3)
                                lv = array.get(bullLiqVoids, j)
                                if not lv.filled and lv.bottom > targetY and lv.top < moveHigh
                                    pullbackY := lv.bottom  // Retrace to bottom of Liquidity Void
                                    pbReason := "LV"
                                    pbColor := lvPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 5: Check for nearby liquidity to sweep
                // Price hunts stops before continuing
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        // Look for sellside liquidity (equal lows, session lows) to sweep
                        // Check session lows that haven't been swept
                        if not londonLowSwept and not na(londonLow) and londonLow < targetY and londonLow > moveLow
                            pullbackY := londonLow * 0.9998  // Sweep just below
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                        else if not nyLowSwept and not na(nyLow) and nyLow < targetY and nyLow > moveLow
                            pullbackY := nyLow * 0.9998
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                    else if dolDirection == DIR_BEAR
                        // Look for buyside liquidity (equal highs, session highs) to sweep
                        if not londonHighSwept and not na(londonHigh) and londonHigh > targetY and londonHigh < moveHigh
                            pullbackY := londonHigh * 1.0002  // Sweep just above
                            pbReason := "LIQ"
                            pbColor := liqPbColor
                        else if not nyHighSwept and not na(nyHigh) and nyHigh > targetY and nyHigh < moveHigh
                            pullbackY := nyHigh * 1.0002
                            pbReason := "LIQ"
                            pbColor := liqPbColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 6: REJECTION BLOCK (ICT Hidden Gem)
                // Single candle close rejection - different from Order Block
                // "This is the close that gets REJECTED" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(bullRejBlocks) > 0
                            for j = 0 to math.min(array.size(bullRejBlocks) - 1, 5)
                                rb = array.get(bullRejBlocks, j)
                                if not rb.mitigated and rb.level < targetY and rb.level > moveLow
                                    pullbackY := rb.level  // Retrace to rejection level
                                    pbReason := "REJ"
                                    pbColor := rejPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(bearRejBlocks) > 0
                            for j = 0 to math.min(array.size(bearRejBlocks) - 1, 5)
                                rb = array.get(bearRejBlocks, j)
                                if not rb.mitigated and rb.level > targetY and rb.level < moveHigh
                                    pullbackY := rb.level  // Retrace to rejection level
                                    pbReason := "REJ"
                                    pbColor := rejPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 7: LONGEST WICK CE (ICT Hidden Gem)
                // "Find THE longest wick, use ONLY its CE" - ICT
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if not na(longestWickCE) and longestWickDirection != 0
                        // Use longest wick CE if it's in our pullback zone
                        if dolDirection == DIR_BULL and longestWickCE < targetY and longestWickCE > moveLow
                            pullbackY := longestWickCE
                            pbReason := "LW-CE"
                            pbColor := lwCEPbColor
                        else if dolDirection == DIR_BEAR and longestWickCE > targetY and longestWickCE < moveHigh
                            pullbackY := longestWickCE
                            pbReason := "LW-CE"
                            pbColor := lwCEPbColor

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 8: WICK GRADIENT CE (ICT Notepad System)
                // "0/25/50/75/100% on wicks" - ICT's notepad levels
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    if dolDirection == DIR_BULL
                        if array.size(discountWicks) > 0
                            for j = 0 to math.min(array.size(discountWicks) - 1, 4)
                                wg = array.get(discountWicks, j)
                                if wg.active and wg.wick50 < targetY and wg.wick50 > moveLow
                                    pullbackY := wg.wick50  // Retrace to wick CE (50%)
                                    pbReason := "WG-CE"
                                    pbColor := wgCEPbColor
                                    break
                    else if dolDirection == DIR_BEAR
                        if array.size(premiumWicks) > 0
                            for j = 0 to math.min(array.size(premiumWicks) - 1, 4)
                                wg = array.get(premiumWicks, j)
                                if wg.active and wg.wick50 > targetY and wg.wick50 < moveHigh
                                    pullbackY := wg.wick50  // Retrace to wick CE (50%)
                                    pbReason := "WG-CE"
                                    pbColor := wgCEPbColor
                                    break

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 9: Equilibrium (50%) - Fair value of the move
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    // Check if we're in a strong trend (use shallower pullback)
                    // or ranging (use equilibrium)
                    eqLevel = targetY - (moveSize * 0.5)

                    // Use equilibrium if move was large (strong momentum = shallow retrace)
                    if math.abs(moveSize) > math.abs(targetY * 0.005)  // > 0.5% move
                        pullbackY := eqLevel
                        pbReason := "EQ"

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // PRIORITY 10: OTE Zone (0.618-0.786) - Fallback
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if na(pullbackY)
                    // Dynamic OTE based on volatility
                    // Calm market = deeper retrace (0.79), volatile = shallower (0.62)
                    atrValue = ta.atr(14)
                    volatilityRatio = atrValue / close
                    oteLevel = volatilityRatio > 0.02 ? 0.618 : volatilityRatio > 0.01 ? 0.705 : 0.786

                    pullbackY := targetY - (moveSize * oteLevel)
                    pbReason := "OTE"

                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // DRAW THE PULLBACK
                // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                pullbackX = targetX + xSpacingPullback

                // Draw pullback line
                pullbackLine = line.new(targetX, targetY, pullbackX, pullbackY,
                     color=pbColor, width=1, style=line.style_dotted)
                array.push(dolPathLines, pullbackLine)

                // Pullback marker with reason
                // Marker symbols: SUSP=â˜… VI=â—† LV=â–¼ FVG=â—ˆ OB=â–  LIQ=â—‡ REJ=â— LW-CE=âŠ• WG-CE=âŠ™ EQ=â—¦ OTE=â—‹
                pbMarkerText = pbReason == "SUSP" ? "â˜…" : pbReason == "VI" ? "â—†" : pbReason == "LV" ? "â–¼" : pbReason == "FVG" ? "â—ˆ" : pbReason == "OB" ? "â– " : pbReason == "LIQ" ? "â—‡" : pbReason == "REJ" ? "â—" : pbReason == "LW-CE" ? "âŠ•" : pbReason == "WG-CE" ? "âŠ™" : pbReason == "EQ" ? "â—¦" : "â—‹"
                pbMarker = label.new(pullbackX, pullbackY, pbMarkerText,
                     style=label.style_none, textcolor=pbColor, size=size.tiny)
                array.push(dolPathLabels, pbMarker)

                // Add reason label (tiny, below marker)
                if pbReason != ""
                    reasonY = dolDirection == DIR_BULL ? pullbackY * 0.9997 : pullbackY * 1.0003
                    reasonLabel = label.new(pullbackX, reasonY, pbReason,
                         style=label.style_none, textcolor=color.new(pbColor, 30), size=size.tiny, textalign=text.align_center)
                    array.push(dolPathLabels, reasonLabel)

                // Update previous point to pullback location for next segment
                prevX := pullbackX
                prevY := pullbackY
            else
                // Last waypoint - no pullback needed
                prevX := targetX
                prevY := targetY

        // Add final target marker
        if tradeReady
            finalLabel = label.new(prevX + 3, prevY, "ğŸ¯",
                 style=label.style_none, textcolor=pacmanYellow, size=size.normal)
            array.push(dolPathLabels, finalLabel)

    else
        // No waypoints found - draw simple arrow to dolTarget if available
        if not na(dolTarget) and dolDirection != DIR_NEUTRAL
            arrowColor = dolDirection == DIR_BULL ? color.new(i_bullColor, 50) : color.new(i_bearColor, 50)
            simpleLine = line.new(bar_index + 2, close, bar_index + 14, dolTarget,
                 color=arrowColor, width=1, style=line.style_arrow_right)
            array.push(dolPathLines, simpleLine)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY TARGETS (Institutional Levels) - Clean minimal
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var label cherryHighLabel = na
var label cherryLowLabel = na
var line bslLine = na
var line sslLine = na

if i_showPacMan and barstate.islast
    if not na(cherryHighLabel)
        label.delete(cherryHighLabel)
    if not na(cherryLowLabel)
        label.delete(cherryLowLabel)
    if not na(bslLine)
        line.delete(bslLine)
    if not na(sslLine)
        line.delete(sslLine)

    // BSL - label UNDER line, right-aligned (right column at +20)
    bslLine := line.new(bar_index - 40, high60IPDA, bar_index + 20, high60IPDA,
         color=color.new(#FF5252, 20), width=2, style=line.style_dashed)
    float bslOffset = (high60IPDA - low60IPDA) * 0.015
    cherryHighLabel := label.new(bar_index + 20, high60IPDA - bslOffset, "ğŸ’ BSL",
         style=label.style_none, textcolor=color.new(#FF5252, 0), size=size.small, textalign=text.align_right)

    // SSL - label UNDER line, right-aligned (right column at +20)
    sslLine := line.new(bar_index - 40, low60IPDA, bar_index + 20, low60IPDA,
         color=color.new(#69F0AE, 20), width=2, style=line.style_dashed)
    cherryLowLabel := label.new(bar_index + 20, low60IPDA - bslOffset, "ğŸ’ SSL",
         style=label.style_none, textcolor=color.new(#69F0AE, 0), size=size.small, textalign=text.align_right)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LIQUIDITY SEQUENCING - Visual Lines + Distance Labels (Column +40)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var line pdhLine = na
var line pdlLine = na
var line pwhLine = na
var line pwlLine = na
var line londonHiLine = na
var line londonLoLine = na
var label pdhLabel = na
var label pdlLabel = na
var label pwhLabel = na
var label pwlLabel = na
var label londonHiLabel = na
var label londonLoLabel = na

if barstate.islast
    // Cleanup previous liquidity lines/labels
    if not na(pdhLine)
        line.delete(pdhLine)
    if not na(pdlLine)
        line.delete(pdlLine)
    if not na(pwhLine)
        line.delete(pwhLine)
    if not na(pwlLine)
        line.delete(pwlLine)
    if not na(londonHiLine)
        line.delete(londonHiLine)
    if not na(londonLoLine)
        line.delete(londonLoLine)
    if not na(pdhLabel)
        label.delete(pdhLabel)
    if not na(pdlLabel)
        label.delete(pdlLabel)
    if not na(pwhLabel)
        label.delete(pwhLabel)
    if not na(pwlLabel)
        label.delete(pwlLabel)
    if not na(londonHiLabel)
        label.delete(londonHiLabel)
    if not na(londonLoLabel)
        label.delete(londonLoLabel)

    // Colors - swept levels are dimmed, active levels are bright
    pdhColor = pdhSwept ? color.new(#FF9800, 70) : color.new(#FF9800, 30)
    pdlColor = pdlSwept ? color.new(#FF9800, 70) : color.new(#FF9800, 30)
    pwhColor = pwhSwept ? color.new(#E040FB, 70) : color.new(#E040FB, 30)
    pwlColor = pwlSwept ? color.new(#E040FB, 70) : color.new(#E040FB, 30)
    ldnColor = color.new(#2196F3, 40)

    // Calculate pip distances (assuming forex with 4/5 decimal places)
    float pipMult = syminfo.mintick >= 0.01 ? 1 : 10  // Adjust for JPY pairs
    float pdhDist = not na(pdh) ? (pdh - close) / syminfo.mintick / pipMult : na
    float pdlDist = not na(pdl) ? (pdl - close) / syminfo.mintick / pipMult : na
    float pwhDist = not na(pwh) ? (pwh - close) / syminfo.mintick / pipMult : na
    float pwlDist = not na(pwl) ? (pwl - close) / syminfo.mintick / pipMult : na
    float ldnHiDist = not na(londonHigh) ? (londonHigh - close) / syminfo.mintick / pipMult : na
    float ldnLoDist = not na(londonLow) ? (londonLow - close) / syminfo.mintick / pipMult : na

    // Line style for swept vs active
    sweptStyle = line.style_dotted
    activeStyle = line.style_dashed

    // PDH - Previous Day High
    if not na(pdh)
        pdhLine := line.new(bar_index - 20, pdh, bar_index + 40, pdh,
             color=pdhColor, width=1, style=pdhSwept ? sweptStyle : activeStyle)
        pdhText = pdhSwept ? "Ì¶PÌ¶DÌ¶HÌ¶ âœ—" : "PDH " + str.tostring(pdhDist, "#") + "p"
        pdhLabel := label.new(bar_index + 40, pdh, pdhText,
             style=label.style_none, textcolor=pdhColor, size=size.tiny, textalign=text.align_left)

    // PDL - Previous Day Low
    if not na(pdl)
        pdlLine := line.new(bar_index - 20, pdl, bar_index + 40, pdl,
             color=pdlColor, width=1, style=pdlSwept ? sweptStyle : activeStyle)
        pdlText = pdlSwept ? "Ì¶PÌ¶DÌ¶LÌ¶ âœ—" : "PDL " + str.tostring(pdlDist, "#") + "p"
        pdlLabel := label.new(bar_index + 40, pdl, pdlText,
             style=label.style_none, textcolor=pdlColor, size=size.tiny, textalign=text.align_left)

    // PWH - Previous Week High
    if not na(pwh)
        pwhLine := line.new(bar_index - 20, pwh, bar_index + 40, pwh,
             color=pwhColor, width=1, style=pwhSwept ? sweptStyle : activeStyle)
        pwhText = pwhSwept ? "Ì¶PÌ¶WÌ¶HÌ¶ âœ—" : "PWH " + str.tostring(pwhDist, "#") + "p"
        pwhLabel := label.new(bar_index + 40, pwh, pwhText,
             style=label.style_none, textcolor=pwhColor, size=size.tiny, textalign=text.align_left)

    // PWL - Previous Week Low
    if not na(pwl)
        pwlLine := line.new(bar_index - 20, pwl, bar_index + 40, pwl,
             color=pwlColor, width=1, style=pwlSwept ? sweptStyle : activeStyle)
        pwlText = pwlSwept ? "Ì¶PÌ¶WÌ¶LÌ¶ âœ—" : "PWL " + str.tostring(pwlDist, "#") + "p"
        pwlLabel := label.new(bar_index + 40, pwl, pwlText,
             style=label.style_none, textcolor=pwlColor, size=size.tiny, textalign=text.align_left)

    // London High (only show if not in London session)
    if not na(londonHigh) and not londonSession
        ldnHiColor = londonHighSwept ? color.new(#2196F3, 70) : ldnColor
        londonHiLine := line.new(bar_index - 10, londonHigh, bar_index + 40, londonHigh,
             color=ldnHiColor, width=1, style=londonHighSwept ? sweptStyle : line.style_dotted)
        ldnHiText = londonHighSwept ? "Ì¶LÌ¶DÌ¶NÌ¶ Ì¶HÌ¶iÌ¶ âœ—" : "LDN Hi " + str.tostring(ldnHiDist, "#") + "p"
        londonHiLabel := label.new(bar_index + 40, londonHigh, ldnHiText,
             style=label.style_none, textcolor=ldnHiColor, size=size.tiny, textalign=text.align_left)

    // London Low (only show if not in London session)
    if not na(londonLow) and not londonSession
        ldnLoColor = londonLowSwept ? color.new(#2196F3, 70) : ldnColor
        londonLoLine := line.new(bar_index - 10, londonLow, bar_index + 40, londonLow,
             color=ldnLoColor, width=1, style=londonLowSwept ? sweptStyle : line.style_dotted)
        ldnLoText = londonLowSwept ? "Ì¶LÌ¶DÌ¶NÌ¶ Ì¶LÌ¶oÌ¶ âœ—" : "LDN Lo " + str.tostring(ldnLoDist, "#") + "p"
        londonLoLabel := label.new(bar_index + 40, londonLow, ldnLoText,
             style=label.style_none, textcolor=ldnLoColor, size=size.tiny, textalign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COMPOSITE TIER SIGNALS (Only on TRUE high-confluence events)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tier 1 requires ACTUAL confluence events, not just high probability
// Must have at least one of these triggers: Model2022, TurtleSoup, Judas, or CHoCH
hasTriggerEvent = model2022Bull or model2022Bear or bullishTS or bearishTS or bullishJudas or bearishJudas or bullishCHoCH or bearishCHoCH or unicornBull or unicornBear or mmxmBullConfirm or mmxmBearConfirm or amdFractalBull or amdFractalBear

tier1Bull = i_showComposite and compositeTier == TIER_1 and dolDirection == DIR_BULL and hasTriggerEvent
tier1Bear = i_showComposite and compositeTier == TIER_1 and dolDirection == DIR_BEAR and hasTriggerEvent
tier2Bull = i_showComposite and compositeTier == TIER_2 and dolDirection == DIR_BULL
tier2Bear = i_showComposite and compositeTier == TIER_2 and dolDirection == DIR_BEAR

// Tier 1 ELITE signals - clean badge style (only on trigger events)
plotshape(tier1Bull and barstate.isconfirmed, title="ELITE Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#00C853, 0), text="ELITE â–²", textcolor=color.white, size=size.small)
plotshape(tier1Bear and barstate.isconfirmed, title="ELITE Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#FF1744, 0), text="ELITE â–¼", textcolor=color.white, size=size.small)

// Tier 2 PREMIUM signals
plotshape(tier2Bull and barstate.isconfirmed and not tier1Bull, title="PREMIUM Bull", style=shape.labelup,
     location=location.belowbar, color=color.new(#69F0AE, 0), text="PREMIUM â–²", textcolor=color.white, size=size.tiny)
plotshape(tier2Bear and barstate.isconfirmed and not tier1Bear, title="PREMIUM Bear", style=shape.labeldown,
     location=location.abovebar, color=color.new(#69F0AE, 0), text="PREMIUM â–¼", textcolor=color.white, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ENTRY ZONE BOX & TARGET ARROW (For ELITE/PREMIUM setups)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var box entryZoneBox = na
var line targetArrow = na
var label targetLabel = na
var label entryLabel = na

// Only show entry zone for high-tier setups on last bar
if i_showComposite and barstate.islast and (compositeTier == TIER_1 or compositeTier == TIER_2)
    // Clean up previous drawings
    if not na(entryZoneBox)
        box.delete(entryZoneBox)
    if not na(targetArrow)
        line.delete(targetArrow)
    if not na(targetLabel)
        label.delete(targetLabel)
    if not na(entryLabel)
        label.delete(entryLabel)

    // Determine entry zone boundaries (OTE zone) - using rangeHigh/rangeLow from P/D calculation
    entryRange = rangeHigh - rangeLow
    ote62 = dolDirection == DIR_BULL ? rangeLow + entryRange * 0.62 : rangeHigh - entryRange * 0.62
    ote79 = dolDirection == DIR_BULL ? rangeLow + entryRange * 0.79 : rangeHigh - entryRange * 0.79

    // Entry zone box GLOW effect (bright, vibrant colors)
    entryBoxColor = compositeTier == TIER_1 ? color.new(#00FF88, 70) : color.new(#00E676, 75)
    entryBorderColor = compositeTier == TIER_1 ? color.new(#00FF88, 0) : color.new(#00E676, 10)

    // Draw entry zone box with pattern name inside
    patternTextColor = compositeTier == TIER_1 ? #00FF88 : #00E676

    if dolDirection == DIR_BULL
        entryZoneBox := box.new(bar_index - 15, ote79, bar_index + 3, ote62,
             bgcolor=entryBoxColor, border_color=entryBorderColor, border_width=2,
             text=patternName, text_color=patternTextColor, text_size=size.small,
             text_halign=text.align_center, text_valign=text.align_top)
        entryLabel := label.new(bar_index + 4, ote62, "ENTRY",
             style=label.style_none, textcolor=color.new(entryBorderColor, 30), size=size.tiny)
    else if dolDirection == DIR_BEAR
        entryZoneBox := box.new(bar_index - 15, ote62, bar_index + 3, ote79,
             bgcolor=entryBoxColor, border_color=entryBorderColor, border_width=2,
             text=patternName, text_color=patternTextColor, text_size=size.small,
             text_halign=text.align_center, text_valign=text.align_top)
        entryLabel := label.new(bar_index + 4, ote62, "ENTRY",
             style=label.style_none, textcolor=color.new(entryBorderColor, 30), size=size.tiny)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STOP LOSS & RISK:REWARD CALCULATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Find optimal stop loss level
    float stopLoss = na
    string slReason = ""

    if dolDirection == DIR_BULL
        // For longs, SL below: OB low, FVG low, recent swing low, or OTE bottom
        slCandidate1 = ote62 - (entryRange * 0.05)  // Just below OTE
        slCandidate2 = na(lastBullRejLevel) ? slCandidate1 : lastBullRejLevel * 0.999

        // Check for nearby OB to place SL below
        if array.size(bullOBs) > 0
            for i = 0 to math.min(array.size(bullOBs) - 1, 3)
                ob = array.get(bullOBs, i)
                if ob.state == OB_TESTED and ob.bottom < ote62 and ob.bottom > rangeLow
                    stopLoss := ob.bottom * 0.999
                    slReason := "OB"
                    break

        if na(stopLoss)
            stopLoss := slCandidate1
            slReason := "OTE"

    else if dolDirection == DIR_BEAR
        // For shorts, SL above: OB high, FVG high, recent swing high, or OTE top
        slCandidate1 = ote62 + (entryRange * 0.05)  // Just above OTE
        slCandidate2 = na(lastBearRejLevel) ? slCandidate1 : lastBearRejLevel * 1.001

        // Check for nearby OB to place SL above
        if array.size(bearOBs) > 0
            for i = 0 to math.min(array.size(bearOBs) - 1, 3)
                ob = array.get(bearOBs, i)
                if ob.state == OB_TESTED and ob.top > ote62 and ob.top < rangeHigh
                    stopLoss := ob.top * 1.001
                    slReason := "OB"
                    break

        if na(stopLoss)
            stopLoss := slCandidate1
            slReason := "OTE"

    // Calculate Risk:Reward
    entryPrice = (ote62 + ote79) / 2  // Middle of OTE
    riskPips = math.abs(entryPrice - stopLoss)
    rewardPips = math.abs(dolTarget - entryPrice)
    riskReward = riskPips > 0 ? rewardPips / riskPips : 0

    // Draw target arrow to liquidity
    targetArrowColor = dolDirection == DIR_BULL ? color.new(#00E676, 20) : color.new(#FF1744, 20)

    if dolDirection == DIR_BULL and not na(dolTarget)
        targetArrow := line.new(bar_index, close, bar_index + 8, dolTarget,
             color=targetArrowColor, width=2, style=line.style_arrow_right)
        targetLabel := label.new(bar_index + 9, dolTarget, "TARGET\n" + str.tostring(dolTarget, format.mintick),
             style=label.style_none, textcolor=targetArrowColor, size=size.tiny)
    else if dolDirection == DIR_BEAR and not na(dolTarget)
        targetArrow := line.new(bar_index, close, bar_index + 8, dolTarget,
             color=targetArrowColor, width=2, style=line.style_arrow_right)
        targetLabel := label.new(bar_index + 9, dolTarget, "TARGET\n" + str.tostring(dolTarget, format.mintick),
             style=label.style_none, textcolor=targetArrowColor, size=size.tiny)

    // Draw Stop Loss line
    var line slLine = na
    var label slLabel = na
    if not na(slLine)
        line.delete(slLine)
    if not na(slLabel)
        label.delete(slLabel)

    if not na(stopLoss)
        slLineColor = color.new(#FF5252, 30)
        slLine := line.new(bar_index - 15, stopLoss, bar_index + 3, stopLoss,
             color=slLineColor, width=1, style=line.style_dashed)
        slLabel := label.new(bar_index + 4, stopLoss, "SL (" + slReason + ")",
             style=label.style_none, textcolor=slLineColor, size=size.tiny)

    // Draw R:R label
    var label rrLabel = na
    if not na(rrLabel)
        label.delete(rrLabel)

    rrColor = riskReward >= 3.0 ? #00E676 : riskReward >= 2.0 ? #69F0AE : riskReward >= 1.5 ? #FFD740 : #FF9800
    rrText = "R:R " + str.tostring(riskReward, "#.#") + ":1"
    rrLabel := label.new(bar_index - 18, entryPrice, rrText,
         style=label.style_none, textcolor=color.new(rrColor, 0), size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOL PROBABILITY DASHBOARD (GOD MODE INFO TABLE) - SLEEK ARCADE DESIGN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Sleek dark arcade background colors
var color tableBg = color.new(#0D0D0D, 5)
var color tableBgAlt = color.new(#1A1A2E, 10)
var color headerBg = color.new(#16213E, 0)
var color accentLine = color.new(#0F3460, 0)
var color textDim = color.new(#8892B0, 0)
var color textBright = color.new(#E6F1FF, 0)

var table infoTable = table.new(position.middle_right, 2, 22, bgcolor=tableBg, border_width=0, border_color=color.new(#1A1A2E, 50), frame_width=2, frame_color=color.new(#0F3460, 30))

if i_showDOLTable and barstate.islast
    // â•â•â• HEADER - Merged and centered â•â•â•
    probColor = compositeScore >= 70 ? i_bullColor : compositeScore >= 50 ? i_neutralColor : i_bearColor
    headerText = "â—‰ ATLAS PRO " + str.tostring(compositeScore, "#") + "%"
    table.cell(infoTable, 0, 0, headerText, text_color=i_pacmanColor, text_size=size.normal, bgcolor=headerBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // â•â•â• DIRECTION ROW - Main signal â•â•â•
    dirText = dolDirection == DIR_BULL ? "â–² LONG" : dolDirection == DIR_BEAR ? "â–¼ SHORT" : "â—† NEUTRAL"
    dirColor = dolDirection == DIR_BULL ? i_bullColor : dolDirection == DIR_BEAR ? i_bearColor : i_neutralColor
    dirBg = dolDirection == DIR_BULL ? color.new(i_bullColor, 85) : dolDirection == DIR_BEAR ? color.new(i_bearColor, 85) : color.new(i_neutralColor, 90)
    table.cell(infoTable, 0, 1, dirText, text_color=dirColor, text_size=size.normal, bgcolor=dirBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 1, 1, 1)

    // â•â•â• MTF BIAS (ICT Multi-Timeframe) â•â•â•
    wArrow = mtfBiasW == 1 ? "â†‘" : mtfBiasW == -1 ? "â†“" : "â€”"
    dArrow = mtfBiasD == 1 ? "â†‘" : mtfBiasD == -1 ? "â†“" : "â€”"
    h1Arrow = mtfBias1H == 1 ? "â†‘" : mtfBias1H == -1 ? "â†“" : "â€”"
    m15Arrow = mtfBias15m == 1 ? "â†‘" : mtfBias15m == -1 ? "â†“" : "â€”"
    m5Arrow = mtfBias5m == 1 ? "â†‘" : mtfBias5m == -1 ? "â†“" : "â€”"

    bullCount = (mtfBiasW == 1 ? 1 : 0) + (mtfBiasD == 1 ? 1 : 0) + (mtfBias1H == 1 ? 1 : 0) + (mtfBias15m == 1 ? 1 : 0) + (mtfBias5m == 1 ? 1 : 0)
    bearCount = (mtfBiasW == -1 ? 1 : 0) + (mtfBiasD == -1 ? 1 : 0) + (mtfBias1H == -1 ? 1 : 0) + (mtfBias15m == -1 ? 1 : 0) + (mtfBias5m == -1 ? 1 : 0)
    mtfAligned = bullCount >= 4 or bearCount >= 4
    mtfColor = mtfAligned ? (bullCount > bearCount ? i_bullColor : i_bearColor) : textDim

    mtfDisplay = "W" + wArrow + " D" + dArrow + " 1H" + h1Arrow + " 15m" + m15Arrow + " 5m" + m5Arrow
    table.cell(infoTable, 0, 2, "MTF Bias", text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_left)
    table.cell(infoTable, 1, 2, mtfDisplay, text_color=mtfColor, text_size=size.small, bgcolor=tableBgAlt, text_halign=text.align_right)

    // â•â•â• ZONE â•â•â•
    zoneText = inPremium ? "PREMIUM â–²" : inDiscount ? "DISCOUNT â–¼" : inOTE ? "â—‰ OTE" : "EQUILIBRIUM"
    zoneColor = inPremium ? i_bearColor : inDiscount ? i_bullColor : inOTE ? color.new(#00BCD4, 0) : textDim
    zoneBg = inOTE ? color.new(#00BCD4, 90) : tableBg
    table.cell(infoTable, 0, 3, "Zone", text_color=textDim, text_size=size.tiny, bgcolor=zoneBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 3, zoneText, text_color=zoneColor, text_size=size.small, bgcolor=zoneBg, text_halign=text.align_right)

    // â•â•â• PATTERN NAME - Featured (5-Tier Colors) â•â•â•
    patternColor = compositeTier == TIER_1 ? #00E676 : compositeTier == TIER_2 ? #69F0AE : compositeTier == TIER_3 ? #FFD740 : compositeTier == TIER_4 ? #FF9800 : #FF5252
    patternBg = compositeTier == TIER_1 ? color.new(#00E676, 88) : compositeTier == TIER_2 ? color.new(#69F0AE, 90) : tableBgAlt
    cleanPattern = str.replace_all(str.replace_all(str.replace_all(str.replace_all(str.replace_all(str.replace_all(patternName, "ğŸ’ ", ""), "ğŸ† ", ""), "â­ ", ""), "ğŸ¥ˆ ", ""), "ğŸ¥‰ ", ""), "âš ï¸ ", "")
    table.cell(infoTable, 0, 4, cleanPattern, text_color=patternColor, text_size=size.small, bgcolor=patternBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 4, 1, 4)

    // â•â•â• TURTLE SOUP STAGE â•â•â•
    tsText = tsStage == "STALK_HIGH" or tsStage == "STALK_LOW" ? "â— STALK" : tsStage == "TRAP" ? "â—‰ TRAP" : tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" ? "âœ“ CONFIRM" : tsStage == "INVALID" ? "âœ— INVALID" : "â€”"
    tsColor = tsStage == "CONFIRM_BULL" or tsStage == "CONFIRM_BEAR" ? i_bullColor : tsStage == "TRAP" ? i_liqColor : tsStage == "STALK_HIGH" or tsStage == "STALK_LOW" ? i_neutralColor : textDim
    table.cell(infoTable, 0, 5, "Turtle Soup", text_color=textDim, text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 5, tsText, text_color=tsColor, text_size=size.small, bgcolor=tableBg, text_halign=text.align_right)

    // â•â•â• AMD PHASE (Judas-Aware) â•â•â•
    amdIcon = amdPhase == 1 ? "â—" : amdPhase == 2 ? "â—‰" : amdPhase == 3 ? "â—" : "â—‹"
    amdShortStatus = amdPhase == 1 ? "ACCUM" :
                     amdPhase == 2 and asianHighSwept ? "JUDAS â–²" :
                     amdPhase == 2 and asianLowSwept ? "JUDAS â–¼" :
                     amdPhase == 2 ? "WATCH" :
                     amdPhase == 3 and manipulationComplete ? (expectedDirection == 1 ? "DIST â–²" : "DIST â–¼") :
                     amdPhase == 3 ? "DIST" : "â€”"
    amdDisplayColor = manipulationComplete ? (expectedDirection == 1 ? i_bullColor : i_bearColor) :
                      asianHighSwept ? i_bearColor : asianLowSwept ? i_bullColor : i_pacmanColor
    amdBg = manipulationComplete ? color.new(amdDisplayColor, 88) : tableBgAlt
    table.cell(infoTable, 0, 6, "AMD", text_color=textDim, text_size=size.tiny, bgcolor=amdBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 6, amdIcon + " " + amdShortStatus, text_color=amdDisplayColor, text_size=size.small, bgcolor=amdBg, text_halign=text.align_right)

    // â•â•â• SESSION / KILLZONE â•â•â•
    sessName = asianSession ? "ASIA" : londonSession ? "LONDON" : nyAMSession ? "NY-AM" : nyPMSession ? "NY-PM" : "OFF"
    kzActive = inSilverBullet or nyAMKZ or nyPMKZ or londonKZ
    kzIndicator = inSilverBullet ? " â—‰ SB" : kzActive ? " â—‰ KZ" : ""
    sessDisplay = sessName + kzIndicator
    sessKzColor = inSilverBullet ? color.new(#00E5FF, 0) : i_pacmanColor
    table.cell(infoTable, 0, 7, "Session", text_color=textDim, text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 7, sessDisplay, text_color=kzActive ? sessKzColor : textDim, text_size=size.small, bgcolor=tableBg, text_halign=text.align_right)

    // â•â•â• CONFLUENCE â•â•â•
    confDisplay = str.tostring(confluenceCount) + "/16"
    confColor = confluenceCount >= 10 ? #00E676 : confluenceCount >= 7 ? #69F0AE : confluenceCount >= 5 ? #FFD740 : textDim
    table.cell(infoTable, 0, 8, "Confluence", text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_left)
    table.cell(infoTable, 1, 8, confDisplay, text_color=confColor, text_size=size.small, bgcolor=tableBgAlt, text_halign=text.align_right)

    // â•â•â• PRIMARY DOL TARGET â•â•â•
    float pipMult2 = syminfo.mintick >= 0.01 ? 1 : 10
    float dolDist = not na(dolTarget) ? (dolTarget - close) / syminfo.mintick / pipMult2 : na
    dolTargetText = not na(dolTarget) ? str.tostring(dolTarget, format.mintick) + " (" + str.tostring(dolDist, "#") + "p)" : "â€”"
    table.cell(infoTable, 0, 9, "DOL Target", text_color=textDim, text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 9, dolTargetText, text_color=dirColor, text_size=size.small, bgcolor=tableBg, text_halign=text.align_right)

    // â•â•â• LIQUIDITY SEQUENCE (Next targets) â•â•â•
    // Build target list based on direction
    liqSeq = ""
    if dolDirection == DIR_BULL
        // Show upside targets: nearest first
        if not pdhSwept and not na(pdh) and pdh > close
            liqSeq := liqSeq + "PDH "
        if not pwhSwept and not na(pwh) and pwh > close
            liqSeq := liqSeq + "PWH "
        if not londonHighSwept and not na(londonHigh) and londonHigh > close and not londonSession
            liqSeq := liqSeq + "LDNâ†‘ "
    else if dolDirection == DIR_BEAR
        // Show downside targets: nearest first
        if not pdlSwept and not na(pdl) and pdl < close
            liqSeq := liqSeq + "PDL "
        if not pwlSwept and not na(pwl) and pwl < close
            liqSeq := liqSeq + "PWL "
        if not londonLowSwept and not na(londonLow) and londonLow < close and not londonSession
            liqSeq := liqSeq + "LDNâ†“ "
    liqSeq := liqSeq == "" ? "â€”" : liqSeq
    liqSeqColor = dolDirection == DIR_BULL ? i_bullColor : dolDirection == DIR_BEAR ? i_bearColor : textDim
    table.cell(infoTable, 0, 10, "Liq Path", text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_left)
    table.cell(infoTable, 1, 10, liqSeq, text_color=liqSeqColor, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_right)

    // â•â•â• SWEPT LIQUIDITY â•â•â•
    sweptLiq = ""
    if pdhSwept
        sweptLiq := sweptLiq + "PÌ¶DÌ¶HÌ¶ "
    if pdlSwept
        sweptLiq := sweptLiq + "PÌ¶DÌ¶LÌ¶ "
    if pwhSwept
        sweptLiq := sweptLiq + "PÌ¶WÌ¶HÌ¶ "
    if pwlSwept
        sweptLiq := sweptLiq + "PÌ¶WÌ¶LÌ¶ "
    if londonHighSwept
        sweptLiq := sweptLiq + "LÌ¶DÌ¶NÌ¶â†‘ "
    if londonLowSwept
        sweptLiq := sweptLiq + "LÌ¶DÌ¶NÌ¶â†“ "
    if asianHighSwept
        sweptLiq := sweptLiq + "AÌ¶SÌ¶NÌ¶â†‘ "
    if asianLowSwept
        sweptLiq := sweptLiq + "AÌ¶SÌ¶NÌ¶â†“ "
    sweptLiq := sweptLiq == "" ? "None" : sweptLiq
    table.cell(infoTable, 0, 11, "Swept", text_color=textDim, text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 11, sweptLiq, text_color=color.new(#FF5252, 30), text_size=size.tiny, bgcolor=tableBg, text_halign=text.align_right)

    // â•â•â• KEY FACTORS â•â•â•
    table.cell(infoTable, 0, 12, dolReason, text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 12, 1, 12)

    // â•â•â• TIER INDICATOR BAR (5-Tier System) â•â•â•
    tierLabel = compositeTier == TIER_1 ? "ELITE" : compositeTier == TIER_2 ? "PREMIUM" : compositeTier == TIER_3 ? "STRONG" : compositeTier == TIER_4 ? "MODERATE" : "WEAK"
    tierBar = compositeTier == TIER_1 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ " + tierLabel : compositeTier == TIER_2 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ " + tierLabel : compositeTier == TIER_3 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ " + tierLabel : compositeTier == TIER_4 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘ " + tierLabel : "â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ " + tierLabel
    tierColor = compositeTier == TIER_1 ? #00E676 : compositeTier == TIER_2 ? #69F0AE : compositeTier == TIER_3 ? #FFD740 : compositeTier == TIER_4 ? #FF9800 : #FF5252
    table.cell(infoTable, 0, 13, tierBar, text_color=tierColor, text_size=size.tiny, bgcolor=headerBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 13, 1, 13)

    // â•â•â• TIME WINDOW (Silver Bullet + Macro) â•â•â•
    timeWindow = inSilverBullet ? "â—‰ SILVER BULLET " + sbPhase :
                 isMacroTime ? "â—‰ MACRO " + macroType :
                 isPowerHour ? "â—‰ POWER HOUR" : "â€”"
    timeColor = sbPrime ? #00E5FF : inSilverBullet ? color.new(#00E5FF, 30) : isMacroTime ? #FFD740 : isPowerHour ? #FF9800 : textDim
    timeBg = sbPrime ? color.new(#00E5FF, 85) : tableBg
    table.cell(infoTable, 0, 14, "Time", text_color=textDim, text_size=size.tiny, bgcolor=timeBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 14, timeWindow, text_color=timeColor, text_size=size.small, bgcolor=timeBg, text_halign=text.align_right)

    // â•â•â• DAY TYPE (Seek & Destroy etc.) â•â•â•
    dayType = isSeekDestroyDay ? "âš¡ SEEK & DESTROY" : isExpansionDay ? "ğŸ“ˆ EXPANSION" : isAccumulationDay ? "ğŸ“Š ACCUMULATION" : "â€”"
    dayTypeColor = isSeekDestroyDay ? #FF9800 : isExpansionDay ? #69F0AE : isAccumulationDay ? #00BCD4 : textDim
    table.cell(infoTable, 0, 15, "Day", text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_left)
    table.cell(infoTable, 1, 15, dayType, text_color=dayTypeColor, text_size=size.small, bgcolor=tableBgAlt, text_halign=text.align_right)

    // â•â•â• PD ARRAY STATUS (Suspension Block, VI, Liquidity Void, NDOG, ORG) â•â•â•
    // Build PD Array status display
    pdArrayStatus = ""
    pdArrayCount2 = 0
    if hasSuspensionBlock
        pdArrayStatus := pdArrayStatus + "â˜…SB "
        pdArrayCount2 += 1
    if hasVolumeImbalance
        pdArrayStatus := pdArrayStatus + "â—†VI "
        pdArrayCount2 += 1
    if hasLiquidityVoid
        pdArrayStatus := pdArrayStatus + "â–¼LV "
        pdArrayCount2 += 1
    if not na(ndogHigh) and not ndogFilled
        pdArrayStatus := pdArrayStatus + "â¬šNDOG "
        pdArrayCount2 += 1
    if not na(orgHigh) and close > orgLow and close < orgHigh
        pdArrayStatus := pdArrayStatus + "â¬›ORG "
        pdArrayCount2 += 1
    if hasRejectionBlock
        pdArrayStatus := pdArrayStatus + "â¬¡RB "
        pdArrayCount2 += 1

    pdArrayDisplay = pdArrayCount2 > 0 ? pdArrayStatus : "â€”"
    pdArrayColor = pdArrayCount2 >= 3 ? #00E676 : pdArrayCount2 >= 2 ? #69F0AE : pdArrayCount2 >= 1 ? #FFD740 : textDim
    pdArrayBg = hasSuspensionBlock ? color.new(#00E676, 85) : tableBg
    table.cell(infoTable, 0, 16, "PD Arrays", text_color=textDim, text_size=size.tiny, bgcolor=pdArrayBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 16, pdArrayDisplay, text_color=pdArrayColor, text_size=size.tiny, bgcolor=pdArrayBg, text_halign=text.align_right)

    // â•â•â• R:R DISPLAY (if Stop Loss calculated) â•â•â•
    rrDisplayText = not na(stopLoss) ? "SL:" + str.tostring(stopLoss, format.mintick) + " R:R " + str.tostring(riskReward, "#.#") : "â€”"
    rrDisplayColor = riskReward >= 3 ? #00E676 : riskReward >= 2 ? #69F0AE : riskReward >= 1 ? #FFD740 : textDim
    table.cell(infoTable, 0, 17, "Risk", text_color=textDim, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_left)
    table.cell(infoTable, 1, 17, rrDisplayText, text_color=rrDisplayColor, text_size=size.tiny, bgcolor=tableBgAlt, text_halign=text.align_right)

    // â•â•â• MARKET CONDITION (High/Low Resistance Liquidity Run) â•â•â•
    mktCondText = isJaggedMarket ? "âš¡ HIGH RES" : isSmoothMarket ? "ğŸŒŠ LOW RES" : "â€” NEUTRAL"
    mktCondColor = isJaggedMarket ? #FF9800 : isSmoothMarket ? #00E676 : textDim
    mktCondBg = isJaggedMarket ? color.new(#FF9800, 90) : isSmoothMarket ? color.new(#00E676, 90) : tableBg
    table.cell(infoTable, 0, 18, "Market", text_color=textDim, text_size=size.tiny, bgcolor=mktCondBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 18, mktCondText, text_color=mktCondColor, text_size=size.tiny, bgcolor=mktCondBg, text_halign=text.align_right)

    // â•â•â• TIME RISK (ICT's Weekly Rhythm) â•â•â•
    timeRiskText = timeRiskReason != "" ? timeRiskReason + " " + str.tostring(timeRiskMultiplier, "#.#") + "x" : "â€”"
    timeRiskColor = isHighProbTime ? #00E676 : isLowProbTime ? #FF5252 : textDim
    timeRiskBg = isHighProbTime ? color.new(#00E676, 90) : isLowProbTime ? color.new(#FF5252, 90) : tableBgAlt
    table.cell(infoTable, 0, 19, "Time Risk", text_color=textDim, text_size=size.tiny, bgcolor=timeRiskBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 19, timeRiskText, text_color=timeRiskColor, text_size=size.tiny, bgcolor=timeRiskBg, text_halign=text.align_right)

    // â•â•â• DISCOUNT SENSITIVITY â•â•â•
    sensText = discountSensitivity ? "â—‰ SENS " + str.tostring(sensitivityCount) + " conf" : "â€”"
    sensColor = discountSensitivity ? #00E676 : textDim
    sensBg = discountSensitivity ? color.new(#00E676, 85) : tableBg
    table.cell(infoTable, 0, 20, "Sensitivity", text_color=textDim, text_size=size.tiny, bgcolor=sensBg, text_halign=text.align_left)
    table.cell(infoTable, 1, 20, sensText, text_color=sensColor, text_size=size.tiny, bgcolor=sensBg, text_halign=text.align_right)

    // â•â•â• TAKE THE TRADE SIGNAL â•â•â•
    takeItActive = takeTradeSignalBull or takeTradeSignalBear
    takeItText = takeItActive ? "ğŸš€ TAKE THE TRADE!" : "â€”"
    takeItColor = takeItActive ? #00FF00 : textDim
    takeItBg = takeItActive ? color.new(#00FF00, 80) : headerBg
    table.cell(infoTable, 0, 21, takeItText, text_color=takeItColor, text_size=size.small, bgcolor=takeItBg, text_halign=text.align_center)
    table.merge_cells(infoTable, 0, 21, 1, 21)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// "TAKE THE TRADE" VISUAL SIGNAL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Create the TAKE THE TRADE conditions (must be calculated outside barstate.islast block)
var bool takeTradeSignalBull = false
var bool takeTradeSignalBear = false

// Update on every bar for proper alerting
takeTradeCondition = (compositeTier == TIER_1 or compositeTier == TIER_2) and
                     (sbPrime or isMacroTime) and
                     isAnyTrigger and
                     inOTE

takeTradeSignalBull := takeTradeCondition and dolDirection == DIR_BULL
takeTradeSignalBear := takeTradeCondition and dolDirection == DIR_BEAR

// Plot TAKE THE TRADE signals (big, can't-miss-it labels)
plotshape(takeTradeSignalBull and barstate.isconfirmed, title="ğŸš€ TAKE THE TRADE Long",
     style=shape.labelup, location=location.belowbar,
     color=color.new(#00FF00, 0), text="ğŸš€ TAKE IT", textcolor=color.white, size=size.normal)

plotshape(takeTradeSignalBear and barstate.isconfirmed, title="ğŸš€ TAKE THE TRADE Short",
     style=shape.labeldown, location=location.abovebar,
     color=color.new(#FF0000, 0), text="ğŸš€ TAKE IT", textcolor=color.white, size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS (Enhanced with TAKE THE TRADE)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// ğŸš€ TAKE THE TRADE - Ultimate alert (highest priority)
alertcondition(takeTradeSignalBull, title="ğŸš€ TAKE THE TRADE Long", message="ğŸš€ TAKE THE TRADE LONG on {{ticker}} - All conditions aligned! Silver Bullet + OTE + Trigger!")
alertcondition(takeTradeSignalBear, title="ğŸš€ TAKE THE TRADE Short", message="ğŸš€ TAKE THE TRADE SHORT on {{ticker}} - All conditions aligned! Silver Bullet + OTE + Trigger!")

// Tier 1 alerts (most important)
alertcondition(tier1Bull, title="ğŸ† Tier 1 Long", message="ğŸ† TIER 1 LONG SETUP on {{ticker}} - Maximum confluence!")
alertcondition(tier1Bear, title="ğŸ† Tier 1 Short", message="ğŸ† TIER 1 SHORT SETUP on {{ticker}} - Maximum confluence!")

// 2022 Model alerts
alertcondition(model2022Bull, title="ğŸ“š 2022 Model Long", message="ğŸ“š 2022 MODEL LONG on {{ticker}} - Sweep + Displacement + FVG")
alertcondition(model2022Bear, title="ğŸ“š 2022 Model Short", message="ğŸ“š 2022 MODEL SHORT on {{ticker}} - Sweep + Displacement + FVG")

// Unicorn Model alerts (high conviction)
alertcondition(unicornBull, title="ğŸ¦„ Unicorn Long", message="ğŸ¦„ UNICORN SETUP LONG on {{ticker}} - Breaker + FVG confluence!")
alertcondition(unicornBear, title="ğŸ¦„ Unicorn Short", message="ğŸ¦„ UNICORN SETUP SHORT on {{ticker}} - Breaker + FVG confluence!")

// MMXM alerts
alertcondition(mmxmBullConfirm, title="ğŸ“Š MMXM Long", message="ğŸ“Š MMXM BUY MODEL on {{ticker}} - Market Maker sequence confirmed!")
alertcondition(mmxmBearConfirm, title="ğŸ“Š MMXM Short", message="ğŸ“Š MMXM SELL MODEL on {{ticker}} - Market Maker sequence confirmed!")

// AMD Fractal alerts
alertcondition(amdFractalBull, title="ğŸ”„ AMD Fractal Long", message="ğŸ”„ AMD FRACTAL LONG on {{ticker}} - Nested AMD alignment!")
alertcondition(amdFractalBear, title="ğŸ”„ AMD Fractal Short", message="ğŸ”„ AMD FRACTAL SHORT on {{ticker}} - Nested AMD alignment!")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PD ARRAY ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Suspension Block alerts (ICT's most powerful PD Array)
suspBlockBullAlert = hasSuspensionBlock and msDirection == DIR_BULL and inDiscount
suspBlockBearAlert = hasSuspensionBlock and msDirection == DIR_BEAR and inPremium
alertcondition(suspBlockBullAlert, title="â˜… Suspension Block Long", message="â˜… SUSPENSION BLOCK LONG on {{ticker}} - ICT's most powerful PD Array in discount zone!")
alertcondition(suspBlockBearAlert, title="â˜… Suspension Block Short", message="â˜… SUSPENSION BLOCK SHORT on {{ticker}} - ICT's most powerful PD Array in premium zone!")

// Volume Imbalance alerts
viLongAlert = hasVolumeImbalance and msDirection == DIR_BULL and inOTE
viShortAlert = hasVolumeImbalance and msDirection == DIR_BEAR and inOTE
alertcondition(viLongAlert, title="â—† Volume Imbalance Long", message="â—† VOLUME IMBALANCE LONG on {{ticker}} - Gap between candle bodies in OTE zone!")
alertcondition(viShortAlert, title="â—† Volume Imbalance Short", message="â—† VOLUME IMBALANCE SHORT on {{ticker}} - Gap between candle bodies in OTE zone!")

// Liquidity Void alerts
lvLongAlert = hasLiquidityVoid and msDirection == DIR_BULL
lvShortAlert = hasLiquidityVoid and msDirection == DIR_BEAR
alertcondition(lvLongAlert, title="â–¼ Liquidity Void Long", message="â–¼ LIQUIDITY VOID LONG on {{ticker}} - Large inefficiency to be filled!")
alertcondition(lvShortAlert, title="â–¼ Liquidity Void Short", message="â–¼ LIQUIDITY VOID SHORT on {{ticker}} - Large inefficiency to be filled!")

// NDOG (New Day Opening Gap) alerts
ndogActive = not na(ndogHigh) and not ndogFilled
ndogLongAlert = ndogActive and close > ndogCE and msDirection == DIR_BULL
ndogShortAlert = ndogActive and close < ndogCE and msDirection == DIR_BEAR
alertcondition(ndogLongAlert, title="â¬š NDOG Long", message="â¬š NDOG LONG on {{ticker}} - Price above New Day Opening Gap CE!")
alertcondition(ndogShortAlert, title="â¬š NDOG Short", message="â¬š NDOG SHORT on {{ticker}} - Price below New Day Opening Gap CE!")

// Combined PD Array Stack alert (multiple PD arrays aligned)
pdStackAlert = (hasSuspensionBlock ? 1 : 0) + (hasVolumeImbalance ? 1 : 0) + (hasLiquidityVoid ? 1 : 0) >= 2 and (msDirection == DIR_BULL or msDirection == DIR_BEAR)
alertcondition(pdStackAlert, title="ğŸ”¥ PD Array Stack", message="ğŸ”¥ MULTIPLE PD ARRAYS STACKED on {{ticker}} - High probability zone!")

// Suspension Block + OTE Combo (highest conviction)
suspOTECombo = hasSuspensionBlock and inOTE
alertcondition(suspOTECombo, title="ğŸ’ Suspension Block + OTE", message="ğŸ’ SUSPENSION BLOCK IN OTE on {{ticker}} - ICT's highest probability entry!")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW HIDDEN GEM ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Rejection Block alerts
rbLongAlert = hasRejectionBlock and msDirection == DIR_BULL and inDiscount
rbShortAlert = hasRejectionBlock and msDirection == DIR_BEAR and inPremium
alertcondition(rbLongAlert, title="â¬¡ Rejection Block Long", message="â¬¡ REJECTION BLOCK LONG on {{ticker}} - Wick rejection in discount zone!")
alertcondition(rbShortAlert, title="â¬¡ Rejection Block Short", message="â¬¡ REJECTION BLOCK SHORT on {{ticker}} - Wick rejection in premium zone!")

// 3-Day ORG Confluence alert
alertcondition(orgConfluenceZone, title="ğŸ“Š 3-Day ORG Confluence", message="ğŸ“Š 3-DAY ORG CONFLUENCE on {{ticker}} - Price respecting 3 days of opening range gaps!")

// Discount Sensitivity alert (high probability bounce)
alertcondition(discountSensitivity, title="ğŸ¯ Discount Sensitivity", message="ğŸ¯ DISCOUNT SENSITIVITY on {{ticker}} - 3+ confluences honoring gradient levels - Expect bounce!")

// Market Condition alerts
alertcondition(isJaggedMarket, title="âš¡ High Resistance Market", message="âš¡ HIGH RESISTANCE MARKET on {{ticker}} - Choppy conditions, reduce position size!")
alertcondition(isSmoothMarket, title="ğŸŒŠ Low Resistance Market", message="ğŸŒŠ LOW RESISTANCE MARKET on {{ticker}} - Smooth conditions, targets easier to reach!")

// Time-Based Risk alerts
alertcondition(isHighProbTime and (compositeTier == TIER_1 or compositeTier == TIER_2), title="ğŸ”¥ High Prob Time + Setup", message="ğŸ”¥ HIGH PROBABILITY TIME + SETUP on {{ticker}} - Best day/time with strong confluence!")
alertcondition(isLowProbTime and compositeScore >= 60, title="âš ï¸ Low Prob Time Warning", message="âš ï¸ LOW PROB TIME on {{ticker}} - Good setup but risky time window - Consider reducing size!")

// Wick Gradient CE test alert
alertcondition(hasWickGradientCE, title="ğŸ“ Wick Gradient CE Test", message="ğŸ“ WICK GRADIENT CE on {{ticker}} - Price testing ICT's notepad level!")

// Tuesday PRIME + Strong Setup (best combination)
tuesdayPrimeSetup = isTuesday and nyHour >= 8 and nyHour < 11 and (hasSuspensionBlock or hasModel2022)
alertcondition(tuesdayPrimeSetup, title="ğŸ† Tuesday PRIME Setup", message="ğŸ† TUESDAY PRIME SETUP on {{ticker}} - Best day + best setup = Maximum conviction!")

// Plot probability for external use
plot(dolProbability, title="DOL Probability", display=display.none)
plot(dolDirection, title="DOL Direction", display=display.none)
plot(compositeTier, title="Composite Tier", display=display.none)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END OF ATLAS ICT PRO v5.0 - GOD MODE [PAC-MAN EDITION]
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// Total ICT Concepts Integrated from The Cortex:
// 1. Market Structure (BOS/CHoCH) - 8,016 mentions
// 2. Liquidity (BSL/SSL/EQH/EQL) - 7,892 mentions
// 3. Premium/Discount Zones - 6,234 mentions
// 4. Order Blocks with Lifecycle - 5,891 mentions
// 5. Fair Value Gaps (FVG/IFVG) - 4,567 mentions
// 6. OTE Zone (62-79%) - 4,123 mentions
// 7. Killzones - 3,892 mentions
// 8. Silver Bullet Windows (FULL HOUR + Phase) - 3,456 mentions
// 9. Power of Three (AMD) - 3,234 mentions
// 10. 2022 Model - 2,891 mentions
// 11. Turtle Soup - 2,567 mentions
// 12. Judas Swing - 2,345 mentions
// 13. Displacement - 2,123 mentions
// 14. IPDA Data Ranges - 1,892 mentions
// 15. Midnight Open/True Day - 1,678 mentions
// 16. CBDR - 1,456 mentions
// 17. NWOG - 1,234 mentions
// 18. HTF Bias Alignment - Custom weight
// 19. Composite Scoring (Tier 1/2/3) - Custom system
//
// NEW PD ARRAYS (v5.0):
// 20. Suspension Block - ICT's MOST POWERFUL PD Array (VI at BOTH ends)
// 21. Volume Imbalance (VI) - Gap between consecutive candle bodies
// 22. Liquidity Void - Large displacement gap with no overlapping wicks
// 23. NDOG (New Day Opening Gap) - Gap from midnight
// 24. ORG (Opening Range Gap) - First session gap
// 25. Rejection Block - Long wick rejection zones (different from OB!)
//
// HIDDEN GEMS (v5.1 - From ICT Cortex Deep Dive):
// 26. High/Low Resistance Liquidity Run Detection - Market condition classifier
// 27. Wick Gradient Levels - ICT's notepad system (0/25/50/75/100% on wicks)
// 28. 3-Day ORG Confluence - ICT's lookback system for opening gaps
// 29. Time-Based Risk Adjustment - ICT's weekly rhythm (Tuesday PRIME, Wed 11am avoid)
// 30. Discount Sensitivity - 3+ confluences honoring gradient levels
//
// HIDDEN GEM COMBOS (21-27):
// 21. Rejection Block + OTE: +5 points
// 22. Rejection Block + FVG: +4 points
// 23. 3-Day ORG Confluence: +6 points
// 24. Discount Sensitivity: +7 points
// 25. Low Resistance Run: +5 points
// 26. Wick Gradient CE Test: +4 points
// 27. High Prob Time + Strong Setup: +6 points
//
// HIDDEN GEM COMBOS (28-35) - From Cortex Deep Dive:
// 28. Immediate Rebalance Pattern: +8 points (ICT: "very strong reaction")
// 29. Market Maker Model Alignment: +5 points (9/18 EMA model alignment)
// 30. Young Swing + Strong Setup: +4 points (1-3 day swings = more room)
// 31. Mature Swing Warning: -3 points PENALTY (5+ day swings = reversal risk)
// 32. Longest Wick CE Test: +5 points (ICT's special level)
// 33. Longest Wick CE + Direction: +3 points (CE direction alignment)
// 34. IOF Drill Entry: +6 points (partial FVG fill entry)
// 35. IOF Drill + OTE + Killzone: +4 points (maximum precision)
//
// HIDDEN GEM FEATURES (v5.2):
// - Immediate Rebalance Pattern - Gap â†’ Sweep â†’ Reverse pattern
// - Market Maker Buy/Sell Model - 9/18 EMA state for bias
// - Power of Three Maturity - Young vs Mature swing classification
// - Longest Wick CE - Find THE longest wick, use ONLY its CE
// - IOF Drill Entry - Partial (50%) FVG fill entry
//
// DOL PATH PULLBACK PRIORITIES:
// 0. Suspension Block (â˜…) - Bright Green
// 1. Fair Value Gap (â—ˆ) - Purple
// 2. Volume Imbalance (â—†) - Magenta
// 3. Order Block (â– ) - Blue
// 4. Liquidity Void (â–¼) - Red
// 5. Liquidity Sweep (â—‡) - Orange
// 6. Rejection Block (â—) - Amber (ICT Hidden Gem)
// 7. Longest Wick CE (âŠ•) - Teal (ICT Hidden Gem)
// 8. Wick Gradient CE (âŠ™) - Light Purple (ICT Notepad)
// 9. Equilibrium (â—¦) - Default
// 10. OTE Zone (â—‹) - Default
//
// PAC-MAN THEME ELEMENTS:
// ğŸŸ¡ PAC-MAN = Current price position
// ğŸ‘» GHOSTS = Institutional liquidity targets (BSL/SSL)
// âš« PELLETS = Equal Highs/Lows (small liquidity)
// ğŸŒ€ SPAWN ZONE = OTE retracement area
// ğŸ¯ MAZE PATH = DOL direction arrow
// ğŸ BONUS = NWOG zones
// ğŸ† TIER MEDALS = Composite confluence signals
// â˜… SUSPENSION BLOCK = Highest priority pullback target
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
